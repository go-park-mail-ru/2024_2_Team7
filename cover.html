
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">kudago/cmd/auth/config/config.go (0.0%)</option>
				
				<option value="file1">kudago/cmd/auth/main.go (0.0%)</option>
				
				<option value="file2">kudago/cmd/event/config/config.go (0.0%)</option>
				
				<option value="file3">kudago/cmd/event/main.go (0.0%)</option>
				
				<option value="file4">kudago/cmd/image/config/config.go (0.0%)</option>
				
				<option value="file5">kudago/cmd/image/main.go (0.0%)</option>
				
				<option value="file6">kudago/cmd/notification/config/config.go (0.0%)</option>
				
				<option value="file7">kudago/cmd/notification/main.go (0.0%)</option>
				
				<option value="file8">kudago/cmd/server/config/config.go (0.0%)</option>
				
				<option value="file9">kudago/cmd/server/main.go (0.0%)</option>
				
				<option value="file10">kudago/cmd/user/config/config.go (0.0%)</option>
				
				<option value="file11">kudago/cmd/user/main.go (0.0%)</option>
				
				<option value="file12">kudago/docs/docs.go (0.0%)</option>
				
				<option value="file13">kudago/internal/auth/api/auth.pb.go (4.1%)</option>
				
				<option value="file14">kudago/internal/auth/api/auth_grpc.pb.go (0.0%)</option>
				
				<option value="file15">kudago/internal/auth/grpc/auth.go (100.0%)</option>
				
				<option value="file16">kudago/internal/auth/grpc/check_session.go (100.0%)</option>
				
				<option value="file17">kudago/internal/auth/grpc/create_session.go (100.0%)</option>
				
				<option value="file18">kudago/internal/auth/grpc/get_user.go (100.0%)</option>
				
				<option value="file19">kudago/internal/auth/grpc/login.go (100.0%)</option>
				
				<option value="file20">kudago/internal/auth/grpc/logout.go (100.0%)</option>
				
				<option value="file21">kudago/internal/auth/grpc/register.go (100.0%)</option>
				
				<option value="file22">kudago/internal/auth/grpc/tests/mocks/auth.go (100.0%)</option>
				
				<option value="file23">kudago/internal/auth/repository/auth/check_credentials.go (0.0%)</option>
				
				<option value="file24">kudago/internal/auth/repository/auth/create_user.go (0.0%)</option>
				
				<option value="file25">kudago/internal/auth/repository/auth/get_user_by_email_or_username.go (0.0%)</option>
				
				<option value="file26">kudago/internal/auth/repository/auth/get_user_by_id.go (0.0%)</option>
				
				<option value="file27">kudago/internal/auth/repository/auth/users.go (0.0%)</option>
				
				<option value="file28">kudago/internal/auth/repository/session/session.go (50.0%)</option>
				
				<option value="file29">kudago/internal/auth/service/auth.go (75.0%)</option>
				
				<option value="file30">kudago/internal/auth/service/mocks/auth.go (56.2%)</option>
				
				<option value="file31">kudago/internal/event/api/event.pb.go (2.0%)</option>
				
				<option value="file32">kudago/internal/event/api/event_grpc.pb.go (0.0%)</option>
				
				<option value="file33">kudago/internal/event/grpc/add_event.go (100.0%)</option>
				
				<option value="file34">kudago/internal/event/grpc/add_event_to_favorites.go (100.0%)</option>
				
				<option value="file35">kudago/internal/event/grpc/delete_event.go (77.8%)</option>
				
				<option value="file36">kudago/internal/event/grpc/delete_event_from_favorites.go (87.5%)</option>
				
				<option value="file37">kudago/internal/event/grpc/event.go (100.0%)</option>
				
				<option value="file38">kudago/internal/event/grpc/get_categories.go (100.0%)</option>
				
				<option value="file39">kudago/internal/event/grpc/get_event_by_id.go (100.0%)</option>
				
				<option value="file40">kudago/internal/event/grpc/get_events_by_category.go (100.0%)</option>
				
				<option value="file41">kudago/internal/event/grpc/get_events_by_ids.go (0.0%)</option>
				
				<option value="file42">kudago/internal/event/grpc/get_events_by_user.go (100.0%)</option>
				
				<option value="file43">kudago/internal/event/grpc/get_favorites.go (100.0%)</option>
				
				<option value="file44">kudago/internal/event/grpc/get_past_events.go (100.0%)</option>
				
				<option value="file45">kudago/internal/event/grpc/get_subscribers_ids.go (100.0%)</option>
				
				<option value="file46">kudago/internal/event/grpc/get_subscription_events.go (100.0%)</option>
				
				<option value="file47">kudago/internal/event/grpc/get_upcoming_events.go (100.0%)</option>
				
				<option value="file48">kudago/internal/event/grpc/get_user_ids_by_favorite.go (100.0%)</option>
				
				<option value="file49">kudago/internal/event/grpc/search_events.go (100.0%)</option>
				
				<option value="file50">kudago/internal/event/grpc/tests/mocks/event.go (94.4%)</option>
				
				<option value="file51">kudago/internal/event/grpc/update_event.go (100.0%)</option>
				
				<option value="file52">kudago/internal/event/repository/add_to_favorites.go (0.0%)</option>
				
				<option value="file53">kudago/internal/event/repository/create_event.go (0.0%)</option>
				
				<option value="file54">kudago/internal/event/repository/delete_event.go (100.0%)</option>
				
				<option value="file55">kudago/internal/event/repository/delete_event_from_favorites.go (100.0%)</option>
				
				<option value="file56">kudago/internal/event/repository/events.go (1.8%)</option>
				
				<option value="file57">kudago/internal/event/repository/get_categories.go (91.7%)</option>
				
				<option value="file58">kudago/internal/event/repository/get_event_by_id.go (0.0%)</option>
				
				<option value="file59">kudago/internal/event/repository/get_events_by_category.go (0.0%)</option>
				
				<option value="file60">kudago/internal/event/repository/get_events_by_ids.go (0.0%)</option>
				
				<option value="file61">kudago/internal/event/repository/get_events_by_user.go (0.0%)</option>
				
				<option value="file62">kudago/internal/event/repository/get_favorites.go (0.0%)</option>
				
				<option value="file63">kudago/internal/event/repository/get_past_events.go (0.0%)</option>
				
				<option value="file64">kudago/internal/event/repository/get_subscribers.go (0.0%)</option>
				
				<option value="file65">kudago/internal/event/repository/get_subscription_events.go (0.0%)</option>
				
				<option value="file66">kudago/internal/event/repository/get_upcoming_events.go (0.0%)</option>
				
				<option value="file67">kudago/internal/event/repository/get_user_ids_by_favorite.go (0.0%)</option>
				
				<option value="file68">kudago/internal/event/repository/mocks/mocks.go (0.0%)</option>
				
				<option value="file69">kudago/internal/event/repository/mocks/mocks_tx.go (0.0%)</option>
				
				<option value="file70">kudago/internal/event/repository/search_events.go (0.0%)</option>
				
				<option value="file71">kudago/internal/event/repository/update_event.go (0.0%)</option>
				
				<option value="file72">kudago/internal/event/service/event.go (39.1%)</option>
				
				<option value="file73">kudago/internal/event/service/mocks/events.go (28.2%)</option>
				
				<option value="file74">kudago/internal/gateway/auth/auth.go (32.4%)</option>
				
				<option value="file75">kudago/internal/gateway/auth/auth_easyjson.go (44.2%)</option>
				
				<option value="file76">kudago/internal/gateway/auth/check_session.go (84.2%)</option>
				
				<option value="file77">kudago/internal/gateway/auth/login.go (73.0%)</option>
				
				<option value="file78">kudago/internal/gateway/auth/logout.go (100.0%)</option>
				
				<option value="file79">kudago/internal/gateway/auth/mocks/auth.go (30.1%)</option>
				
				<option value="file80">kudago/internal/gateway/auth/register.go (26.5%)</option>
				
				<option value="file81">kudago/internal/gateway/errors/errors_easyjson.go (29.3%)</option>
				
				<option value="file82">kudago/internal/gateway/event/add_event.go (0.0%)</option>
				
				<option value="file83">kudago/internal/gateway/event/add_event_to_favorites.go (82.6%)</option>
				
				<option value="file84">kudago/internal/gateway/event/create_invitation_notification.go (0.0%)</option>
				
				<option value="file85">kudago/internal/gateway/event/delete_event.go (82.6%)</option>
				
				<option value="file86">kudago/internal/gateway/event/delete_event_from_favorites.go (81.0%)</option>
				
				<option value="file87">kudago/internal/gateway/event/event.go (20.9%)</option>
				
				<option value="file88">kudago/internal/gateway/event/event_easyjson.go (52.0%)</option>
				
				<option value="file89">kudago/internal/gateway/event/get_categories.go (100.0%)</option>
				
				<option value="file90">kudago/internal/gateway/event/get_event_by_id.go (88.2%)</option>
				
				<option value="file91">kudago/internal/gateway/event/get_events_by_category.go (90.9%)</option>
				
				<option value="file92">kudago/internal/gateway/event/get_events_by_ids.go (90.0%)</option>
				
				<option value="file93">kudago/internal/gateway/event/get_events_by_user.go (100.0%)</option>
				
				<option value="file94">kudago/internal/gateway/event/get_favorites.go (84.6%)</option>
				
				<option value="file95">kudago/internal/gateway/event/get_notifications.go (79.3%)</option>
				
				<option value="file96">kudago/internal/gateway/event/get_past_events.go (100.0%)</option>
				
				<option value="file97">kudago/internal/gateway/event/get_subsciption_events.go (100.0%)</option>
				
				<option value="file98">kudago/internal/gateway/event/get_upcoming_events.go (100.0%)</option>
				
				<option value="file99">kudago/internal/gateway/event/mocks/event.go (41.1%)</option>
				
				<option value="file100">kudago/internal/gateway/event/mocks/notification.go (18.9%)</option>
				
				<option value="file101">kudago/internal/gateway/event/search.go (100.0%)</option>
				
				<option value="file102">kudago/internal/gateway/event/update_event.go (0.0%)</option>
				
				<option value="file103">kudago/internal/gateway/user/get_subscribers.go (100.0%)</option>
				
				<option value="file104">kudago/internal/gateway/user/get_subscriptions.go (100.0%)</option>
				
				<option value="file105">kudago/internal/gateway/user/mocks/user.go (42.2%)</option>
				
				<option value="file106">kudago/internal/gateway/user/profile.go (100.0%)</option>
				
				<option value="file107">kudago/internal/gateway/user/subscribe.go (82.8%)</option>
				
				<option value="file108">kudago/internal/gateway/user/unsubscribe.go (91.7%)</option>
				
				<option value="file109">kudago/internal/gateway/user/update_user.go (0.0%)</option>
				
				<option value="file110">kudago/internal/gateway/user/user.go (53.8%)</option>
				
				<option value="file111">kudago/internal/gateway/user/user_easyjson.go (50.8%)</option>
				
				<option value="file112">kudago/internal/gateway/utils/utils.go (29.5%)</option>
				
				<option value="file113">kudago/internal/gateway/utils/utils_easyjson.go (0.0%)</option>
				
				<option value="file114">kudago/internal/image/api/image.pb.go (10.5%)</option>
				
				<option value="file115">kudago/internal/image/api/image_grpc.pb.go (0.0%)</option>
				
				<option value="file116">kudago/internal/image/grpc/delete_image.go (100.0%)</option>
				
				<option value="file117">kudago/internal/image/grpc/image.go (100.0%)</option>
				
				<option value="file118">kudago/internal/image/grpc/tests/mocks/image.go (100.0%)</option>
				
				<option value="file119">kudago/internal/image/grpc/upload_image.go (88.9%)</option>
				
				<option value="file120">kudago/internal/image/repository/image.go (0.0%)</option>
				
				<option value="file121">kudago/internal/interceptors/metrics.go (0.0%)</option>
				
				<option value="file122">kudago/internal/interceptors/panic.go (0.0%)</option>
				
				<option value="file123">kudago/internal/logger/logger.go (41.7%)</option>
				
				<option value="file124">kudago/internal/metrics/metrics.go (0.0%)</option>
				
				<option value="file125">kudago/internal/middleware/auth.go (0.0%)</option>
				
				<option value="file126">kudago/internal/middleware/cors.go (0.0%)</option>
				
				<option value="file127">kudago/internal/middleware/logging.go (0.0%)</option>
				
				<option value="file128">kudago/internal/middleware/metrics.go (0.0%)</option>
				
				<option value="file129">kudago/internal/middleware/panic.go (0.0%)</option>
				
				<option value="file130">kudago/internal/models/errors.go (0.0%)</option>
				
				<option value="file131">kudago/internal/models/notification_easyjson.go (72.2%)</option>
				
				<option value="file132">kudago/internal/models/user_easyjson.go (18.9%)</option>
				
				<option value="file133">kudago/internal/notification/api/notification.pb.go (6.7%)</option>
				
				<option value="file134">kudago/internal/notification/api/notification_grpc.pb.go (0.0%)</option>
				
				<option value="file135">kudago/internal/notification/grpc/notification.go (92.9%)</option>
				
				<option value="file136">kudago/internal/notification/grpc/tests/mocks/notification.go (100.0%)</option>
				
				<option value="file137">kudago/internal/notification/repository/notification.go (0.0%)</option>
				
				<option value="file138">kudago/internal/repository/postgres/init.go (0.0%)</option>
				
				<option value="file139">kudago/internal/repository/redis/init.go (0.0%)</option>
				
				<option value="file140">kudago/internal/user/api/user.pb.go (5.4%)</option>
				
				<option value="file141">kudago/internal/user/api/user_grpc.pb.go (0.0%)</option>
				
				<option value="file142">kudago/internal/user/grpc/get_profile.go (100.0%)</option>
				
				<option value="file143">kudago/internal/user/grpc/get_subscribers.go (100.0%)</option>
				
				<option value="file144">kudago/internal/user/grpc/get_subscriptions.go (100.0%)</option>
				
				<option value="file145">kudago/internal/user/grpc/subscribe.go (100.0%)</option>
				
				<option value="file146">kudago/internal/user/grpc/tests/mocks/user.go (100.0%)</option>
				
				<option value="file147">kudago/internal/user/grpc/unsubscribe.go (100.0%)</option>
				
				<option value="file148">kudago/internal/user/grpc/update_user.go (91.7%)</option>
				
				<option value="file149">kudago/internal/user/grpc/user.go (100.0%)</option>
				
				<option value="file150">kudago/internal/user/repository/get_subscribers.go (85.7%)</option>
				
				<option value="file151">kudago/internal/user/repository/get_subscriptions.go (85.7%)</option>
				
				<option value="file152">kudago/internal/user/repository/get_user_by_email_or_username.go (83.3%)</option>
				
				<option value="file153">kudago/internal/user/repository/get_user_by_id.go (100.0%)</option>
				
				<option value="file154">kudago/internal/user/repository/subscribe.go (0.0%)</option>
				
				<option value="file155">kudago/internal/user/repository/unsubscribe.go (100.0%)</option>
				
				<option value="file156">kudago/internal/user/repository/update_user.go (0.0%)</option>
				
				<option value="file157">kudago/internal/user/repository/users.go (55.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "errors"
        "os"

        "kudago/internal/repository/postgres"

        sessionRepository "kudago/internal/repository/redis"
)

type Config struct {
        PostgresConfig postgres.PostgresConfig
        RedisConfig    sessionRepository.RedisConfig
        ServiceAddr    string
}

func LoadConfig() (Config, error) <span class="cov0" title="0">{
        var conf Config

        redisConfig, err := sessionRepository.GetRedisConfig()
        if err != nil </span><span class="cov0" title="0">{
                return Config{}, errors.New("Failed to connect to the redis database")
        }</span>
        <span class="cov0" title="0">conf.RedisConfig = *redisConfig

        postgresConfig, err := postgres.GetPostgresConfig()
        if err != nil </span><span class="cov0" title="0">{
                return Config{}, errors.New("Failed to connect to the postgres database")
        }</span>
        <span class="cov0" title="0">conf.PostgresConfig = postgresConfig

        conf.ServiceAddr = os.Getenv("AUTH_SERVICE_ADDR")
        if conf.ServiceAddr == "" </span><span class="cov0" title="0">{
                return Config{}, errors.New("Failed to get service address")
        }</span>

        <span class="cov0" title="0">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "log"
        "net"
        "net/http"

        "kudago/cmd/auth/config"
        proto "kudago/internal/auth/api"
        grpcAuth "kudago/internal/auth/grpc"
        authRepository "kudago/internal/auth/repository/auth"
        sessionRepository "kudago/internal/auth/repository/session"
        authService "kudago/internal/auth/service"
        "kudago/internal/interceptors"
        "kudago/internal/logger"
        "kudago/internal/metrics"
        "kudago/internal/repository/postgres"

        grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"

        "google.golang.org/grpc"
)

func main() <span class="cov0" title="0">{
        conf, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get config: %v", err)
        }</span>

        <span class="cov0" title="0">appLogger, err := logger.NewLogger()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Server failed to start logger: %v", err)
        }</span>
        <span class="cov0" title="0">defer appLogger.Logger.Sync()

        pool, err := postgres.InitPostgres(conf.PostgresConfig, appLogger)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to the postgres database: %v", err)
        }</span>
        <span class="cov0" title="0">defer pool.Close()

        listener, err := net.Listen("tcp", conf.ServiceAddr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Не удалось запустить gRPC-сервер auth: %v", err)
        }</span>

        <span class="cov0" title="0">userDB := authRepository.NewDB(pool)
        sessionDB := sessionRepository.NewDB(&amp;conf.RedisConfig)

        authService := authService.NewService(userDB)
        authServer := grpcAuth.NewServerAPI(authService, sessionDB, appLogger)
        metrics.InitMetrics()

        grpc_prometheus.EnableHandlingTimeHistogram()
        grpcServer := grpc.NewServer(
                grpc.ChainUnaryInterceptor(
                        interceptors.MetricsUnaryInterceptor("auth_service"),
                        interceptors.PanicRecoveryInterceptor,
                ),
        )

        proto.RegisterAuthServiceServer(grpcServer, authServer)

        go func() </span><span class="cov0" title="0">{
                http.Handle("/metrics", promhttp.Handler())
                metricsAddr := ":9091"
                log.Printf("Метрики доступны на %s/metrics", metricsAddr)
                if err := http.ListenAndServe(metricsAddr, nil); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Не удалось запустить HTTP-сервер для метрик: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">log.Printf("gRPC сервер запущен на %s", conf.ServiceAddr)
        if err := grpcServer.Serve(listener); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Ошибка запуска gRPC-сервера auth: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "errors"
        "os"

        "kudago/internal/repository/postgres"

        "github.com/joho/godotenv"
)

type Config struct {
        PostgresConfig postgres.PostgresConfig
        ServiceAddr    string
}

func LoadConfig() (Config, error) <span class="cov0" title="0">{
        var conf Config
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        <span class="cov0" title="0">postgresConfig, err := postgres.GetPostgresConfig()
        if err != nil </span><span class="cov0" title="0">{
                return Config{}, errors.New("Failed to connect to the postgres database")
        }</span>
        <span class="cov0" title="0">conf.PostgresConfig = postgresConfig

        conf.ServiceAddr = os.Getenv("EVENT_SERVICE_ADDR")
        if conf.ServiceAddr == "" </span><span class="cov0" title="0">{
                return Config{}, errors.New("Failed to get service address")
        }</span>

        <span class="cov0" title="0">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "log"
        "net"
        "net/http"

        "kudago/cmd/event/config"
        proto "kudago/internal/event/api"
        grpcEvent "kudago/internal/event/grpc"
        eventRepository "kudago/internal/event/repository"
        eventService "kudago/internal/event/service"
        "kudago/internal/interceptors"
        "kudago/internal/logger"
        "kudago/internal/metrics"
        "kudago/internal/repository/postgres"

        grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"

        "google.golang.org/grpc"
)

func main() <span class="cov0" title="0">{
        conf, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get config: %v", err)
        }</span>

        <span class="cov0" title="0">appLogger, err := logger.NewLogger()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Server failed to start logger: %v", err)
        }</span>
        <span class="cov0" title="0">defer appLogger.Logger.Sync()

        pool, err := postgres.InitPostgres(conf.PostgresConfig, appLogger)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to the postgres database: %v", err)
        }</span>
        <span class="cov0" title="0">defer pool.Close()

        listener, err := net.Listen("tcp", conf.ServiceAddr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Не удалось запустить gRPC-сервер user: %v", err)
        }</span>

        <span class="cov0" title="0">eventDB := eventRepository.NewDB(pool)
        eventService := eventService.NewService(eventDB)
        metrics.InitMetrics()

        grpc_prometheus.EnableHandlingTimeHistogram()
        grpcServer := grpc.NewServer(
                grpc.ChainUnaryInterceptor(
                        interceptors.MetricsUnaryInterceptor("event_service"),
                        interceptors.PanicRecoveryInterceptor,
                ),
        )

        eventServer := grpcEvent.NewServerAPI(&amp;eventService, eventDB, appLogger)
        proto.RegisterEventServiceServer(grpcServer, eventServer)

        grpc_prometheus.Register(grpcServer)

        go func() </span><span class="cov0" title="0">{
                http.Handle("/metrics", promhttp.Handler())
                metricsAddr := ":9093"
                log.Printf("Метрики доступны на %s/metrics", metricsAddr)
                if err := http.ListenAndServe(metricsAddr, nil); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Не удалось запустить HTTP-сервер для метрик: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">log.Printf("gRPC сервер запущен на %s", conf.ServiceAddr)
        if err := grpcServer.Serve(listener); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Ошибка запуска gRPC-сервера: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "errors"
        "os"

        imageRepository "kudago/internal/image/repository"

        "github.com/joho/godotenv"
)

type Config struct {
        ImageConfig imageRepository.ImageConfig
        ServiceAddr string
}

func LoadConfig() (Config, error) <span class="cov0" title="0">{
        var conf Config
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        <span class="cov0" title="0">conf.ImageConfig = imageRepository.ImageConfig{
                Path: "./static/images",
        }

        conf.ServiceAddr = os.Getenv("IMAGE_SERVICE_ADDR")
        if conf.ServiceAddr == "" </span><span class="cov0" title="0">{
                return Config{}, errors.New("Failed to get service address")
        }</span>

        <span class="cov0" title="0">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "log"
        "net"
        "net/http"

        "kudago/cmd/image/config"
        proto "kudago/internal/image/api"
        grpcImage "kudago/internal/image/grpc"
        "kudago/internal/interceptors"
        "kudago/internal/logger"
        "kudago/internal/metrics"

        grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "google.golang.org/grpc"
        imageRepository "kudago/internal/image/repository"
)

func main() <span class="cov0" title="0">{
        conf, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get config: %v", err)
        }</span>

        <span class="cov0" title="0">appLogger, err := logger.NewLogger()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Server failed to start logger: %v", err)
        }</span>
        <span class="cov0" title="0">defer appLogger.Logger.Sync()

        listener, err := net.Listen("tcp", conf.ServiceAddr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Не удалось запустить gRPC-сервер image: %v", err)
        }</span>

        <span class="cov0" title="0">imageDB := imageRepository.NewDB(conf.ImageConfig)

        imageServer := grpcImage.NewServerAPI(imageDB, appLogger)
        metrics.InitMetrics()

        grpc_prometheus.EnableHandlingTimeHistogram()
        grpcServer := grpc.NewServer(
                grpc.ChainUnaryInterceptor(
                        interceptors.MetricsUnaryInterceptor("auth_service"),
                        interceptors.PanicRecoveryInterceptor,
                ),
        )

        proto.RegisterImageServiceServer(grpcServer, imageServer)

        go func() </span><span class="cov0" title="0">{
                http.Handle("/metrics", promhttp.Handler())
                metricsAddr := ":9094"
                log.Printf("Метрики доступны на %s/metrics", metricsAddr)
                if err := http.ListenAndServe(metricsAddr, nil); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Не удалось запустить HTTP-сервер для метрик: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">log.Printf("gRPC сервер запущен на %s", conf.ServiceAddr)
        if err := grpcServer.Serve(listener); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Ошибка запуска gRPC-сервера image: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "errors"
        "os"

        "kudago/internal/repository/postgres"

        "github.com/joho/godotenv"
)

type Config struct {
        PostgresConfig postgres.PostgresConfig
        ServiceAddr    string
}

func LoadConfig() (Config, error) <span class="cov0" title="0">{
        var conf Config
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        <span class="cov0" title="0">postgresConfig, err := postgres.GetPostgresConfig()
        if err != nil </span><span class="cov0" title="0">{
                return Config{}, errors.New("Failed to connect to the postgres database")
        }</span>
        <span class="cov0" title="0">conf.PostgresConfig = postgresConfig

        conf.ServiceAddr = os.Getenv("NOTIFICATION_SERVICE_ADDR")
        if conf.ServiceAddr == "" </span><span class="cov0" title="0">{
                return Config{}, errors.New("Failed to get service address")
        }</span>

        <span class="cov0" title="0">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "log"
        "net"
        "net/http"

        "kudago/cmd/notification/config"
        "kudago/internal/logger"
        "kudago/internal/metrics"
        "kudago/internal/repository/postgres"

        grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
        "kudago/internal/interceptors"
        proto "kudago/internal/notification/api"
        grpcUser "kudago/internal/notification/grpc"
        notificationRepository "kudago/internal/notification/repository"

        "github.com/prometheus/client_golang/prometheus/promhttp"
        "google.golang.org/grpc"
)

func main() <span class="cov0" title="0">{
        conf, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get config: %v", err)
        }</span>

        <span class="cov0" title="0">appLogger, err := logger.NewLogger()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Server failed to start logger: %v", err)
        }</span>
        <span class="cov0" title="0">defer appLogger.Logger.Sync()

        pool, err := postgres.InitPostgres(conf.PostgresConfig, appLogger)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to the postgres database: %v", err)
        }</span>
        <span class="cov0" title="0">defer pool.Close()

        listener, err := net.Listen("tcp", conf.ServiceAddr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Не удалось запустить gRPC-сервер notification: %v", err)
        }</span>

        <span class="cov0" title="0">notificationDB := notificationRepository.NewDB(pool)

        notificationServer := grpcUser.NewServerAPI(notificationDB, appLogger)

        metrics.InitMetrics()

        grpc_prometheus.EnableHandlingTimeHistogram()
        grpcServer := grpc.NewServer(
                grpc.ChainUnaryInterceptor(
                        interceptors.MetricsUnaryInterceptor("notification_service"),
                        interceptors.PanicRecoveryInterceptor,
                ),
        )

        proto.RegisterNotificationServiceServer(grpcServer, notificationServer)

        go func() </span><span class="cov0" title="0">{
                http.Handle("/metrics", promhttp.Handler())
                metricsAddr := ":9096"
                log.Printf("Метрики доступны на %s/metrics", metricsAddr)
                if err := http.ListenAndServe(metricsAddr, nil); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Не удалось запустить HTTP-сервер для метрик: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">log.Printf("gRPC сервер запущен на %s", conf.ServiceAddr)
        if err := grpcServer.Serve(listener); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Ошибка запуска gRPC-сервера: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package config

import (
        "errors"
        "os"

        "github.com/joho/godotenv"
)

const (
        DefaultPort = "8080"
)

type Config struct {
        Port                    string
        AuthServiceAddr         string
        UserServiceAddr         string
        EventServiceAddr        string
        ImageServiceAddr        string
        CSATServiceAddr         string
        NotificationServiceAddr string
}

func LoadConfig() (Config, error) <span class="cov0" title="0">{
        var conf Config
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        <span class="cov0" title="0">port := os.Getenv("PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = DefaultPort
        }</span>
        <span class="cov0" title="0">conf.Port = port

        conf.AuthServiceAddr = os.Getenv("AUTH_SERVICE_ADDR")
        if conf.AuthServiceAddr == "" </span><span class="cov0" title="0">{
                return Config{}, errors.New("Failed to get auth service address")
        }</span>

        <span class="cov0" title="0">conf.UserServiceAddr = os.Getenv("USER_SERVICE_ADDR")
        if conf.UserServiceAddr == "" </span><span class="cov0" title="0">{
                return Config{}, errors.New("Failed to get user service address")
        }</span>

        <span class="cov0" title="0">conf.EventServiceAddr = os.Getenv("EVENT_SERVICE_ADDR")
        if conf.EventServiceAddr == "" </span><span class="cov0" title="0">{
                return Config{}, errors.New("Failed to get event service address")
        }</span>

        <span class="cov0" title="0">conf.ImageServiceAddr = os.Getenv("IMAGE_SERVICE_ADDR")
        if conf.ImageServiceAddr == "" </span><span class="cov0" title="0">{
                return Config{}, errors.New("Failed to get image service address")
        }</span>

        <span class="cov0" title="0">conf.CSATServiceAddr = os.Getenv("CSAT_SERVICE_ADDR")
        if conf.CSATServiceAddr == "" </span><span class="cov0" title="0">{
                return Config{}, errors.New("Failed to get csat service address")
        }</span>

        <span class="cov0" title="0">conf.NotificationServiceAddr = os.Getenv("NOTIFICATION_SERVICE_ADDR")
        if conf.NotificationServiceAddr == "" </span><span class="cov0" title="0">{
                return Config{}, errors.New("Failed to get notification service address")
        }</span>

        <span class="cov0" title="0">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "log"
        "net/http"

        "kudago/cmd/server/config"
        _ "kudago/docs"
        authHandlers "kudago/internal/gateway/auth"
        eventHandlers "kudago/internal/gateway/event"
        userHandlers "kudago/internal/gateway/user"

        "kudago/internal/logger"
        "kudago/internal/metrics"
        "kudago/internal/middleware"

        "github.com/gorilla/mux"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        httpSwagger "github.com/swaggo/http-swagger"
)

// swag init

// @title           Swagger Vihodnoy API
// @version         1.0
// @description     This is a description of the Vihodnoy server.
// @termsOfService  http://swagger.io/terms/

func main() <span class="cov0" title="0">{
        conf, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get config: %v", err)
        }</span>

        <span class="cov0" title="0">appLogger, err := logger.NewLogger()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Server failed to start logger: %v", err)
        }</span>
        <span class="cov0" title="0">defer appLogger.Logger.Sync()

        authHandler, err := authHandlers.NewHandlers(conf.AuthServiceAddr, conf.ImageServiceAddr, appLogger)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to auth service: %v", err)
        }</span>

        <span class="cov0" title="0">userHandler, err := userHandlers.NewHandlers(conf.UserServiceAddr, appLogger)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to user service: %v", err)
        }</span>

        <span class="cov0" title="0">eventHandler, err := eventHandlers.NewHandlers(conf.EventServiceAddr, conf.ImageServiceAddr, conf.NotificationServiceAddr, appLogger)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to event service: %v", err)
        }</span>

        <span class="cov0" title="0">r := mux.NewRouter()

        fs := http.FileServer(http.Dir("./static/"))
        r.PathPrefix("/static/").Handler(http.StripPrefix("/static/", fs))
        r.PathPrefix("/swagger/").Handler(httpSwagger.WrapHandler)

        r.HandleFunc("/register", authHandler.Register).Methods(http.MethodPost)
        r.HandleFunc("/login", authHandler.Login).Methods(http.MethodPost)
        r.HandleFunc("/logout", authHandler.Logout).Methods(http.MethodPost)
        r.HandleFunc("/session", authHandler.CheckSession).Methods(http.MethodGet)

        r.HandleFunc("/profile/{id:[0-9]+}", userHandler.Profile).Methods(http.MethodGet)
        r.HandleFunc("/profile", userHandler.UpdateUser).Methods(http.MethodPut)

        r.HandleFunc("/profile/subscribe/{id:[0-9]+}", userHandler.Subscribe).Methods(http.MethodPost)
        r.HandleFunc("/profile/subscribe", userHandler.GetSubscribers).Methods(http.MethodGet)
        r.HandleFunc("/profile/subscribe/{id:[0-9]+}", userHandler.GetSubscriptions).Methods(http.MethodGet)
        r.HandleFunc("/profile/subscribe/{id:[0-9]+}", userHandler.Unsubscribe).Methods(http.MethodDelete)

        r.HandleFunc("/events/{id:[0-9]+}", eventHandler.GetEventByID).Methods(http.MethodGet)
        r.HandleFunc("/events/categories/{category:[0-9]+}", eventHandler.GetEventsByCategory).Methods(http.MethodGet)
        r.HandleFunc("/events", eventHandler.GetUpcomingEvents).Methods(http.MethodGet)
        r.HandleFunc("/events/past", eventHandler.GetPastEvents).Methods(http.MethodGet)
        r.HandleFunc("/events/subscription", eventHandler.GetSubscriptionEvents).Methods(http.MethodGet)

        r.HandleFunc("/categories", eventHandler.GetCategories).Methods(http.MethodGet)
        r.HandleFunc("/events/user/{id:[0-9]+}", eventHandler.GetEventsByUser).Methods(http.MethodGet)
        r.HandleFunc("/events/{id:[0-9]+}", eventHandler.UpdateEvent).Methods(http.MethodPut)
        r.HandleFunc("/events/{id:[0-9]+}", eventHandler.DeleteEvent).Methods(http.MethodDelete)
        r.HandleFunc("/events", eventHandler.AddEvent).Methods(http.MethodPost)
        r.HandleFunc("/events/search", eventHandler.SearchEvents).Methods(http.MethodGet)
        r.HandleFunc("/events/favorites", eventHandler.GetFavorites).Methods(http.MethodGet)
        r.HandleFunc("/events/favorites/{id:[0-9]+}", eventHandler.AddEventToFavorites).Methods(http.MethodPost)
        r.HandleFunc("/events/favorites/{id:[0-9]+}", eventHandler.DeleteEventFromFavorites).Methods(http.MethodDelete)

        r.HandleFunc("/notification", eventHandler.GetNotifications).Methods(http.MethodGet)
        r.HandleFunc("/notification", eventHandler.CreateInvitationNotification).Methods(http.MethodPost)

        handlerWithAuth := middleware.AuthMiddleware(authHandler.AuthService, r)
        handlerWithCORS := middleware.CORSMiddleware(handlerWithAuth)
        handlerWithLogging := middleware.LoggingMiddleware(handlerWithCORS, appLogger.Logger)
        handlerWithMetrics := middleware.MetricsMiddleware(handlerWithLogging, "server")
        handler := middleware.PanicMiddleware(handlerWithMetrics)

        r.Handle("/metrics", promhttp.Handler())
        metrics.InitMetrics()

        err = http.ListenAndServe(":"+conf.Port, handler)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Server failed to start: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package config

import (
        "errors"
        "os"

        "kudago/internal/repository/postgres"

        "github.com/joho/godotenv"
)

type Config struct {
        PostgresConfig postgres.PostgresConfig
        ServiceAddr    string
}

func LoadConfig() (Config, error) <span class="cov0" title="0">{
        var conf Config
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        <span class="cov0" title="0">postgresConfig, err := postgres.GetPostgresConfig()
        if err != nil </span><span class="cov0" title="0">{
                return Config{}, errors.New("Failed to connect to the postgres database")
        }</span>
        <span class="cov0" title="0">conf.PostgresConfig = postgresConfig

        conf.ServiceAddr = os.Getenv("USER_SERVICE_ADDR")
        if conf.ServiceAddr == "" </span><span class="cov0" title="0">{
                return Config{}, errors.New("Failed to get service address")
        }</span>

        <span class="cov0" title="0">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
        "log"
        "net"
        "net/http"

        "kudago/cmd/user/config"
        "kudago/internal/interceptors"
        "kudago/internal/logger"
        "kudago/internal/metrics"
        "kudago/internal/repository/postgres"
        proto "kudago/internal/user/api"
        grpcEvent "kudago/internal/user/grpc"
        userRepository "kudago/internal/user/repository"

        grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"

        "google.golang.org/grpc"
)

func main() <span class="cov0" title="0">{
        conf, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get config: %v", err)
        }</span>

        <span class="cov0" title="0">appLogger, err := logger.NewLogger()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Server failed to start logger: %v", err)
        }</span>
        <span class="cov0" title="0">defer appLogger.Logger.Sync()

        pool, err := postgres.InitPostgres(conf.PostgresConfig, appLogger)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to the postgres database: %v", err)
        }</span>
        <span class="cov0" title="0">defer pool.Close()

        listener, err := net.Listen("tcp", conf.ServiceAddr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Не удалось запустить gRPC-сервер user: %v", err)
        }</span>

        <span class="cov0" title="0">userDB := userRepository.NewDB(pool)
        metrics.InitMetrics()

        grpc_prometheus.EnableHandlingTimeHistogram()
        grpcServer := grpc.NewServer(
                grpc.ChainUnaryInterceptor(
                        interceptors.MetricsUnaryInterceptor("user_service"),
                        interceptors.PanicRecoveryInterceptor,
                ),
        )

        userServer := grpcEvent.NewServerAPI(userDB, appLogger)
        proto.RegisterUserServiceServer(grpcServer, userServer)

        grpc_prometheus.Register(grpcServer)

        go func() </span><span class="cov0" title="0">{
                http.Handle("/metrics", promhttp.Handler())
                metricsAddr := ":9092"
                log.Printf("Метрики доступны на %s/metrics", metricsAddr)
                if err := http.ListenAndServe(metricsAddr, nil); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Не удалось запустить HTTP-сервер для метрик: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">log.Printf("gRPC сервер запущен на %s", conf.ServiceAddr)
        if err := grpcServer.Serve(listener); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Ошибка запуска gRPC-сервера: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/categories": {
            "get": {
                "description": "Получить список всех доступных категорий событий",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "categories"
                ],
                "summary": "Получить все категории",
                "responses": {
                    "200": {
                        "description": "Список категорий",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.Category"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    }
                }
            }
        },
        "/events": {
            "get": {
                "description": "Поиск событий по ключевым словам, датам, тегам и категории",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "events"
                ],
                "summary": "Поиск событий",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Номер страницы (по умолчанию 1)",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Количество событий на странице (по умолчанию 30)",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Ключевые слова для поиска",
                        "name": "query",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Дата начала события в формате YYYY-MM-DD",
                        "name": "event_start",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Дата окончания события в формате YYYY-MM-DD",
                        "name": "event_end",
                        "in": "query"
                    },
                    {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "collectionFormat": "csv",
                        "description": "Список тегов",
                        "name": "tags",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "ID категории",
                        "name": "category_id",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Список событий",
                        "schema": {
                            "$ref": "#/definitions/events.GetEventsResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid Data",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    }
                }
            },
            "post": {
                "description": "Создает новое событие в системе. Необходимо передать JSON-объект с данными события.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "events"
                ],
                "summary": "Создание события",
                "parameters": [
                    {
                        "description": "Данные для создания события",
                        "name": "json",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/events.NewEventRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Событие успешно создано",
                        "schema": {
                            "$ref": "#/definitions/events.NewEventResponse"
                        }
                    },
                    "400": {
                        "description": "Неверные данные",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "401": {
                        "description": "Неавторизован",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "500": {
                        "description": "Внутренняя ошибка сервера",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    }
                }
            }
        },
        "/events/categories/{category}": {
            "get": {
                "description": "Возвращает события по ID категории",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "events"
                ],
                "summary": "Получение событий по категори",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/events.GetEventsResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    }
                }
            }
        },
        "/events/favorites": {
            "get": {
                "description": "Возвращает избранные события",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "events"
                ],
                "summary": "Получение избранных событий",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Номер страницы (по умолчанию 1)",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Количество событий на странице (по умолчанию 30)",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/events.GetEventsResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    }
                }
            }
        },
        "/events/favorites/{id}": {
            "post": {
                "description": "Добавить событие в избранное",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "events"
                ],
                "summary": "Добавление события в изсбранное",
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    }
                }
            },
            "delete": {
                "description": "Удаляет событие из списка избранного",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "events"
                ],
                "summary": "Удаление события из избранного",
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    }
                }
            }
        },
        "/events/subscription": {
            "get": {
                "description": "Возвращает события пользователя",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "events"
                ],
                "summary": "Получение событий по подпискам пользователя",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/events.GetEventsResponse"
                        }
                    },
                    "403": {
                        "description": "Status forbidden",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    }
                }
            }
        },
        "/events/user/{id}": {
            "get": {
                "description": "Возвращает события пользователя",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "events"
                ],
                "summary": "Получение событий пользователя",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/events.GetEventsResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    }
                }
            }
        },
        "/events/{id}": {
            "get": {
                "description": "Возвращает информацию о событии по его идентификатору",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "events"
                ],
                "summary": "Получение события по ID",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/events.EventResponse"
                        }
                    },
                    "404": {
                        "description": "Event Not Found",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    }
                }
            },
            "put": {
                "description": "Обновляет данные существующего события. Необходимо передать JSON-объект с данными события и идентификатором события в URL.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "events"
                ],
                "summary": "Обновление события",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Идентификатор события",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Данные для обновления события",
                        "name": "json",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/events.NewEventRequest"
                        }
                    },
                    {
                        "type": "file",
                        "description": "Изображение события",
                        "name": "image",
                        "in": "formData"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Успешное обновление события",
                        "schema": {
                            "$ref": "#/definitions/events.NewEventResponse"
                        }
                    },
                    "400": {
                        "description": "Неверные данные",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "401": {
                        "description": "Неавторизован",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "403": {
                        "description": "Доступ запрещен",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "404": {
                        "description": "Событие не найдено",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "500": {
                        "description": "Внутренняя ошибка сервера",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    }
                }
            },
            "delete": {
                "description": "Удаляет существующее событие",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "events"
                ],
                "summary": "Удаление события",
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "403": {
                        "description": "Access Denied",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "404": {
                        "description": "Event Not Found",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    }
                }
            }
        },
        "/notifications": {
            "get": {
                "description": "Возвращает уведомления по идентификатору пользователя",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "notifications"
                ],
                "summary": "Получение уведомлений по ID пользователя",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/handlers.GetNotificationsResponse"
                        }
                    },
                    "404": {
                        "description": "Notification Not Found",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    }
                }
            },
            "post": {
                "description": "Создание уведомления",
                "consumes": [
                    "application/json"
                ],
                "tags": [
                    "notifications"
                ],
                "summary": "Создание уведомления",
                "parameters": [
                    {
                        "description": "Данные для создания уведомления",
                        "name": "json",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handlers.CreateNotificationRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Notification created successfully",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    }
                }
            }
        },
        "/profile/{id}": {
            "get": {
                "description": "Возвращает информацию о профиле текущего пользователя",
                "tags": [
                    "profile"
                ],
                "summary": "Профиль пользователя",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/handlers.ProfileResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    }
                }
            }
        },
        "/users/subscribe/{id}": {
            "post": {
                "description": "Подписка на пользователя",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Подписка на пользователя",
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "404": {
                        "description": "Invalid ID",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "409": {
                        "description": "Self subscription",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/httpErrors.HttpError"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "events.EventResponse": {
            "type": "object",
            "properties": {
                "Latitude": {
                    "type": "number"
                },
                "Longitude": {
                    "type": "number"
                },
                "author": {
                    "type": "integer"
                },
                "capacity": {
                    "type": "integer"
                },
                "category_id": {
                    "type": "integer"
                },
                "description": {
                    "type": "string"
                },
                "event_end": {
                    "type": "string"
                },
                "event_start": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "image": {
                    "type": "string"
                },
                "location": {
                    "type": "string"
                },
                "tag": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "events.GetEventsResponse": {
            "type": "object",
            "properties": {
                "events": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/events.EventResponse"
                    }
                }
            }
        },
        "events.NewEventRequest": {
            "type": "object",
            "properties": {
                "Latitude": {
                    "type": "number"
                },
                "Longitude": {
                    "type": "number"
                },
                "capacity": {
                    "type": "integer"
                },
                "category_id": {
                    "type": "integer"
                },
                "description": {
                    "type": "string"
                },
                "event_end": {
                    "type": "string"
                },
                "event_start": {
                    "type": "string"
                },
                "location": {
                    "type": "string"
                },
                "tag": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "events.NewEventResponse": {
            "type": "object",
            "properties": {
                "event": {
                    "$ref": "#/definitions/events.EventResponse"
                }
            }
        },
        "handlers.CreateNotificationRequest": {
            "type": "object",
            "properties": {
                "event_id": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                },
                "notify_at": {
                    "type": "string"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "handlers.GetNotificationsResponse": {
            "type": "object",
            "properties": {
                "notifications": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Notification"
                    }
                }
            }
        },
        "handlers.ProfileResponse": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "image": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "httpErrors.HttpError": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string"
                },
                "message": {
                    "type": "string"
                }
            }
        },
        "models.Category": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "models.Notification": {
            "type": "object",
            "properties": {
                "event_id": {
                    "type": "integer"
                },
                "id": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                },
                "notify_at": {
                    "type": "string"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "Swagger Vihodnoy API",
        Description:      "This is a description of the Vihodnoy server.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.35.2
//         protoc        v3.12.4
// source: auth.proto

package auth

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type RegisterRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Username  string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
        Email     string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
        Password  string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
        AvatarUrl string `protobuf:"bytes,4,opt,name=avatar_url,json=avatarUrl,proto3" json:"avatar_url,omitempty"`
}

func (x *RegisterRequest) Reset() <span class="cov0" title="0">{
        *x = RegisterRequest{}
        mi := &amp;file_auth_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RegisterRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterRequest.ProtoReflect.Descriptor instead.
func (*RegisterRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{0}
}</span>

func (x *RegisterRequest) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetAvatarUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AvatarUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LoginRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
        Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (x *LoginRequest) Reset() <span class="cov0" title="0">{
        *x = LoginRequest{}
        mi := &amp;file_auth_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LoginRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginRequest.ProtoReflect.Descriptor instead.
func (*LoginRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{1}
}</span>

func (x *LoginRequest) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CheckSessionRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Cookie string `protobuf:"bytes,1,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
}

func (x *CheckSessionRequest) Reset() <span class="cov0" title="0">{
        *x = CheckSessionRequest{}
        mi := &amp;file_auth_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CheckSessionRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CheckSessionRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CheckSessionRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CheckSessionRequest.ProtoReflect.Descriptor instead.
func (*CheckSessionRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{2}
}</span>

func (x *CheckSessionRequest) GetCookie() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Cookie
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetUserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (x *GetUserRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserRequest{}
        mi := &amp;file_auth_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserRequest.ProtoReflect.Descriptor instead.
func (*GetUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetUserRequest) GetID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type User struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ID        int32  `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
        Username  string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
        Email     string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
        AvatarUrl string `protobuf:"bytes,4,opt,name=avatar_url,json=avatarUrl,proto3" json:"avatar_url,omitempty"`
}

func (x *User) Reset() <span class="cov0" title="0">{
        *x = User{}
        mi := &amp;file_auth_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *User) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*User) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *User) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{4}
}</span>

func (x *User) GetID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *User) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetAvatarUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AvatarUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LogoutRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
}

func (x *LogoutRequest) Reset() <span class="cov0" title="0">{
        *x = LogoutRequest{}
        mi := &amp;file_auth_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LogoutRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogoutRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogoutRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogoutRequest.ProtoReflect.Descriptor instead.
func (*LogoutRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{5}
}</span>

func (x *LogoutRequest) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Empty struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *Empty) Reset() <span class="cov0" title="0">{
        *x = Empty{}
        mi := &amp;file_auth_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Empty) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Empty) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Empty) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Empty.ProtoReflect.Descriptor instead.
func (*Empty) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{6}
}</span>

type CreateSessionRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (x *CreateSessionRequest) Reset() <span class="cov0" title="0">{
        *x = CreateSessionRequest{}
        mi := &amp;file_auth_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateSessionRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateSessionRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateSessionRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateSessionRequest.ProtoReflect.Descriptor instead.
func (*CreateSessionRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{7}
}</span>

func (x *CreateSessionRequest) GetID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Session struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserID  int32  `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
        Token   string `protobuf:"bytes,2,opt,name=Token,proto3" json:"Token,omitempty"`
        Expires string `protobuf:"bytes,3,opt,name=Expires,proto3" json:"Expires,omitempty"`
}

func (x *Session) Reset() <span class="cov0" title="0">{
        *x = Session{}
        mi := &amp;file_auth_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Session) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Session) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Session) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Session.ProtoReflect.Descriptor instead.
func (*Session) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{8}
}</span>

func (x *Session) GetUserID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Session) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Session) GetExpires() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Expires
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteSessionRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Token string `protobuf:"bytes,1,opt,name=Token,proto3" json:"Token,omitempty"`
}

func (x *DeleteSessionRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteSessionRequest{}
        mi := &amp;file_auth_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteSessionRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteSessionRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteSessionRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteSessionRequest.ProtoReflect.Descriptor instead.
func (*DeleteSessionRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{9}
}</span>

func (x *DeleteSessionRequest) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_auth_proto protoreflect.FileDescriptor

var file_auth_proto_rawDesc = []byte{
        0x0a, 0x0a, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x04, 0x61, 0x75,
        0x74, 0x68, 0x22, 0x7e, 0x0a, 0x0f, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d,
        0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d,
        0x65, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77,
        0x6f, 0x72, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77,
        0x6f, 0x72, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72, 0x5f, 0x75, 0x72,
        0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72, 0x55,
        0x72, 0x6c, 0x22, 0x46, 0x0a, 0x0c, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1a,
        0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x2d, 0x0a, 0x13, 0x43, 0x68,
        0x65, 0x63, 0x6b, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x12, 0x16, 0x0a, 0x06, 0x43, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x06, 0x43, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x22, 0x20, 0x0a, 0x0e, 0x47, 0x65, 0x74,
        0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x49,
        0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x49, 0x44, 0x22, 0x67, 0x0a, 0x04, 0x55,
        0x73, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x02, 0x49, 0x44, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12,
        0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05,
        0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x1d, 0x0a, 0x0a, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72, 0x5f,
        0x75, 0x72, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x61, 0x76, 0x61, 0x74, 0x61,
        0x72, 0x55, 0x72, 0x6c, 0x22, 0x25, 0x0a, 0x0d, 0x4c, 0x6f, 0x67, 0x6f, 0x75, 0x74, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x07, 0x0a, 0x05, 0x45,
        0x6d, 0x70, 0x74, 0x79, 0x22, 0x26, 0x0a, 0x14, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x65,
        0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02,
        0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x49, 0x44, 0x22, 0x51, 0x0a, 0x07,
        0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x55, 0x73, 0x65, 0x72, 0x49,
        0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44, 0x12,
        0x14, 0x0a, 0x05, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05,
        0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x18, 0x0a, 0x07, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73,
        0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x22,
        0x2c, 0x0a, 0x14, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x54, 0x6f, 0x6b, 0x65, 0x6e,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x32, 0xee, 0x02,
        0x0a, 0x0b, 0x41, 0x75, 0x74, 0x68, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x2d, 0x0a,
        0x08, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x12, 0x15, 0x2e, 0x61, 0x75, 0x74, 0x68,
        0x2e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x0a, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x12, 0x27, 0x0a, 0x05,
        0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x12, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x4c, 0x6f, 0x67,
        0x69, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x0a, 0x2e, 0x61, 0x75, 0x74, 0x68,
        0x2e, 0x55, 0x73, 0x65, 0x72, 0x12, 0x38, 0x0a, 0x0c, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x53, 0x65,
        0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x19, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x43, 0x68, 0x65,
        0x63, 0x6b, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x0d, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12,
        0x2b, 0x0a, 0x07, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x12, 0x14, 0x2e, 0x61, 0x75, 0x74,
        0x68, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x0a, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x12, 0x2a, 0x0a, 0x06,
        0x4c, 0x6f, 0x67, 0x6f, 0x75, 0x74, 0x12, 0x13, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x4c, 0x6f,
        0x67, 0x6f, 0x75, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x0b, 0x2e, 0x61, 0x75,
        0x74, 0x68, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x3a, 0x0a, 0x0d, 0x43, 0x72, 0x65, 0x61,
        0x74, 0x65, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1a, 0x2e, 0x61, 0x75, 0x74, 0x68,
        0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x0d, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x53, 0x65, 0x73,
        0x73, 0x69, 0x6f, 0x6e, 0x12, 0x38, 0x0a, 0x0d, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x53, 0x65,
        0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1a, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x44, 0x65, 0x6c,
        0x65, 0x74, 0x65, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x0b, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x42, 0x09,
        0x5a, 0x07, 0x2e, 0x2f, 0x3b, 0x61, 0x75, 0x74, 0x68, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x33,
}

var (
        file_auth_proto_rawDescOnce sync.Once
        file_auth_proto_rawDescData = file_auth_proto_rawDesc
)

func file_auth_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_auth_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_auth_proto_rawDescData = protoimpl.X.CompressGZIP(file_auth_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_auth_proto_rawDescData</span>
}

var file_auth_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_auth_proto_goTypes = []any{
        (*RegisterRequest)(nil),      // 0: auth.RegisterRequest
        (*LoginRequest)(nil),         // 1: auth.LoginRequest
        (*CheckSessionRequest)(nil),  // 2: auth.CheckSessionRequest
        (*GetUserRequest)(nil),       // 3: auth.GetUserRequest
        (*User)(nil),                 // 4: auth.User
        (*LogoutRequest)(nil),        // 5: auth.LogoutRequest
        (*Empty)(nil),                // 6: auth.Empty
        (*CreateSessionRequest)(nil), // 7: auth.CreateSessionRequest
        (*Session)(nil),              // 8: auth.Session
        (*DeleteSessionRequest)(nil), // 9: auth.DeleteSessionRequest
}
var file_auth_proto_depIdxs = []int32{
        0, // 0: auth.AuthService.Register:input_type -&gt; auth.RegisterRequest
        1, // 1: auth.AuthService.Login:input_type -&gt; auth.LoginRequest
        2, // 2: auth.AuthService.CheckSession:input_type -&gt; auth.CheckSessionRequest
        3, // 3: auth.AuthService.GetUser:input_type -&gt; auth.GetUserRequest
        5, // 4: auth.AuthService.Logout:input_type -&gt; auth.LogoutRequest
        7, // 5: auth.AuthService.CreateSession:input_type -&gt; auth.CreateSessionRequest
        9, // 6: auth.AuthService.DeleteSession:input_type -&gt; auth.DeleteSessionRequest
        4, // 7: auth.AuthService.Register:output_type -&gt; auth.User
        4, // 8: auth.AuthService.Login:output_type -&gt; auth.User
        8, // 9: auth.AuthService.CheckSession:output_type -&gt; auth.Session
        4, // 10: auth.AuthService.GetUser:output_type -&gt; auth.User
        6, // 11: auth.AuthService.Logout:output_type -&gt; auth.Empty
        8, // 12: auth.AuthService.CreateSession:output_type -&gt; auth.Session
        6, // 13: auth.AuthService.DeleteSession:output_type -&gt; auth.Empty
        7, // [7:14] is the sub-list for method output_type
        0, // [0:7] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_auth_proto_init() }</span>
func file_auth_proto_init() <span class="cov8" title="1">{
        if File_auth_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_auth_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   10,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_auth_proto_goTypes,
                DependencyIndexes: file_auth_proto_depIdxs,
                MessageInfos:      file_auth_proto_msgTypes,
        }.Build()
        File_auth_proto = out.File
        file_auth_proto_rawDesc = nil
        file_auth_proto_goTypes = nil
        file_auth_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: auth.proto

package auth

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        AuthService_Register_FullMethodName      = "/auth.AuthService/Register"
        AuthService_Login_FullMethodName         = "/auth.AuthService/Login"
        AuthService_CheckSession_FullMethodName  = "/auth.AuthService/CheckSession"
        AuthService_GetUser_FullMethodName       = "/auth.AuthService/GetUser"
        AuthService_Logout_FullMethodName        = "/auth.AuthService/Logout"
        AuthService_CreateSession_FullMethodName = "/auth.AuthService/CreateSession"
        AuthService_DeleteSession_FullMethodName = "/auth.AuthService/DeleteSession"
)

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthServiceClient interface {
        Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*User, error)
        Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*User, error)
        CheckSession(ctx context.Context, in *CheckSessionRequest, opts ...grpc.CallOption) (*Session, error)
        GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*User, error)
        Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*Empty, error)
        CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*Session, error)
        DeleteSession(ctx context.Context, in *DeleteSessionRequest, opts ...grpc.CallOption) (*Empty, error)
}

type authServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient <span class="cov0" title="0">{
        return &amp;authServiceClient{cc}
}</span>

func (c *authServiceClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*User, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(User)
        err := c.cc.Invoke(ctx, AuthService_Register_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*User, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(User)
        err := c.cc.Invoke(ctx, AuthService_Login_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) CheckSession(ctx context.Context, in *CheckSessionRequest, opts ...grpc.CallOption) (*Session, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Session)
        err := c.cc.Invoke(ctx, AuthService_CheckSession_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*User, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(User)
        err := c.cc.Invoke(ctx, AuthService_GetUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Empty)
        err := c.cc.Invoke(ctx, AuthService_Logout_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*Session, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Session)
        err := c.cc.Invoke(ctx, AuthService_CreateSession_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) DeleteSession(ctx context.Context, in *DeleteSessionRequest, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Empty)
        err := c.cc.Invoke(ctx, AuthService_DeleteSession_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility.
type AuthServiceServer interface {
        Register(context.Context, *RegisterRequest) (*User, error)
        Login(context.Context, *LoginRequest) (*User, error)
        CheckSession(context.Context, *CheckSessionRequest) (*Session, error)
        GetUser(context.Context, *GetUserRequest) (*User, error)
        Logout(context.Context, *LogoutRequest) (*Empty, error)
        CreateSession(context.Context, *CreateSessionRequest) (*Session, error)
        DeleteSession(context.Context, *DeleteSessionRequest) (*Empty, error)
        mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthServiceServer struct{}

func (UnimplementedAuthServiceServer) Register(context.Context, *RegisterRequest) (*User, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}</span>
func (UnimplementedAuthServiceServer) Login(context.Context, *LoginRequest) (*User, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}</span>
func (UnimplementedAuthServiceServer) CheckSession(context.Context, *CheckSessionRequest) (*Session, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CheckSession not implemented")
}</span>
func (UnimplementedAuthServiceServer) GetUser(context.Context, *GetUserRequest) (*User, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}</span>
func (UnimplementedAuthServiceServer) Logout(context.Context, *LogoutRequest) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}</span>
func (UnimplementedAuthServiceServer) CreateSession(context.Context, *CreateSessionRequest) (*Session, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateSession not implemented")
}</span>
func (UnimplementedAuthServiceServer) DeleteSession(context.Context, *DeleteSessionRequest) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteSession not implemented")
}</span>
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedAuthServiceServer) testEmbeddedByValue()                     {<span class="cov0" title="0">}</span>

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
        mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedAuthServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;AuthService_ServiceDesc, srv)</span>
}

func _AuthService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RegisterRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Register(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_Register_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Register(ctx, req.(*RegisterRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LoginRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Login(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_Login_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Login(ctx, req.(*LoginRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_CheckSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CheckSessionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).CheckSession(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_CheckSession_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).CheckSession(ctx, req.(*CheckSessionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).GetUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_GetUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).GetUser(ctx, req.(*GetUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LogoutRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Logout(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_Logout_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Logout(ctx, req.(*LogoutRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_CreateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateSessionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).CreateSession(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_CreateSession_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).CreateSession(ctx, req.(*CreateSessionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_DeleteSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteSessionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).DeleteSession(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_DeleteSession_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).DeleteSession(ctx, req.(*DeleteSessionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "auth.AuthService",
        HandlerType: (*AuthServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Register",
                        Handler:    _AuthService_Register_Handler,
                },
                {
                        MethodName: "Login",
                        Handler:    _AuthService_Login_Handler,
                },
                {
                        MethodName: "CheckSession",
                        Handler:    _AuthService_CheckSession_Handler,
                },
                {
                        MethodName: "GetUser",
                        Handler:    _AuthService_GetUser_Handler,
                },
                {
                        MethodName: "Logout",
                        Handler:    _AuthService_Logout_Handler,
                },
                {
                        MethodName: "CreateSession",
                        Handler:    _AuthService_CreateSession_Handler,
                },
                {
                        MethodName: "DeleteSession",
                        Handler:    _AuthService_DeleteSession_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "auth.proto",
}
</pre>
		
		<pre class="file" id="file15" style="display: none">//go:generate mockgen -source=auth.go -destination=tests/mocks/auth.go -package=mocks

package auth

import (
        "context"

        pb "kudago/internal/auth/api"
        "kudago/internal/logger"
        "kudago/internal/models"
)

type ServerAPI struct {
        pb.UnimplementedAuthServiceServer
        service        AuthService
        sessionManager SessionManager
        logger         *logger.Logger
}

type AuthService interface {
        CheckCredentials(ctx context.Context, creds models.Credentials) (models.User, error)
        Register(ctx context.Context, user models.User) (models.User, error)
        GetUserByID(ctx context.Context, ID int) (models.User, error)
}

type SessionManager interface {
        DeleteSession(ctx context.Context, token string) error
        CheckSession(ctx context.Context, cookie string) (models.Session, error)
        CreateSession(ctx context.Context, ID int) (models.Session, error)
}

func NewServerAPI(service AuthService, sessionManager SessionManager, logger *logger.Logger) *ServerAPI <span class="cov8" title="1">{
        return &amp;ServerAPI{
                sessionManager: sessionManager,
                service:        service,
                logger:         logger,
        }
}</span>

func userToUserPb(userData models.User) *pb.User <span class="cov8" title="1">{
        return &amp;pb.User{
                ID:        int32(userData.ID),
                Username:  userData.Username,
                Email:     userData.Email,
                AvatarUrl: userData.ImageURL,
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package auth

import (
        "context"
        "errors"
        "time"

        pb "kudago/internal/auth/api"
        "kudago/internal/models"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) CheckSession(ctx context.Context, in *pb.CheckSessionRequest) (*pb.Session, error) <span class="cov8" title="1">{
        session, err := s.sessionManager.CheckSession(ctx, in.Cookie)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrUserNotFound) </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.NotFound, ErrUserNotFound)
                }</span>
                <span class="cov8" title="1">s.logger.Error(ctx, "check session", err)
                return nil, status.Error(codes.Internal, ErrInternal)</span>
        }

        <span class="cov8" title="1">user := &amp;pb.Session{
                UserID:  int32(session.UserID),
                Token:   session.Token,
                Expires: session.Expires.Format(time.RFC3339),
        }

        return user, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package auth

import (
        "context"
        "time"

        pb "kudago/internal/auth/api"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) CreateSession(ctx context.Context, in *pb.CreateSessionRequest) (*pb.Session, error) <span class="cov8" title="1">{
        session, err := s.sessionManager.CreateSession(ctx, int(in.ID))
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "create session", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>

        <span class="cov8" title="1">user := &amp;pb.Session{
                UserID:  int32(session.UserID),
                Token:   session.Token,
                Expires: session.Expires.Format(time.RFC3339),
        }

        return user, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package auth

import (
        "context"
        "errors"

        pb "kudago/internal/auth/api"
        "kudago/internal/models"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) GetUser(ctx context.Context, in *pb.GetUserRequest) (*pb.User, error) <span class="cov8" title="1">{
        userData, err := s.service.GetUserByID(ctx, int(in.ID))
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrUserNotFound) </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.NotFound, ErrUserNotFound)
                }</span>
                <span class="cov8" title="1">s.logger.Error(ctx, "get user", err)
                return nil, status.Error(codes.Internal, ErrInternal)</span>
        }

        <span class="cov8" title="1">user := userToUserPb(userData)

        return user, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package auth

import (
        "context"
        "errors"

        pb "kudago/internal/auth/api"
        "kudago/internal/models"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) Login(ctx context.Context, in *pb.LoginRequest) (*pb.User, error) <span class="cov8" title="1">{
        creds := models.Credentials{
                Username: in.Username,
                Password: in.Password,
        }

        userData, err := s.service.CheckCredentials(ctx, creds)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrUserNotFound) </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.NotFound, ErrInvalidCredentials)
                }</span>
                <span class="cov8" title="1">s.logger.Error(ctx, "login", err)
                return nil, status.Error(codes.Internal, ErrInternal)</span>
        }

        <span class="cov8" title="1">user := userToUserPb(userData)

        return user, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package auth

import (
        "context"

        pb "kudago/internal/auth/api"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) Logout(ctx context.Context, in *pb.LogoutRequest) (*pb.Empty, error) <span class="cov8" title="1">{
        err := s.sessionManager.DeleteSession(ctx, in.Token)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "logout", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>

        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package auth

import (
        "context"
        "errors"

        pb "kudago/internal/auth/api"
        "kudago/internal/models"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) Register(ctx context.Context, in *pb.RegisterRequest) (*pb.User, error) <span class="cov8" title="1">{
        user := models.User{
                Username: in.Username,
                Password: in.Password,
                Email:    in.Email,
                ImageURL: in.AvatarUrl,
        }

        userData, err := s.service.Register(ctx, user)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrEmailIsUsed) </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.AlreadyExists, ErrUsernameOrEmailIsTaken)
                }</span>
                <span class="cov8" title="1">s.logger.Error(ctx, "register", err)
                return nil, status.Error(codes.Internal, ErrInternal)</span>
        }

        <span class="cov8" title="1">resp := userToUserPb(userData)

        return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: auth.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        models "kudago/internal/models"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockAuthService is a mock of AuthService interface.
type MockAuthService struct {
        ctrl     *gomock.Controller
        recorder *MockAuthServiceMockRecorder
}

// MockAuthServiceMockRecorder is the mock recorder for MockAuthService.
type MockAuthServiceMockRecorder struct {
        mock *MockAuthService
}

// NewMockAuthService creates a new mock instance.
func NewMockAuthService(ctrl *gomock.Controller) *MockAuthService <span class="cov8" title="1">{
        mock := &amp;MockAuthService{ctrl: ctrl}
        mock.recorder = &amp;MockAuthServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthService) EXPECT() *MockAuthServiceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CheckCredentials mocks base method.
func (m *MockAuthService) CheckCredentials(ctx context.Context, creds models.Credentials) (models.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CheckCredentials", ctx, creds)
        ret0, _ := ret[0].(models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CheckCredentials indicates an expected call of CheckCredentials.
func (mr *MockAuthServiceMockRecorder) CheckCredentials(ctx, creds interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckCredentials", reflect.TypeOf((*MockAuthService)(nil).CheckCredentials), ctx, creds)
}</span>

// GetUserByID mocks base method.
func (m *MockAuthService) GetUserByID(ctx context.Context, ID int) (models.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByID", ctx, ID)
        ret0, _ := ret[0].(models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByID indicates an expected call of GetUserByID.
func (mr *MockAuthServiceMockRecorder) GetUserByID(ctx, ID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByID", reflect.TypeOf((*MockAuthService)(nil).GetUserByID), ctx, ID)
}</span>

// Register mocks base method.
func (m *MockAuthService) Register(ctx context.Context, user models.User) (models.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Register", ctx, user)
        ret0, _ := ret[0].(models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Register indicates an expected call of Register.
func (mr *MockAuthServiceMockRecorder) Register(ctx, user interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Register", reflect.TypeOf((*MockAuthService)(nil).Register), ctx, user)
}</span>

// MockSessionManager is a mock of SessionManager interface.
type MockSessionManager struct {
        ctrl     *gomock.Controller
        recorder *MockSessionManagerMockRecorder
}

// MockSessionManagerMockRecorder is the mock recorder for MockSessionManager.
type MockSessionManagerMockRecorder struct {
        mock *MockSessionManager
}

// NewMockSessionManager creates a new mock instance.
func NewMockSessionManager(ctrl *gomock.Controller) *MockSessionManager <span class="cov8" title="1">{
        mock := &amp;MockSessionManager{ctrl: ctrl}
        mock.recorder = &amp;MockSessionManagerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSessionManager) EXPECT() *MockSessionManagerMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CheckSession mocks base method.
func (m *MockSessionManager) CheckSession(ctx context.Context, cookie string) (models.Session, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CheckSession", ctx, cookie)
        ret0, _ := ret[0].(models.Session)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CheckSession indicates an expected call of CheckSession.
func (mr *MockSessionManagerMockRecorder) CheckSession(ctx, cookie interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckSession", reflect.TypeOf((*MockSessionManager)(nil).CheckSession), ctx, cookie)
}</span>

// CreateSession mocks base method.
func (m *MockSessionManager) CreateSession(ctx context.Context, ID int) (models.Session, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateSession", ctx, ID)
        ret0, _ := ret[0].(models.Session)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateSession indicates an expected call of CreateSession.
func (mr *MockSessionManagerMockRecorder) CreateSession(ctx, ID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateSession", reflect.TypeOf((*MockSessionManager)(nil).CreateSession), ctx, ID)
}</span>

// DeleteSession mocks base method.
func (m *MockSessionManager) DeleteSession(ctx context.Context, token string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteSession", ctx, token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteSession indicates an expected call of DeleteSession.
func (mr *MockSessionManagerMockRecorder) DeleteSession(ctx, token interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSession", reflect.TypeOf((*MockSessionManager)(nil).DeleteSession), ctx, token)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package userRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"

        "github.com/jackc/pgx/v5"
        "github.com/pkg/errors"
)

const checkCredentialsQuery = `
        SELECT id, username, email, created_at, url_to_avatar
        FROM "USER"
        WHERE username = $1 AND password_hash = $2`

func (d UserDB) CheckCredentials(ctx context.Context, username, password string) (models.User, error) <span class="cov0" title="0">{
        var userInfo UserInfo
        err := d.pool.QueryRow(ctx, checkCredentialsQuery, username, password).Scan(
                &amp;userInfo.ID,
                &amp;userInfo.Username,
                &amp;userInfo.Email,
                &amp;userInfo.CreatedAt,
                &amp;userInfo.ImageURL,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return models.User{}, fmt.Errorf("%s: %w", models.LevelDB, models.ErrUserNotFound)
                }</span>
                <span class="cov0" title="0">return models.User{}, fmt.Errorf("%s: %w", models.LevelDB, err)</span>
        }
        <span class="cov0" title="0">user := toDomainUser(userInfo)
        return user, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package userRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

const createUserQuery = `
        INSERT INTO "USER" (username, email, password_hash, url_to_avatar)
        VALUES ($1, $2, $3, $4)
        RETURNING id,  created_at`

func (d *UserDB) CreateUser(ctx context.Context, user models.User) (models.User, error) <span class="cov0" title="0">{
        var userInfo UserInfo
        err := d.pool.QueryRow(ctx, createUserQuery,
                user.Username,
                user.Email,
                user.Password,
                user.ImageURL,
        ).Scan(
                &amp;userInfo.ID,
                &amp;userInfo.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return models.User{}, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov0" title="0">userInfo.Username = user.Username
        userInfo.Email = user.Email
        userInfo.ImageURL = &amp;user.ImageURL

        newUser := toDomainUser(userInfo)
        return newUser, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package userRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"

        "github.com/jackc/pgx/v5"
        "github.com/pkg/errors"
)

const getUserByEmailOrUsernameQuery = `
                SELECT id 
                FROM "USER" 
                WHERE (username = $1 OR email = $2)`

func (d *UserDB) UserExists(ctx context.Context, user models.User) (bool, error) <span class="cov0" title="0">{
        var exists int
        query := getUserByEmailOrUsernameQuery
        args := []interface{}{user.Username, user.Email}

        if user.ID &gt; 0 </span><span class="cov0" title="0">{
                query += " AND id != $3"
                args = append(args, user.ID)
        }</span>

        <span class="cov0" title="0">err := d.pool.QueryRow(ctx, query, args...).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("%s: %w", models.LevelDB, err)</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package userRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"

        "github.com/jackc/pgx/v5"
)

const getUserByIDQuery = `SELECT id, username, email, url_to_avatar FROM "USER" WHERE id=$1`

func (d UserDB) GetUserByID(ctx context.Context, ID int) (models.User, error) <span class="cov0" title="0">{
        var userInfo UserInfo

        err := d.pool.QueryRow(ctx, getUserByIDQuery, ID).Scan(
                &amp;userInfo.ID,
                &amp;userInfo.Username,
                &amp;userInfo.Email,
                &amp;userInfo.ImageURL,
        )

        if err == pgx.ErrNoRows </span><span class="cov0" title="0">{
                return models.User{}, fmt.Errorf("%s: %w", models.LevelDB, models.ErrUserNotFound)
        }</span>

        <span class="cov0" title="0">user := toDomainUser(userInfo)
        return user, err</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package userRepository

import (
        "time"

        "kudago/internal/models"

        "github.com/jackc/pgx/v5/pgxpool"
)

type UserInfo struct {
        ID         int       `db:"id"`
        Username   string    `db:"username"`
        Email      string    `db:"email"`
        ImageURL   *string   `db:"url_to_avatar"`
        CreatedAt  time.Time `db:"created_at"`
        ModifiedAt time.Time `db:"modified_at"`
}

type UserDB struct {
        pool *pgxpool.Pool
}

func NewDB(pool *pgxpool.Pool) *UserDB <span class="cov0" title="0">{
        return &amp;UserDB{
                pool: pool,
        }
}</span>

func nilIfEmpty(value string) *string <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;value</span>
}

func toDomainUser(user UserInfo) models.User <span class="cov0" title="0">{
        var imageURL string
        if user.ImageURL == nil </span><span class="cov0" title="0">{
                imageURL = ""
        }</span> else<span class="cov0" title="0"> {
                imageURL = *user.ImageURL
        }</span>

        <span class="cov0" title="0">return models.User{
                ID:       user.ID,
                Username: user.Username,
                Email:    user.Email,
                ImageURL: imageURL,
        }</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package sessionRepository

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "strconv"
        "time"

        "github.com/redis/go-redis/v9"

        "kudago/internal/models"
        redisDB "kudago/internal/repository/redis"
)

const (
        expirationTime = 24 * time.Hour
)

type SessionDB struct {
        client *redis.Client
}

func NewDB(config *redisDB.RedisConfig) *SessionDB <span class="cov0" title="0">{
        redisClient := redis.NewClient(&amp;redis.Options{
                Addr:     config.URL,
                Password: config.Password,
                DB:       config.DB,
                PoolSize: config.PoolSize,
        })

        return &amp;SessionDB{
                client: redisClient,
        }
}</span>

func (db *SessionDB) CreateSession(ctx context.Context, ID int) (models.Session, error) <span class="cov0" title="0">{
        sessionToken := generateSessionToken()
        expiration := time.Now().Add(expirationTime)

        session := models.Session{
                UserID:  ID,
                Token:   sessionToken,
                Expires: expiration,
        }
        err := db.client.Set(ctx, sessionToken, session.UserID, expirationTime).Err()
        if err != nil </span><span class="cov0" title="0">{
                return models.Session{}, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov0" title="0">return session, nil</span>
}

func (db *SessionDB) CheckSession(ctx context.Context, cookie string) (models.Session, error) <span class="cov8" title="1">{
        ID, err := db.client.Get(ctx, cookie).Result()
        if err == redis.Nil </span><span class="cov8" title="1">{
                return models.Session{}, models.ErrUserNotFound
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return models.Session{}, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov8" title="1">userID, err := strconv.Atoi(ID)
        if err != nil </span><span class="cov0" title="0">{
                return models.Session{}, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov8" title="1">session := models.Session{
                UserID:  userID,
                Token:   cookie,
                Expires: time.Now().Add(expirationTime),
        }

        return session, nil</span>
}

func (db *SessionDB) DeleteSession(ctx context.Context, token string) error <span class="cov8" title="1">{
        err := db.client.Del(ctx, token).Err()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func generateSessionToken() string <span class="cov0" title="0">{
        b := make([]byte, 16)
        rand.Read(b)
        return hex.EncodeToString(b)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">//go:generate mockgen -source ./auth.go -destination=./mocks/auth.go -package=mocks

package service

import (
        "context"

        "kudago/internal/models"
)

type service struct {
        UserDB UserDB
}

type UserDB interface {
        CreateUser(ctx context.Context, user models.User) (models.User, error)
        GetUserByID(ctx context.Context, ID int) (models.User, error)
        CheckCredentials(ctx context.Context, username string, password string) (models.User, error)
        UserExists(ctx context.Context, user models.User) (bool, error)
}

func NewService(userDB UserDB) *service <span class="cov8" title="1">{
        return &amp;service{UserDB: userDB}
}</span>

func (a *service) GetUserByID(ctx context.Context, ID int) (models.User, error) <span class="cov0" title="0">{
        return a.UserDB.GetUserByID(ctx, ID)
}</span>

func (a *service) CheckCredentials(ctx context.Context, creds models.Credentials) (models.User, error) <span class="cov0" title="0">{
        return a.UserDB.CheckCredentials(ctx, creds.Username, creds.Password)
}</span>

func (a *service) Register(ctx context.Context, user models.User) (models.User, error) <span class="cov8" title="1">{
        userExists, err := a.UserDB.UserExists(ctx, user)
        if err != nil </span><span class="cov8" title="1">{
                return models.User{}, err
        }</span>

        <span class="cov8" title="1">if userExists </span><span class="cov8" title="1">{
                return models.User{}, models.ErrEmailIsUsed
        }</span>

        <span class="cov8" title="1">user, err = a.UserDB.CreateUser(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                return models.User{}, err
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./auth.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        models "kudago/internal/models"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockUserDB is a mock of UserDB interface.
type MockUserDB struct {
        ctrl     *gomock.Controller
        recorder *MockUserDBMockRecorder
}

// MockUserDBMockRecorder is the mock recorder for MockUserDB.
type MockUserDBMockRecorder struct {
        mock *MockUserDB
}

// NewMockUserDB creates a new mock instance.
func NewMockUserDB(ctrl *gomock.Controller) *MockUserDB <span class="cov8" title="1">{
        mock := &amp;MockUserDB{ctrl: ctrl}
        mock.recorder = &amp;MockUserDBMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserDB) EXPECT() *MockUserDBMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CheckCredentials mocks base method.
func (m *MockUserDB) CheckCredentials(ctx context.Context, username, password string) (models.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CheckCredentials", ctx, username, password)
        ret0, _ := ret[0].(models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CheckCredentials indicates an expected call of CheckCredentials.
func (mr *MockUserDBMockRecorder) CheckCredentials(ctx, username, password interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckCredentials", reflect.TypeOf((*MockUserDB)(nil).CheckCredentials), ctx, username, password)
}</span>

// CreateUser mocks base method.
func (m *MockUserDB) CreateUser(ctx context.Context, user models.User) (models.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateUser", ctx, user)
        ret0, _ := ret[0].(models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockUserDBMockRecorder) CreateUser(ctx, user interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockUserDB)(nil).CreateUser), ctx, user)
}</span>

// GetUserByID mocks base method.
func (m *MockUserDB) GetUserByID(ctx context.Context, ID int) (models.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByID", ctx, ID)
        ret0, _ := ret[0].(models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByID indicates an expected call of GetUserByID.
func (mr *MockUserDBMockRecorder) GetUserByID(ctx, ID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByID", reflect.TypeOf((*MockUserDB)(nil).GetUserByID), ctx, ID)
}</span>

// UserExists mocks base method.
func (m *MockUserDB) UserExists(ctx context.Context, user models.User) (bool, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UserExists", ctx, user)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UserExists indicates an expected call of UserExists.
func (mr *MockUserDBMockRecorder) UserExists(ctx, user interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserExists", reflect.TypeOf((*MockUserDB)(nil).UserExists), ctx, user)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.35.2
//         protoc        v3.12.4
// source: event.proto

package event

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type GetEventByIDRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (x *GetEventByIDRequest) Reset() <span class="cov0" title="0">{
        *x = GetEventByIDRequest{}
        mi := &amp;file_event_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetEventByIDRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetEventByIDRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetEventByIDRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetEventByIDRequest.ProtoReflect.Descriptor instead.
func (*GetEventByIDRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{0}
}</span>

func (x *GetEventByIDRequest) GetID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetSubscribersIDsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserID int32 `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
}

func (x *GetSubscribersIDsRequest) Reset() <span class="cov0" title="0">{
        *x = GetSubscribersIDsRequest{}
        mi := &amp;file_event_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSubscribersIDsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSubscribersIDsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSubscribersIDsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSubscribersIDsRequest.ProtoReflect.Descriptor instead.
func (*GetSubscribersIDsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{1}
}</span>

func (x *GetSubscribersIDsRequest) GetUserID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetEventsByIDsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        IDs []int32 `protobuf:"varint,1,rep,packed,name=IDs,proto3" json:"IDs,omitempty"`
}

func (x *GetEventsByIDsRequest) Reset() <span class="cov0" title="0">{
        *x = GetEventsByIDsRequest{}
        mi := &amp;file_event_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetEventsByIDsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetEventsByIDsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetEventsByIDsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetEventsByIDsRequest.ProtoReflect.Descriptor instead.
func (*GetEventsByIDsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetEventsByIDsRequest) GetIDs() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IDs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetUserIDsByFavoriteEventRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (x *GetUserIDsByFavoriteEventRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserIDsByFavoriteEventRequest{}
        mi := &amp;file_event_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserIDsByFavoriteEventRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserIDsByFavoriteEventRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserIDsByFavoriteEventRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserIDsByFavoriteEventRequest.ProtoReflect.Descriptor instead.
func (*GetUserIDsByFavoriteEventRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetUserIDsByFavoriteEventRequest) GetID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetUserIDsResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        IDs []int32 `protobuf:"varint,1,rep,packed,name=IDs,proto3" json:"IDs,omitempty"`
}

func (x *GetUserIDsResponse) Reset() <span class="cov0" title="0">{
        *x = GetUserIDsResponse{}
        mi := &amp;file_event_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserIDsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserIDsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserIDsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserIDsResponse.ProtoReflect.Descriptor instead.
func (*GetUserIDsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{4}
}</span>

func (x *GetUserIDsResponse) GetIDs() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IDs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetSubscriptionsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ID     int32             `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
        Params *PaginationParams `protobuf:"bytes,2,opt,name=params,proto3" json:"params,omitempty"`
}

func (x *GetSubscriptionsRequest) Reset() <span class="cov0" title="0">{
        *x = GetSubscriptionsRequest{}
        mi := &amp;file_event_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSubscriptionsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSubscriptionsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSubscriptionsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSubscriptionsRequest.ProtoReflect.Descriptor instead.
func (*GetSubscriptionsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{5}
}</span>

func (x *GetSubscriptionsRequest) GetID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetSubscriptionsRequest) GetParams() *PaginationParams <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Params
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetEventsByCategoryRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        CategoryID int32             `protobuf:"varint,1,opt,name=CategoryID,proto3" json:"CategoryID,omitempty"`
        Params     *PaginationParams `protobuf:"bytes,2,opt,name=params,proto3" json:"params,omitempty"`
}

func (x *GetEventsByCategoryRequest) Reset() <span class="cov0" title="0">{
        *x = GetEventsByCategoryRequest{}
        mi := &amp;file_event_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetEventsByCategoryRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetEventsByCategoryRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetEventsByCategoryRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetEventsByCategoryRequest.ProtoReflect.Descriptor instead.
func (*GetEventsByCategoryRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{6}
}</span>

func (x *GetEventsByCategoryRequest) GetCategoryID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CategoryID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetEventsByCategoryRequest) GetParams() *PaginationParams <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Params
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetEventsByUserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserID int32             `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
        Params *PaginationParams `protobuf:"bytes,2,opt,name=params,proto3" json:"params,omitempty"`
}

func (x *GetEventsByUserRequest) Reset() <span class="cov0" title="0">{
        *x = GetEventsByUserRequest{}
        mi := &amp;file_event_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetEventsByUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetEventsByUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetEventsByUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetEventsByUserRequest.ProtoReflect.Descriptor instead.
func (*GetEventsByUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{7}
}</span>

func (x *GetEventsByUserRequest) GetUserID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetEventsByUserRequest) GetParams() *PaginationParams <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Params
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetFavoritesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserID int32             `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
        Params *PaginationParams `protobuf:"bytes,2,opt,name=params,proto3" json:"params,omitempty"`
}

func (x *GetFavoritesRequest) Reset() <span class="cov0" title="0">{
        *x = GetFavoritesRequest{}
        mi := &amp;file_event_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetFavoritesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetFavoritesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetFavoritesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetFavoritesRequest.ProtoReflect.Descriptor instead.
func (*GetFavoritesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{8}
}</span>

func (x *GetFavoritesRequest) GetUserID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetFavoritesRequest) GetParams() *PaginationParams <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Params
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeleteEventRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        EventID  int32 `protobuf:"varint,1,opt,name=EventID,proto3" json:"EventID,omitempty"`
        AuthorID int32 `protobuf:"varint,2,opt,name=AuthorID,proto3" json:"AuthorID,omitempty"`
}

func (x *DeleteEventRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteEventRequest{}
        mi := &amp;file_event_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteEventRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteEventRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteEventRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteEventRequest.ProtoReflect.Descriptor instead.
func (*DeleteEventRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{9}
}</span>

func (x *DeleteEventRequest) GetEventID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EventID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DeleteEventRequest) GetAuthorID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PaginationParams struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Limit  int32 `protobuf:"varint,1,opt,name=Limit,proto3" json:"Limit,omitempty"`
        Offset int32 `protobuf:"varint,2,opt,name=Offset,proto3" json:"Offset,omitempty"`
}

func (x *PaginationParams) Reset() <span class="cov0" title="0">{
        *x = PaginationParams{}
        mi := &amp;file_event_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PaginationParams) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PaginationParams) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PaginationParams) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PaginationParams.ProtoReflect.Descriptor instead.
func (*PaginationParams) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{10}
}</span>

func (x *PaginationParams) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PaginationParams) GetOffset() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Events struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Events []*Event `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
}

func (x *Events) Reset() <span class="cov0" title="0">{
        *x = Events{}
        mi := &amp;file_event_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Events) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Events) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Events) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Events.ProtoReflect.Descriptor instead.
func (*Events) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{11}
}</span>

func (x *Events) GetEvents() []*Event <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Events
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetCategoriesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Categories []*Category `protobuf:"bytes,1,rep,name=categories,proto3" json:"categories,omitempty"`
}

func (x *GetCategoriesResponse) Reset() <span class="cov0" title="0">{
        *x = GetCategoriesResponse{}
        mi := &amp;file_event_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetCategoriesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetCategoriesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetCategoriesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetCategoriesResponse.ProtoReflect.Descriptor instead.
func (*GetCategoriesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{12}
}</span>

func (x *GetCategoriesResponse) GetCategories() []*Category <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Categories
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type FavoriteEvent struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserID  int32 `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
        EventID int32 `protobuf:"varint,2,opt,name=EventID,proto3" json:"EventID,omitempty"`
}

func (x *FavoriteEvent) Reset() <span class="cov0" title="0">{
        *x = FavoriteEvent{}
        mi := &amp;file_event_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *FavoriteEvent) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FavoriteEvent) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FavoriteEvent) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FavoriteEvent.ProtoReflect.Descriptor instead.
func (*FavoriteEvent) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{13}
}</span>

func (x *FavoriteEvent) GetUserID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FavoriteEvent) GetEventID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EventID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Category struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ID   int32  `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
        Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *Category) Reset() <span class="cov0" title="0">{
        *x = Category{}
        mi := &amp;file_event_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Category) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Category) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Category) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Category.ProtoReflect.Descriptor instead.
func (*Category) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{14}
}</span>

func (x *Category) GetID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Category) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Event struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ID          int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
        Title       string   `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
        Description string   `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
        Location    string   `protobuf:"bytes,4,opt,name=location,proto3" json:"location,omitempty"`
        CategoryID  int32    `protobuf:"varint,5,opt,name=category_iD,json=categoryID,proto3" json:"category_iD,omitempty"`
        Capacity    int32    `protobuf:"varint,6,opt,name=capacity,proto3" json:"capacity,omitempty"`
        Tag         []string `protobuf:"bytes,7,rep,name=tag,proto3" json:"tag,omitempty"`
        AuthorID    int32    `protobuf:"varint,8,opt,name=author_iD,json=authorID,proto3" json:"author_iD,omitempty"`
        Latitude    float64  `protobuf:"fixed64,9,opt,name=latitude,proto3" json:"latitude,omitempty"`
        Longitude   float64  `protobuf:"fixed64,10,opt,name=longitude,proto3" json:"longitude,omitempty"`
        EventStart  string   `protobuf:"bytes,11,opt,name=event_start,json=eventStart,proto3" json:"event_start,omitempty"`
        EventEnd    string   `protobuf:"bytes,12,opt,name=event_end,json=eventEnd,proto3" json:"event_end,omitempty"`
        Image       string   `protobuf:"bytes,13,opt,name=image,proto3" json:"image,omitempty"`
}

func (x *Event) Reset() <span class="cov0" title="0">{
        *x = Event{}
        mi := &amp;file_event_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Event) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Event) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Event) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Event.ProtoReflect.Descriptor instead.
func (*Event) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{15}
}</span>

func (x *Event) GetID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Event) GetTitle() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Event) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Event) GetLocation() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Location
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Event) GetCategoryID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CategoryID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Event) GetCapacity() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Capacity
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Event) GetTag() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tag
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Event) GetAuthorID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Event) GetLatitude() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Latitude
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Event) GetLongitude() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Longitude
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Event) GetEventStart() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EventStart
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Event) GetEventEnd() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EventEnd
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Event) GetImage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Image
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type File struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        File     []byte `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
        Filename string `protobuf:"bytes,2,opt,name=filename,proto3" json:"filename,omitempty"`
}

func (x *File) Reset() <span class="cov0" title="0">{
        *x = File{}
        mi := &amp;file_event_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *File) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*File) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *File) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use File.ProtoReflect.Descriptor instead.
func (*File) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{16}
}</span>

func (x *File) GetFile() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.File
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *File) GetFilename() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Filename
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SearchParams struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Query        string            `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
        CategoryID   int32             `protobuf:"varint,2,opt,name=category_iD,json=categoryID,proto3" json:"category_iD,omitempty"`
        Tag          []string          `protobuf:"bytes,3,rep,name=tag,proto3" json:"tag,omitempty"`
        EventStart   string            `protobuf:"bytes,4,opt,name=event_start,json=eventStart,proto3" json:"event_start,omitempty"`
        EventEnd     string            `protobuf:"bytes,5,opt,name=event_end,json=eventEnd,proto3" json:"event_end,omitempty"`
        Params       *PaginationParams `protobuf:"bytes,6,opt,name=params,proto3" json:"params,omitempty"`
        LatitudeMin  float64           `protobuf:"fixed64,7,opt,name=latitude_min,json=latitudeMin,proto3" json:"latitude_min,omitempty"`
        LatitudeMax  float64           `protobuf:"fixed64,8,opt,name=latitude_max,json=latitudeMax,proto3" json:"latitude_max,omitempty"`
        LongitudeMin float64           `protobuf:"fixed64,9,opt,name=longitude_min,json=longitudeMin,proto3" json:"longitude_min,omitempty"`
        LongitudeMax float64           `protobuf:"fixed64,10,opt,name=longitude_max,json=longitudeMax,proto3" json:"longitude_max,omitempty"`
}

func (x *SearchParams) Reset() <span class="cov0" title="0">{
        *x = SearchParams{}
        mi := &amp;file_event_proto_msgTypes[17]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SearchParams) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SearchParams) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SearchParams) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[17]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SearchParams.ProtoReflect.Descriptor instead.
func (*SearchParams) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{17}
}</span>

func (x *SearchParams) GetQuery() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Query
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SearchParams) GetCategoryID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CategoryID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SearchParams) GetTag() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tag
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SearchParams) GetEventStart() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EventStart
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SearchParams) GetEventEnd() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EventEnd
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SearchParams) GetParams() *PaginationParams <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Params
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SearchParams) GetLatitudeMin() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LatitudeMin
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SearchParams) GetLatitudeMax() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LatitudeMax
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SearchParams) GetLongitudeMin() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LongitudeMin
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SearchParams) GetLongitudeMax() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LongitudeMax
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Empty struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *Empty) Reset() <span class="cov0" title="0">{
        *x = Empty{}
        mi := &amp;file_event_proto_msgTypes[18]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Empty) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Empty) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Empty) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_event_proto_msgTypes[18]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Empty.ProtoReflect.Descriptor instead.
func (*Empty) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_event_proto_rawDescGZIP(), []int{18}
}</span>

var File_event_proto protoreflect.FileDescriptor

var file_event_proto_rawDesc = []byte{
        0x0a, 0x0b, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x05, 0x65,
        0x76, 0x65, 0x6e, 0x74, 0x22, 0x25, 0x0a, 0x13, 0x47, 0x65, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74,
        0x42, 0x79, 0x49, 0x44, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x49,
        0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x49, 0x44, 0x22, 0x32, 0x0a, 0x18, 0x47,
        0x65, 0x74, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x72, 0x73, 0x49, 0x44, 0x73,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x55, 0x73, 0x65, 0x72, 0x49,
        0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44, 0x22,
        0x29, 0x0a, 0x15, 0x47, 0x65, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x42, 0x79, 0x49, 0x44,
        0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x49, 0x44, 0x73, 0x18,
        0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x03, 0x49, 0x44, 0x73, 0x22, 0x32, 0x0a, 0x20, 0x47, 0x65,
        0x74, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44, 0x73, 0x42, 0x79, 0x46, 0x61, 0x76, 0x6f, 0x72, 0x69,
        0x74, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e,
        0x0a, 0x02, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x49, 0x44, 0x22, 0x26,
        0x0a, 0x12, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44, 0x73, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x49, 0x44, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
        0x05, 0x52, 0x03, 0x49, 0x44, 0x73, 0x22, 0x5a, 0x0a, 0x17, 0x47, 0x65, 0x74, 0x53, 0x75, 0x62,
        0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x49,
        0x44, 0x12, 0x2f, 0x0a, 0x06, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x17, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x61, 0x67, 0x69, 0x6e, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x52, 0x06, 0x70, 0x61, 0x72, 0x61,
        0x6d, 0x73, 0x22, 0x6d, 0x0a, 0x1a, 0x47, 0x65, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x42,
        0x79, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x12, 0x1e, 0x0a, 0x0a, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x49, 0x44, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x05, 0x52, 0x0a, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x49, 0x44,
        0x12, 0x2f, 0x0a, 0x06, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x17, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x61, 0x67, 0x69, 0x6e, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x52, 0x06, 0x70, 0x61, 0x72, 0x61, 0x6d,
        0x73, 0x22, 0x61, 0x0a, 0x16, 0x47, 0x65, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x42, 0x79,
        0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x55,
        0x73, 0x65, 0x72, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x55, 0x73, 0x65,
        0x72, 0x49, 0x44, 0x12, 0x2f, 0x0a, 0x06, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x61, 0x67, 0x69,
        0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x52, 0x06, 0x70, 0x61,
        0x72, 0x61, 0x6d, 0x73, 0x22, 0x5e, 0x0a, 0x13, 0x47, 0x65, 0x74, 0x46, 0x61, 0x76, 0x6f, 0x72,
        0x69, 0x74, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x55,
        0x73, 0x65, 0x72, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x55, 0x73, 0x65,
        0x72, 0x49, 0x44, 0x12, 0x2f, 0x0a, 0x06, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x61, 0x67, 0x69,
        0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x52, 0x06, 0x70, 0x61,
        0x72, 0x61, 0x6d, 0x73, 0x22, 0x4a, 0x0a, 0x12, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x45, 0x76,
        0x65, 0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x45, 0x76,
        0x65, 0x6e, 0x74, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x07, 0x45, 0x76, 0x65,
        0x6e, 0x74, 0x49, 0x44, 0x12, 0x1a, 0x0a, 0x08, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x49, 0x44,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x49, 0x44,
        0x22, 0x40, 0x0a, 0x10, 0x50, 0x61, 0x67, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x61,
        0x72, 0x61, 0x6d, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x05, 0x52, 0x05, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x4f, 0x66,
        0x66, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x4f, 0x66, 0x66, 0x73,
        0x65, 0x74, 0x22, 0x2e, 0x0a, 0x06, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x24, 0x0a, 0x06,
        0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x65,
        0x76, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x52, 0x06, 0x65, 0x76, 0x65, 0x6e,
        0x74, 0x73, 0x22, 0x48, 0x0a, 0x15, 0x47, 0x65, 0x74, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72,
        0x69, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2f, 0x0a, 0x0a, 0x63,
        0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x0f, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79,
        0x52, 0x0a, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73, 0x22, 0x41, 0x0a, 0x0d,
        0x46, 0x61, 0x76, 0x6f, 0x72, 0x69, 0x74, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x16, 0x0a,
        0x06, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x55,
        0x73, 0x65, 0x72, 0x49, 0x44, 0x12, 0x18, 0x0a, 0x07, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x44,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x07, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x22,
        0x2e, 0x0a, 0x08, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x12, 0x0e, 0x0a, 0x02, 0x49,
        0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x49, 0x44, 0x12, 0x12, 0x0a, 0x04, 0x6e,
        0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x22,
        0xe5, 0x02, 0x0a, 0x05, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x44, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x49, 0x44, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x69, 0x74,
        0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x12,
        0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1f, 0x0a,
        0x0b, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x5f, 0x69, 0x44, 0x18, 0x05, 0x20, 0x01,
        0x28, 0x05, 0x52, 0x0a, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x49, 0x44, 0x12, 0x1a,
        0x0a, 0x08, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05,
        0x52, 0x08, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x74, 0x61,
        0x67, 0x18, 0x07, 0x20, 0x03, 0x28, 0x09, 0x52, 0x03, 0x74, 0x61, 0x67, 0x12, 0x1b, 0x0a, 0x09,
        0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x5f, 0x69, 0x44, 0x18, 0x08, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x08, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x49, 0x44, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x61, 0x74,
        0x69, 0x74, 0x75, 0x64, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x01, 0x52, 0x08, 0x6c, 0x61, 0x74,
        0x69, 0x74, 0x75, 0x64, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75,
        0x64, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x01, 0x52, 0x09, 0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x74,
        0x75, 0x64, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x73, 0x74, 0x61,
        0x72, 0x74, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x53,
        0x74, 0x61, 0x72, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x65, 0x6e,
        0x64, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x45, 0x6e,
        0x64, 0x12, 0x14, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x22, 0x36, 0x0a, 0x04, 0x46, 0x69, 0x6c, 0x65, 0x12,
        0x12, 0x0a, 0x04, 0x66, 0x69, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x04, 0x66,
        0x69, 0x6c, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x22,
        0xd6, 0x02, 0x0a, 0x0c, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73,
        0x12, 0x14, 0x0a, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x12, 0x1f, 0x0a, 0x0b, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f,
        0x72, 0x79, 0x5f, 0x69, 0x44, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a, 0x63, 0x61, 0x74,
        0x65, 0x67, 0x6f, 0x72, 0x79, 0x49, 0x44, 0x12, 0x10, 0x0a, 0x03, 0x74, 0x61, 0x67, 0x18, 0x03,
        0x20, 0x03, 0x28, 0x09, 0x52, 0x03, 0x74, 0x61, 0x67, 0x12, 0x1f, 0x0a, 0x0b, 0x65, 0x76, 0x65,
        0x6e, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a,
        0x65, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x72, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x65, 0x76,
        0x65, 0x6e, 0x74, 0x5f, 0x65, 0x6e, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x65,
        0x76, 0x65, 0x6e, 0x74, 0x45, 0x6e, 0x64, 0x12, 0x2f, 0x0a, 0x06, 0x70, 0x61, 0x72, 0x61, 0x6d,
        0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e,
        0x50, 0x61, 0x67, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73,
        0x52, 0x06, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x6c, 0x61, 0x74, 0x69,
        0x74, 0x75, 0x64, 0x65, 0x5f, 0x6d, 0x69, 0x6e, 0x18, 0x07, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0b,
        0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x4d, 0x69, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x6c,
        0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x6d, 0x61, 0x78, 0x18, 0x08, 0x20, 0x01, 0x28,
        0x01, 0x52, 0x0b, 0x6c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x4d, 0x61, 0x78, 0x12, 0x23,
        0x0a, 0x0d, 0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x6d, 0x69, 0x6e, 0x18,
        0x09, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0c, 0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65,
        0x4d, 0x69, 0x6e, 0x12, 0x23, 0x0a, 0x0d, 0x6c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65,
        0x5f, 0x6d, 0x61, 0x78, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0c, 0x6c, 0x6f, 0x6e, 0x67,
        0x69, 0x74, 0x75, 0x64, 0x65, 0x4d, 0x61, 0x78, 0x22, 0x07, 0x0a, 0x05, 0x45, 0x6d, 0x70, 0x74,
        0x79, 0x32, 0xb4, 0x08, 0x0a, 0x0c, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69,
        0x63, 0x65, 0x12, 0x26, 0x0a, 0x08, 0x41, 0x64, 0x64, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x0c,
        0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x1a, 0x0c, 0x2e, 0x65,
        0x76, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x39, 0x0a, 0x13, 0x41, 0x64,
        0x64, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x6f, 0x46, 0x61, 0x76, 0x6f, 0x72, 0x69, 0x74, 0x65,
        0x73, 0x12, 0x14, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x61, 0x76, 0x6f, 0x72, 0x69,
        0x74, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x1a, 0x0c, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e,
        0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x3e, 0x0a, 0x18, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x45,
        0x76, 0x65, 0x6e, 0x74, 0x46, 0x72, 0x6f, 0x6d, 0x46, 0x61, 0x76, 0x6f, 0x72, 0x69, 0x74, 0x65,
        0x73, 0x12, 0x14, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x61, 0x76, 0x6f, 0x72, 0x69,
        0x74, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x1a, 0x0c, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e,
        0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x36, 0x0a, 0x0b, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x45,
        0x76, 0x65, 0x6e, 0x74, 0x12, 0x19, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x44, 0x65, 0x6c,
        0x65, 0x74, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
        0x0c, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x3b, 0x0a,
        0x0d, 0x47, 0x65, 0x74, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73, 0x12, 0x0c,
        0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x1c, 0x2e, 0x65,
        0x76, 0x65, 0x6e, 0x74, 0x2e, 0x47, 0x65, 0x74, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x69,
        0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x38, 0x0a, 0x0c, 0x47, 0x65,
        0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x42, 0x79, 0x49, 0x44, 0x12, 0x1a, 0x2e, 0x65, 0x76, 0x65,
        0x6e, 0x74, 0x2e, 0x47, 0x65, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x42, 0x79, 0x49, 0x44, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x0c, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x45,
        0x76, 0x65, 0x6e, 0x74, 0x12, 0x47, 0x0a, 0x13, 0x47, 0x65, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74,
        0x73, 0x42, 0x79, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x12, 0x21, 0x2e, 0x65, 0x76,
        0x65, 0x6e, 0x74, 0x2e, 0x47, 0x65, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x42, 0x79, 0x43,
        0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x0d,
        0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x3f, 0x0a,
        0x0f, 0x47, 0x65, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x42, 0x79, 0x55, 0x73, 0x65, 0x72,
        0x12, 0x1d, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x47, 0x65, 0x74, 0x45, 0x76, 0x65, 0x6e,
        0x74, 0x73, 0x42, 0x79, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
        0x0d, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x39,
        0x0a, 0x0c, 0x47, 0x65, 0x74, 0x46, 0x61, 0x76, 0x6f, 0x72, 0x69, 0x74, 0x65, 0x73, 0x12, 0x1a,
        0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x47, 0x65, 0x74, 0x46, 0x61, 0x76, 0x6f, 0x72, 0x69,
        0x74, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x0d, 0x2e, 0x65, 0x76, 0x65,
        0x6e, 0x74, 0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x37, 0x0a, 0x0d, 0x47, 0x65, 0x74,
        0x50, 0x61, 0x73, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x17, 0x2e, 0x65, 0x76, 0x65,
        0x6e, 0x74, 0x2e, 0x50, 0x61, 0x67, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x61, 0x72,
        0x61, 0x6d, 0x73, 0x1a, 0x0d, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x76, 0x65, 0x6e,
        0x74, 0x73, 0x12, 0x3b, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x55, 0x70, 0x63, 0x6f, 0x6d, 0x69, 0x6e,
        0x67, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x17, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e,
        0x50, 0x61, 0x67, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73,
        0x1a, 0x0d, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x12,
        0x47, 0x0a, 0x16, 0x47, 0x65, 0x74, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x1e, 0x2e, 0x65, 0x76, 0x65, 0x6e,
        0x74, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x0d, 0x2e, 0x65, 0x76, 0x65, 0x6e,
        0x74, 0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x29, 0x0a, 0x0b, 0x55, 0x70, 0x64, 0x61,
        0x74, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x0c, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e,
        0x45, 0x76, 0x65, 0x6e, 0x74, 0x1a, 0x0c, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x76,
        0x65, 0x6e, 0x74, 0x12, 0x32, 0x0a, 0x0c, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x45, 0x76, 0x65,
        0x6e, 0x74, 0x73, 0x12, 0x13, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x65, 0x61, 0x72,
        0x63, 0x68, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x1a, 0x0d, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74,
        0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x5f, 0x0a, 0x19, 0x47, 0x65, 0x74, 0x55, 0x73,
        0x65, 0x72, 0x49, 0x44, 0x73, 0x42, 0x79, 0x46, 0x61, 0x76, 0x6f, 0x72, 0x69, 0x74, 0x65, 0x45,
        0x76, 0x65, 0x6e, 0x74, 0x12, 0x27, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x47, 0x65, 0x74,
        0x55, 0x73, 0x65, 0x72, 0x49, 0x44, 0x73, 0x42, 0x79, 0x46, 0x61, 0x76, 0x6f, 0x72, 0x69, 0x74,
        0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x19, 0x2e,
        0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44, 0x73,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3d, 0x0a, 0x0e, 0x47, 0x65, 0x74, 0x45,
        0x76, 0x65, 0x6e, 0x74, 0x73, 0x42, 0x79, 0x49, 0x44, 0x73, 0x12, 0x1c, 0x2e, 0x65, 0x76, 0x65,
        0x6e, 0x74, 0x2e, 0x47, 0x65, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x42, 0x79, 0x49, 0x44,
        0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x0d, 0x2e, 0x65, 0x76, 0x65, 0x6e, 0x74,
        0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x4f, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x53, 0x75,
        0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x72, 0x73, 0x49, 0x44, 0x73, 0x12, 0x1f, 0x2e, 0x65,
        0x76, 0x65, 0x6e, 0x74, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62,
        0x65, 0x72, 0x73, 0x49, 0x44, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x19, 0x2e,
        0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44, 0x73,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x0a, 0x5a, 0x08, 0x2e, 0x2f, 0x3b, 0x65,
        0x76, 0x65, 0x6e, 0x74, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_event_proto_rawDescOnce sync.Once
        file_event_proto_rawDescData = file_event_proto_rawDesc
)

func file_event_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_event_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_event_proto_rawDescData = protoimpl.X.CompressGZIP(file_event_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_event_proto_rawDescData</span>
}

var file_event_proto_msgTypes = make([]protoimpl.MessageInfo, 19)
var file_event_proto_goTypes = []any{
        (*GetEventByIDRequest)(nil),              // 0: event.GetEventByIDRequest
        (*GetSubscribersIDsRequest)(nil),         // 1: event.GetSubscribersIDsRequest
        (*GetEventsByIDsRequest)(nil),            // 2: event.GetEventsByIDsRequest
        (*GetUserIDsByFavoriteEventRequest)(nil), // 3: event.GetUserIDsByFavoriteEventRequest
        (*GetUserIDsResponse)(nil),               // 4: event.GetUserIDsResponse
        (*GetSubscriptionsRequest)(nil),          // 5: event.GetSubscriptionsRequest
        (*GetEventsByCategoryRequest)(nil),       // 6: event.GetEventsByCategoryRequest
        (*GetEventsByUserRequest)(nil),           // 7: event.GetEventsByUserRequest
        (*GetFavoritesRequest)(nil),              // 8: event.GetFavoritesRequest
        (*DeleteEventRequest)(nil),               // 9: event.DeleteEventRequest
        (*PaginationParams)(nil),                 // 10: event.PaginationParams
        (*Events)(nil),                           // 11: event.Events
        (*GetCategoriesResponse)(nil),            // 12: event.GetCategoriesResponse
        (*FavoriteEvent)(nil),                    // 13: event.FavoriteEvent
        (*Category)(nil),                         // 14: event.Category
        (*Event)(nil),                            // 15: event.Event
        (*File)(nil),                             // 16: event.File
        (*SearchParams)(nil),                     // 17: event.SearchParams
        (*Empty)(nil),                            // 18: event.Empty
}
var file_event_proto_depIdxs = []int32{
        10, // 0: event.GetSubscriptionsRequest.params:type_name -&gt; event.PaginationParams
        10, // 1: event.GetEventsByCategoryRequest.params:type_name -&gt; event.PaginationParams
        10, // 2: event.GetEventsByUserRequest.params:type_name -&gt; event.PaginationParams
        10, // 3: event.GetFavoritesRequest.params:type_name -&gt; event.PaginationParams
        15, // 4: event.Events.events:type_name -&gt; event.Event
        14, // 5: event.GetCategoriesResponse.categories:type_name -&gt; event.Category
        10, // 6: event.SearchParams.params:type_name -&gt; event.PaginationParams
        15, // 7: event.EventService.AddEvent:input_type -&gt; event.Event
        13, // 8: event.EventService.AddEventToFavorites:input_type -&gt; event.FavoriteEvent
        13, // 9: event.EventService.DeleteEventFromFavorites:input_type -&gt; event.FavoriteEvent
        9,  // 10: event.EventService.DeleteEvent:input_type -&gt; event.DeleteEventRequest
        18, // 11: event.EventService.GetCategories:input_type -&gt; event.Empty
        0,  // 12: event.EventService.GetEventByID:input_type -&gt; event.GetEventByIDRequest
        6,  // 13: event.EventService.GetEventsByCategory:input_type -&gt; event.GetEventsByCategoryRequest
        7,  // 14: event.EventService.GetEventsByUser:input_type -&gt; event.GetEventsByUserRequest
        8,  // 15: event.EventService.GetFavorites:input_type -&gt; event.GetFavoritesRequest
        10, // 16: event.EventService.GetPastEvents:input_type -&gt; event.PaginationParams
        10, // 17: event.EventService.GetUpcomingEvents:input_type -&gt; event.PaginationParams
        5,  // 18: event.EventService.GetSubscriptionsEvents:input_type -&gt; event.GetSubscriptionsRequest
        15, // 19: event.EventService.UpdateEvent:input_type -&gt; event.Event
        17, // 20: event.EventService.SearchEvents:input_type -&gt; event.SearchParams
        3,  // 21: event.EventService.GetUserIDsByFavoriteEvent:input_type -&gt; event.GetUserIDsByFavoriteEventRequest
        2,  // 22: event.EventService.GetEventsByIDs:input_type -&gt; event.GetEventsByIDsRequest
        1,  // 23: event.EventService.GetSubscribersIDs:input_type -&gt; event.GetSubscribersIDsRequest
        15, // 24: event.EventService.AddEvent:output_type -&gt; event.Event
        18, // 25: event.EventService.AddEventToFavorites:output_type -&gt; event.Empty
        18, // 26: event.EventService.DeleteEventFromFavorites:output_type -&gt; event.Empty
        18, // 27: event.EventService.DeleteEvent:output_type -&gt; event.Empty
        12, // 28: event.EventService.GetCategories:output_type -&gt; event.GetCategoriesResponse
        15, // 29: event.EventService.GetEventByID:output_type -&gt; event.Event
        11, // 30: event.EventService.GetEventsByCategory:output_type -&gt; event.Events
        11, // 31: event.EventService.GetEventsByUser:output_type -&gt; event.Events
        11, // 32: event.EventService.GetFavorites:output_type -&gt; event.Events
        11, // 33: event.EventService.GetPastEvents:output_type -&gt; event.Events
        11, // 34: event.EventService.GetUpcomingEvents:output_type -&gt; event.Events
        11, // 35: event.EventService.GetSubscriptionsEvents:output_type -&gt; event.Events
        15, // 36: event.EventService.UpdateEvent:output_type -&gt; event.Event
        11, // 37: event.EventService.SearchEvents:output_type -&gt; event.Events
        4,  // 38: event.EventService.GetUserIDsByFavoriteEvent:output_type -&gt; event.GetUserIDsResponse
        11, // 39: event.EventService.GetEventsByIDs:output_type -&gt; event.Events
        4,  // 40: event.EventService.GetSubscribersIDs:output_type -&gt; event.GetUserIDsResponse
        24, // [24:41] is the sub-list for method output_type
        7,  // [7:24] is the sub-list for method input_type
        7,  // [7:7] is the sub-list for extension type_name
        7,  // [7:7] is the sub-list for extension extendee
        0,  // [0:7] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_event_proto_init() }</span>
func file_event_proto_init() <span class="cov8" title="1">{
        if File_event_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_event_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   19,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_event_proto_goTypes,
                DependencyIndexes: file_event_proto_depIdxs,
                MessageInfos:      file_event_proto_msgTypes,
        }.Build()
        File_event_proto = out.File
        file_event_proto_rawDesc = nil
        file_event_proto_goTypes = nil
        file_event_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: event.proto

package event

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        EventService_AddEvent_FullMethodName                  = "/event.EventService/AddEvent"
        EventService_AddEventToFavorites_FullMethodName       = "/event.EventService/AddEventToFavorites"
        EventService_DeleteEventFromFavorites_FullMethodName  = "/event.EventService/DeleteEventFromFavorites"
        EventService_DeleteEvent_FullMethodName               = "/event.EventService/DeleteEvent"
        EventService_GetCategories_FullMethodName             = "/event.EventService/GetCategories"
        EventService_GetEventByID_FullMethodName              = "/event.EventService/GetEventByID"
        EventService_GetEventsByCategory_FullMethodName       = "/event.EventService/GetEventsByCategory"
        EventService_GetEventsByUser_FullMethodName           = "/event.EventService/GetEventsByUser"
        EventService_GetFavorites_FullMethodName              = "/event.EventService/GetFavorites"
        EventService_GetPastEvents_FullMethodName             = "/event.EventService/GetPastEvents"
        EventService_GetUpcomingEvents_FullMethodName         = "/event.EventService/GetUpcomingEvents"
        EventService_GetSubscriptionsEvents_FullMethodName    = "/event.EventService/GetSubscriptionsEvents"
        EventService_UpdateEvent_FullMethodName               = "/event.EventService/UpdateEvent"
        EventService_SearchEvents_FullMethodName              = "/event.EventService/SearchEvents"
        EventService_GetUserIDsByFavoriteEvent_FullMethodName = "/event.EventService/GetUserIDsByFavoriteEvent"
        EventService_GetEventsByIDs_FullMethodName            = "/event.EventService/GetEventsByIDs"
        EventService_GetSubscribersIDs_FullMethodName         = "/event.EventService/GetSubscribersIDs"
)

// EventServiceClient is the client API for EventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EventServiceClient interface {
        AddEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
        AddEventToFavorites(ctx context.Context, in *FavoriteEvent, opts ...grpc.CallOption) (*Empty, error)
        DeleteEventFromFavorites(ctx context.Context, in *FavoriteEvent, opts ...grpc.CallOption) (*Empty, error)
        DeleteEvent(ctx context.Context, in *DeleteEventRequest, opts ...grpc.CallOption) (*Empty, error)
        GetCategories(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetCategoriesResponse, error)
        GetEventByID(ctx context.Context, in *GetEventByIDRequest, opts ...grpc.CallOption) (*Event, error)
        GetEventsByCategory(ctx context.Context, in *GetEventsByCategoryRequest, opts ...grpc.CallOption) (*Events, error)
        GetEventsByUser(ctx context.Context, in *GetEventsByUserRequest, opts ...grpc.CallOption) (*Events, error)
        GetFavorites(ctx context.Context, in *GetFavoritesRequest, opts ...grpc.CallOption) (*Events, error)
        GetPastEvents(ctx context.Context, in *PaginationParams, opts ...grpc.CallOption) (*Events, error)
        GetUpcomingEvents(ctx context.Context, in *PaginationParams, opts ...grpc.CallOption) (*Events, error)
        GetSubscriptionsEvents(ctx context.Context, in *GetSubscriptionsRequest, opts ...grpc.CallOption) (*Events, error)
        UpdateEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
        SearchEvents(ctx context.Context, in *SearchParams, opts ...grpc.CallOption) (*Events, error)
        GetUserIDsByFavoriteEvent(ctx context.Context, in *GetUserIDsByFavoriteEventRequest, opts ...grpc.CallOption) (*GetUserIDsResponse, error)
        GetEventsByIDs(ctx context.Context, in *GetEventsByIDsRequest, opts ...grpc.CallOption) (*Events, error)
        GetSubscribersIDs(ctx context.Context, in *GetSubscribersIDsRequest, opts ...grpc.CallOption) (*GetUserIDsResponse, error)
}

type eventServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewEventServiceClient(cc grpc.ClientConnInterface) EventServiceClient <span class="cov0" title="0">{
        return &amp;eventServiceClient{cc}
}</span>

func (c *eventServiceClient) AddEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Event)
        err := c.cc.Invoke(ctx, EventService_AddEvent_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *eventServiceClient) AddEventToFavorites(ctx context.Context, in *FavoriteEvent, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Empty)
        err := c.cc.Invoke(ctx, EventService_AddEventToFavorites_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *eventServiceClient) DeleteEventFromFavorites(ctx context.Context, in *FavoriteEvent, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Empty)
        err := c.cc.Invoke(ctx, EventService_DeleteEventFromFavorites_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *eventServiceClient) DeleteEvent(ctx context.Context, in *DeleteEventRequest, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Empty)
        err := c.cc.Invoke(ctx, EventService_DeleteEvent_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *eventServiceClient) GetCategories(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetCategoriesResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetCategoriesResponse)
        err := c.cc.Invoke(ctx, EventService_GetCategories_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *eventServiceClient) GetEventByID(ctx context.Context, in *GetEventByIDRequest, opts ...grpc.CallOption) (*Event, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Event)
        err := c.cc.Invoke(ctx, EventService_GetEventByID_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *eventServiceClient) GetEventsByCategory(ctx context.Context, in *GetEventsByCategoryRequest, opts ...grpc.CallOption) (*Events, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Events)
        err := c.cc.Invoke(ctx, EventService_GetEventsByCategory_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *eventServiceClient) GetEventsByUser(ctx context.Context, in *GetEventsByUserRequest, opts ...grpc.CallOption) (*Events, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Events)
        err := c.cc.Invoke(ctx, EventService_GetEventsByUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *eventServiceClient) GetFavorites(ctx context.Context, in *GetFavoritesRequest, opts ...grpc.CallOption) (*Events, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Events)
        err := c.cc.Invoke(ctx, EventService_GetFavorites_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *eventServiceClient) GetPastEvents(ctx context.Context, in *PaginationParams, opts ...grpc.CallOption) (*Events, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Events)
        err := c.cc.Invoke(ctx, EventService_GetPastEvents_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *eventServiceClient) GetUpcomingEvents(ctx context.Context, in *PaginationParams, opts ...grpc.CallOption) (*Events, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Events)
        err := c.cc.Invoke(ctx, EventService_GetUpcomingEvents_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *eventServiceClient) GetSubscriptionsEvents(ctx context.Context, in *GetSubscriptionsRequest, opts ...grpc.CallOption) (*Events, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Events)
        err := c.cc.Invoke(ctx, EventService_GetSubscriptionsEvents_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *eventServiceClient) UpdateEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Event)
        err := c.cc.Invoke(ctx, EventService_UpdateEvent_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *eventServiceClient) SearchEvents(ctx context.Context, in *SearchParams, opts ...grpc.CallOption) (*Events, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Events)
        err := c.cc.Invoke(ctx, EventService_SearchEvents_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *eventServiceClient) GetUserIDsByFavoriteEvent(ctx context.Context, in *GetUserIDsByFavoriteEventRequest, opts ...grpc.CallOption) (*GetUserIDsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetUserIDsResponse)
        err := c.cc.Invoke(ctx, EventService_GetUserIDsByFavoriteEvent_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *eventServiceClient) GetEventsByIDs(ctx context.Context, in *GetEventsByIDsRequest, opts ...grpc.CallOption) (*Events, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Events)
        err := c.cc.Invoke(ctx, EventService_GetEventsByIDs_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *eventServiceClient) GetSubscribersIDs(ctx context.Context, in *GetSubscribersIDsRequest, opts ...grpc.CallOption) (*GetUserIDsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetUserIDsResponse)
        err := c.cc.Invoke(ctx, EventService_GetSubscribersIDs_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// EventServiceServer is the server API for EventService service.
// All implementations must embed UnimplementedEventServiceServer
// for forward compatibility.
type EventServiceServer interface {
        AddEvent(context.Context, *Event) (*Event, error)
        AddEventToFavorites(context.Context, *FavoriteEvent) (*Empty, error)
        DeleteEventFromFavorites(context.Context, *FavoriteEvent) (*Empty, error)
        DeleteEvent(context.Context, *DeleteEventRequest) (*Empty, error)
        GetCategories(context.Context, *Empty) (*GetCategoriesResponse, error)
        GetEventByID(context.Context, *GetEventByIDRequest) (*Event, error)
        GetEventsByCategory(context.Context, *GetEventsByCategoryRequest) (*Events, error)
        GetEventsByUser(context.Context, *GetEventsByUserRequest) (*Events, error)
        GetFavorites(context.Context, *GetFavoritesRequest) (*Events, error)
        GetPastEvents(context.Context, *PaginationParams) (*Events, error)
        GetUpcomingEvents(context.Context, *PaginationParams) (*Events, error)
        GetSubscriptionsEvents(context.Context, *GetSubscriptionsRequest) (*Events, error)
        UpdateEvent(context.Context, *Event) (*Event, error)
        SearchEvents(context.Context, *SearchParams) (*Events, error)
        GetUserIDsByFavoriteEvent(context.Context, *GetUserIDsByFavoriteEventRequest) (*GetUserIDsResponse, error)
        GetEventsByIDs(context.Context, *GetEventsByIDsRequest) (*Events, error)
        GetSubscribersIDs(context.Context, *GetSubscribersIDsRequest) (*GetUserIDsResponse, error)
        mustEmbedUnimplementedEventServiceServer()
}

// UnimplementedEventServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEventServiceServer struct{}

func (UnimplementedEventServiceServer) AddEvent(context.Context, *Event) (*Event, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddEvent not implemented")
}</span>
func (UnimplementedEventServiceServer) AddEventToFavorites(context.Context, *FavoriteEvent) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddEventToFavorites not implemented")
}</span>
func (UnimplementedEventServiceServer) DeleteEventFromFavorites(context.Context, *FavoriteEvent) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteEventFromFavorites not implemented")
}</span>
func (UnimplementedEventServiceServer) DeleteEvent(context.Context, *DeleteEventRequest) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteEvent not implemented")
}</span>
func (UnimplementedEventServiceServer) GetCategories(context.Context, *Empty) (*GetCategoriesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetCategories not implemented")
}</span>
func (UnimplementedEventServiceServer) GetEventByID(context.Context, *GetEventByIDRequest) (*Event, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetEventByID not implemented")
}</span>
func (UnimplementedEventServiceServer) GetEventsByCategory(context.Context, *GetEventsByCategoryRequest) (*Events, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetEventsByCategory not implemented")
}</span>
func (UnimplementedEventServiceServer) GetEventsByUser(context.Context, *GetEventsByUserRequest) (*Events, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetEventsByUser not implemented")
}</span>
func (UnimplementedEventServiceServer) GetFavorites(context.Context, *GetFavoritesRequest) (*Events, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetFavorites not implemented")
}</span>
func (UnimplementedEventServiceServer) GetPastEvents(context.Context, *PaginationParams) (*Events, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetPastEvents not implemented")
}</span>
func (UnimplementedEventServiceServer) GetUpcomingEvents(context.Context, *PaginationParams) (*Events, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUpcomingEvents not implemented")
}</span>
func (UnimplementedEventServiceServer) GetSubscriptionsEvents(context.Context, *GetSubscriptionsRequest) (*Events, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetSubscriptionsEvents not implemented")
}</span>
func (UnimplementedEventServiceServer) UpdateEvent(context.Context, *Event) (*Event, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateEvent not implemented")
}</span>
func (UnimplementedEventServiceServer) SearchEvents(context.Context, *SearchParams) (*Events, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SearchEvents not implemented")
}</span>
func (UnimplementedEventServiceServer) GetUserIDsByFavoriteEvent(context.Context, *GetUserIDsByFavoriteEventRequest) (*GetUserIDsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserIDsByFavoriteEvent not implemented")
}</span>
func (UnimplementedEventServiceServer) GetEventsByIDs(context.Context, *GetEventsByIDsRequest) (*Events, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetEventsByIDs not implemented")
}</span>
func (UnimplementedEventServiceServer) GetSubscribersIDs(context.Context, *GetSubscribersIDsRequest) (*GetUserIDsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetSubscribersIDs not implemented")
}</span>
func (UnimplementedEventServiceServer) mustEmbedUnimplementedEventServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedEventServiceServer) testEmbeddedByValue()                      {<span class="cov0" title="0">}</span>

// UnsafeEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventServiceServer will
// result in compilation errors.
type UnsafeEventServiceServer interface {
        mustEmbedUnimplementedEventServiceServer()
}

func RegisterEventServiceServer(s grpc.ServiceRegistrar, srv EventServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedEventServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;EventService_ServiceDesc, srv)</span>
}

func _EventService_AddEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(Event)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).AddEvent(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EventService_AddEvent_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).AddEvent(ctx, req.(*Event))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _EventService_AddEventToFavorites_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(FavoriteEvent)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).AddEventToFavorites(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EventService_AddEventToFavorites_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).AddEventToFavorites(ctx, req.(*FavoriteEvent))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _EventService_DeleteEventFromFavorites_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(FavoriteEvent)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).DeleteEventFromFavorites(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EventService_DeleteEventFromFavorites_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).DeleteEventFromFavorites(ctx, req.(*FavoriteEvent))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _EventService_DeleteEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteEventRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).DeleteEvent(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EventService_DeleteEvent_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).DeleteEvent(ctx, req.(*DeleteEventRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _EventService_GetCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetCategories(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EventService_GetCategories_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetCategories(ctx, req.(*Empty))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _EventService_GetEventByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetEventByIDRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetEventByID(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EventService_GetEventByID_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetEventByID(ctx, req.(*GetEventByIDRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _EventService_GetEventsByCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetEventsByCategoryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetEventsByCategory(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EventService_GetEventsByCategory_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetEventsByCategory(ctx, req.(*GetEventsByCategoryRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _EventService_GetEventsByUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetEventsByUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetEventsByUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EventService_GetEventsByUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetEventsByUser(ctx, req.(*GetEventsByUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _EventService_GetFavorites_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetFavoritesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetFavorites(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EventService_GetFavorites_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetFavorites(ctx, req.(*GetFavoritesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _EventService_GetPastEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(PaginationParams)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetPastEvents(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EventService_GetPastEvents_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetPastEvents(ctx, req.(*PaginationParams))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _EventService_GetUpcomingEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(PaginationParams)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetUpcomingEvents(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EventService_GetUpcomingEvents_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetUpcomingEvents(ctx, req.(*PaginationParams))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _EventService_GetSubscriptionsEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetSubscriptionsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetSubscriptionsEvents(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EventService_GetSubscriptionsEvents_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetSubscriptionsEvents(ctx, req.(*GetSubscriptionsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _EventService_UpdateEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(Event)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).UpdateEvent(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EventService_UpdateEvent_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).UpdateEvent(ctx, req.(*Event))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _EventService_SearchEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SearchParams)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).SearchEvents(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EventService_SearchEvents_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).SearchEvents(ctx, req.(*SearchParams))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _EventService_GetUserIDsByFavoriteEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserIDsByFavoriteEventRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetUserIDsByFavoriteEvent(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EventService_GetUserIDsByFavoriteEvent_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetUserIDsByFavoriteEvent(ctx, req.(*GetUserIDsByFavoriteEventRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _EventService_GetEventsByIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetEventsByIDsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetEventsByIDs(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EventService_GetEventsByIDs_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetEventsByIDs(ctx, req.(*GetEventsByIDsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _EventService_GetSubscribersIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetSubscribersIDsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetSubscribersIDs(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: EventService_GetSubscribersIDs_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(EventServiceServer).GetSubscribersIDs(ctx, req.(*GetSubscribersIDsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// EventService_ServiceDesc is the grpc.ServiceDesc for EventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "event.EventService",
        HandlerType: (*EventServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "AddEvent",
                        Handler:    _EventService_AddEvent_Handler,
                },
                {
                        MethodName: "AddEventToFavorites",
                        Handler:    _EventService_AddEventToFavorites_Handler,
                },
                {
                        MethodName: "DeleteEventFromFavorites",
                        Handler:    _EventService_DeleteEventFromFavorites_Handler,
                },
                {
                        MethodName: "DeleteEvent",
                        Handler:    _EventService_DeleteEvent_Handler,
                },
                {
                        MethodName: "GetCategories",
                        Handler:    _EventService_GetCategories_Handler,
                },
                {
                        MethodName: "GetEventByID",
                        Handler:    _EventService_GetEventByID_Handler,
                },
                {
                        MethodName: "GetEventsByCategory",
                        Handler:    _EventService_GetEventsByCategory_Handler,
                },
                {
                        MethodName: "GetEventsByUser",
                        Handler:    _EventService_GetEventsByUser_Handler,
                },
                {
                        MethodName: "GetFavorites",
                        Handler:    _EventService_GetFavorites_Handler,
                },
                {
                        MethodName: "GetPastEvents",
                        Handler:    _EventService_GetPastEvents_Handler,
                },
                {
                        MethodName: "GetUpcomingEvents",
                        Handler:    _EventService_GetUpcomingEvents_Handler,
                },
                {
                        MethodName: "GetSubscriptionsEvents",
                        Handler:    _EventService_GetSubscriptionsEvents_Handler,
                },
                {
                        MethodName: "UpdateEvent",
                        Handler:    _EventService_UpdateEvent_Handler,
                },
                {
                        MethodName: "SearchEvents",
                        Handler:    _EventService_SearchEvents_Handler,
                },
                {
                        MethodName: "GetUserIDsByFavoriteEvent",
                        Handler:    _EventService_GetUserIDsByFavoriteEvent_Handler,
                },
                {
                        MethodName: "GetEventsByIDs",
                        Handler:    _EventService_GetEventsByIDs_Handler,
                },
                {
                        MethodName: "GetSubscribersIDs",
                        Handler:    _EventService_GetSubscribersIDs_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "event.proto",
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package grpc

import (
        "context"

        pb "kudago/internal/event/api"
        "kudago/internal/models"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) AddEvent(ctx context.Context, req *pb.Event) (*pb.Event, error) <span class="cov8" title="1">{
        newEvent := eventPBToEvent(req)

        eventData, err := s.service.AddEvent(ctx, newEvent)
        if err != nil </span><span class="cov8" title="1">{
                switch err </span>{
                case models.ErrInvalidCategory:<span class="cov8" title="1">
                        return nil, status.Error(codes.InvalidArgument, ErrBadData)</span>
                }
                <span class="cov8" title="1">s.logger.Error(ctx, "add event", err)
                return nil, status.Error(codes.Internal, ErrInternal)</span>
        }

        <span class="cov8" title="1">event := eventToEventPB(eventData)

        return event, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package grpc

import (
        "context"

        pb "kudago/internal/event/api"
        "kudago/internal/models"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) AddEventToFavorites(ctx context.Context, req *pb.FavoriteEvent) (*pb.Empty, error) <span class="cov8" title="1">{
        newFavorite := favoritePBToFavorite(req)

        err := s.service.AddEventToFavorites(ctx, newFavorite)
        if err != nil </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Error(ctx, "add event to favorites", err)
                        switch err </span>{
                        case models.ErrForeignKeyViolation:<span class="cov8" title="1">
                                return nil, status.Error(codes.NotFound, ErrEventNotFound)</span>
                        case models.ErrNothingToInsert:<span class="cov8" title="1">
                                return nil, status.Error(codes.AlreadyExists, ErrAlreadyInFavorites)</span>
                        default:<span class="cov8" title="1">
                                return nil, status.Error(codes.Internal, ErrInternal)</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package grpc

import (
        "context"
        "errors"

        pb "kudago/internal/event/api"
        "kudago/internal/models"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) DeleteEvent(ctx context.Context, req *pb.DeleteEventRequest) (*pb.Empty, error) <span class="cov8" title="1">{
        err := s.service.DeleteEvent(ctx, int(req.EventID), int(req.AuthorID))
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.NotFound, ErrEventNotFound)
                }</span>
                <span class="cov8" title="1">if errors.Is(err, models.ErrAccessDenied) </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.PermissionDenied, ErrPermissionDenied)
                }</span>
                <span class="cov8" title="1">s.logger.Error(ctx, "delete event", err)
                return nil, status.Error(codes.Internal, ErrInternal)</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package grpc

import (
        "context"
        "errors"

        pb "kudago/internal/event/api"
        "kudago/internal/models"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) DeleteEventFromFavorites(ctx context.Context, req *pb.FavoriteEvent) (*pb.Empty, error) <span class="cov8" title="1">{
        newFavorite := favoritePBToFavorite(req)

        err := s.service.DeleteEventFromFavorites(ctx, newFavorite)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.NotFound, ErrEventNotFound)
                }</span>
                <span class="cov8" title="1">s.logger.Error(ctx, "delete event from favorites", err)
                return nil, status.Error(codes.Internal, ErrInternal)</span>
        }

        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">//go:generate mockgen -source=event.go -destination=tests/mocks/event.go -package=mocks

package grpc

import (
        "context"

        pb "kudago/internal/event/api"
        "kudago/internal/logger"
        "kudago/internal/models"
)

const (
        ErrInternal           = "internal error"
        ErrEventNotFound      = "event not found"
        ErrPermissionDenied   = "permission denied"
        ErrAlreadyInFavorites = "event is already in favorites"
        ErrBadData            = "bad data request"
)

type ServerAPI struct {
        pb.UnimplementedEventServiceServer
        service EventService
        getter  EventsGetter
        logger  *logger.Logger
}

type EventService interface {
        AddEvent(ctx context.Context, event models.Event) (models.Event, error)
        DeleteEvent(ctx context.Context, ID, authorID int) error
        UpdateEvent(ctx context.Context, event models.Event) (models.Event, error)
        SearchEvents(ctx context.Context, params models.SearchParams, paginationParams models.PaginationParams) ([]models.Event, error)
        AddEventToFavorites(ctx context.Context, newFavorite models.FavoriteEvent) error
        DeleteEventFromFavorites(ctx context.Context, newFavorite models.FavoriteEvent) error
}

type EventsGetter interface {
        GetUpcomingEvents(ctx context.Context, paginationParams models.PaginationParams) ([]models.Event, error)
        GetPastEvents(ctx context.Context, paginationParams models.PaginationParams) ([]models.Event, error)
        GetEventsByCategory(ctx context.Context, categoryID int, paginationParams models.PaginationParams) ([]models.Event, error)
        GetEventsByUser(ctx context.Context, userID int, paginationParams models.PaginationParams) ([]models.Event, error)
        GetCategories(ctx context.Context) ([]models.Category, error)
        GetEventByID(ctx context.Context, ID int) (models.Event, error)
        GetFavorites(ctx context.Context, userID int, paginationParams models.PaginationParams) ([]models.Event, error)
        GetSubscriptionEvents(ctx context.Context, userID int, paginationParams models.PaginationParams) ([]models.Event, error)
        GetUserIDsByFavoriteEvent(ctx context.Context, eventID int) ([]int, error)
        GetEventsByIDs(ctx context.Context, ids []int) ([]models.Event, error)
        GetSubscribersIDs(ctx context.Context, id int) ([]int, error)
}

func NewServerAPI(service EventService, getter EventsGetter, logger *logger.Logger) *ServerAPI <span class="cov8" title="1">{
        return &amp;ServerAPI{
                service: service,
                getter:  getter,
                logger:  logger,
        }
}</span>

func eventPBToEvent(event *pb.Event) models.Event <span class="cov8" title="1">{
        return models.Event{
                ID:          int(event.ID),
                Title:       event.Title,
                Description: event.Description,
                EventStart:  event.EventStart,
                EventEnd:    event.EventEnd,
                Location:    event.Location,
                Capacity:    int(event.Capacity),
                CategoryID:  int(event.CategoryID),
                Tag:         event.Tag,
                AuthorID:    int(event.AuthorID),
                ImageURL:    event.Image,
                Latitude:    float64(event.Latitude),
                Longitude:   float64(event.Longitude),
        }
}</span>

func eventToEventPB(event models.Event) *pb.Event <span class="cov8" title="1">{
        return &amp;pb.Event{
                ID:          int32(event.ID),
                Title:       event.Title,
                Description: event.Description,
                EventStart:  event.EventStart,
                EventEnd:    event.EventEnd,
                Location:    event.Location,
                Capacity:    int32(event.Capacity),
                CategoryID:  int32(event.CategoryID),
                Tag:         event.Tag,
                AuthorID:    int32(event.AuthorID),
                Image:       event.ImageURL,
                Latitude:    float64(event.Latitude),
                Longitude:   float64(event.Longitude),
        }
}</span>

func favoritePBToFavorite(favorite *pb.FavoriteEvent) models.FavoriteEvent <span class="cov8" title="1">{
        return models.FavoriteEvent{
                EventID: int(favorite.EventID),
                UserID:  int(favorite.UserID),
        }
}</span>

func writeEventsResponse(events []models.Event, limit int) *pb.Events <span class="cov8" title="1">{
        pbEvents := make([]*pb.Event, 0, limit)
        for _, event := range events </span><span class="cov8" title="1">{
                pbEvents = append(pbEvents, eventToEventPB(event))
        }</span>

        <span class="cov8" title="1">return &amp;pb.Events{
                Events: pbEvents,
        }</span>
}

func getPaginationParams(params *pb.PaginationParams) models.PaginationParams <span class="cov8" title="1">{
        return models.PaginationParams{
                Limit:  int(params.Limit),
                Offset: int(params.Offset),
        }
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package grpc

import (
        "context"

        pb "kudago/internal/event/api"
        "kudago/internal/models"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) GetCategories(ctx context.Context, req *pb.Empty) (*pb.GetCategoriesResponse, error) <span class="cov8" title="1">{
        categories, err := s.getter.GetCategories(ctx)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "get categories", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>
        <span class="cov8" title="1">resp := writeCategoriesResponse(categories)
        return resp, nil</span>
}

func writeCategoriesResponse(categories []models.Category) *pb.GetCategoriesResponse <span class="cov8" title="1">{
        pbCategories := make([]*pb.Category, 0, 16)
        for _, category := range categories </span><span class="cov8" title="1">{
                pbCategories = append(pbCategories, &amp;pb.Category{
                        ID:   int32(category.ID),
                        Name: category.Name,
                })
        }</span>

        <span class="cov8" title="1">return &amp;pb.GetCategoriesResponse{
                Categories: pbCategories,
        }</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package grpc

import (
        "context"
        "errors"

        pb "kudago/internal/event/api"
        "kudago/internal/models"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) GetEventByID(ctx context.Context, req *pb.GetEventByIDRequest) (*pb.Event, error) <span class="cov8" title="1">{
        eventData, err := s.getter.GetEventByID(ctx, int(req.ID))
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrEventNotFound) </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.NotFound, ErrEventNotFound)
                }</span>
                <span class="cov8" title="1">s.logger.Error(ctx, "get event by id", err)
                return nil, status.Error(codes.Internal, ErrInternal)</span>
        }

        <span class="cov8" title="1">event := eventToEventPB(eventData)

        return event, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package grpc

import (
        "context"

        pb "kudago/internal/event/api"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) GetEventsByCategory(ctx context.Context, req *pb.GetEventsByCategoryRequest) (*pb.Events, error) <span class="cov8" title="1">{
        params := getPaginationParams(req.Params)
        eventsData, err := s.getter.GetEventsByCategory(ctx, int(req.CategoryID), params)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "get events by category", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>

        <span class="cov8" title="1">event := writeEventsResponse(eventsData, params.Limit)

        return event, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package grpc

import (
        "context"
        "errors"

        pb "kudago/internal/event/api"
        "kudago/internal/models"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) GetEventsByIDs(ctx context.Context, req *pb.GetEventsByIDsRequest) (*pb.Events, error) <span class="cov0" title="0">{
        ids := make([]int, 0, len(req.IDs))
        for _, id := range req.IDs </span><span class="cov0" title="0">{
                ids = append(ids, int(id))
        }</span>

        <span class="cov0" title="0">events, err := s.getter.GetEventsByIDs(ctx, ids)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, models.ErrEventNotFound) </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.NotFound, ErrEventNotFound)
                }</span>
                <span class="cov0" title="0">s.logger.Error(ctx, "get events by ids", err)
                return nil, status.Error(codes.Internal, ErrInternal)</span>
        }

        <span class="cov0" title="0">resp := writeEventsResponse(events, len(req.IDs))

        return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package grpc

import (
        "context"

        pb "kudago/internal/event/api"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) GetEventsByUser(ctx context.Context, req *pb.GetEventsByUserRequest) (*pb.Events, error) <span class="cov8" title="1">{
        params := getPaginationParams(req.Params)
        eventsData, err := s.getter.GetEventsByUser(ctx, int(req.UserID), params)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "get events by user", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>

        <span class="cov8" title="1">resp := writeEventsResponse(eventsData, params.Limit)

        return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package grpc

import (
        "context"

        pb "kudago/internal/event/api"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) GetFavorites(ctx context.Context, req *pb.GetFavoritesRequest) (*pb.Events, error) <span class="cov8" title="1">{
        params := getPaginationParams(req.Params)
        eventsData, err := s.getter.GetFavorites(ctx, int(req.UserID), params)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "get favorites", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>

        <span class="cov8" title="1">event := writeEventsResponse(eventsData, params.Limit)

        return event, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package grpc

import (
        "context"

        pb "kudago/internal/event/api"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) GetPastEvents(ctx context.Context, req *pb.PaginationParams) (*pb.Events, error) <span class="cov8" title="1">{
        params := getPaginationParams(req)
        eventsData, err := s.getter.GetPastEvents(ctx, params)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "get past events", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>

        <span class="cov8" title="1">event := writeEventsResponse(eventsData, params.Limit)

        return event, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package grpc

import (
        "context"

        pb "kudago/internal/event/api"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) GetSubscribersIDs(ctx context.Context, req *pb.GetSubscribersIDsRequest) (*pb.GetUserIDsResponse, error) <span class="cov8" title="1">{
        ids, err := s.getter.GetSubscribersIDs(ctx, int(req.UserID))
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "get subscribers", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.GetUserIDsResponse{
                IDs: make([]int32, 0, len(ids)),
        }

        for _, id := range ids </span><span class="cov8" title="1">{
                resp.IDs = append(resp.IDs, int32(id))
        }</span>

        <span class="cov8" title="1">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package grpc

import (
        "context"

        pb "kudago/internal/event/api"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) GetSubscriptionsEvents(ctx context.Context, req *pb.GetSubscriptionsRequest) (*pb.Events, error) <span class="cov8" title="1">{
        params := getPaginationParams(req.Params)
        eventsData, err := s.getter.GetSubscriptionEvents(ctx, int(req.ID), params)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "get subscription event", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>

        <span class="cov8" title="1">event := writeEventsResponse(eventsData, params.Limit)

        return event, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package grpc

import (
        "context"

        pb "kudago/internal/event/api"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) GetUpcomingEvents(ctx context.Context, req *pb.PaginationParams) (*pb.Events, error) <span class="cov8" title="1">{
        params := getPaginationParams(req)
        eventsData, err := s.getter.GetUpcomingEvents(ctx, params)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "get upcoming events", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>

        <span class="cov8" title="1">event := writeEventsResponse(eventsData, params.Limit)

        return event, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package grpc

import (
        "context"

        pb "kudago/internal/event/api"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) GetUserIDsByFavoriteEvent(ctx context.Context, req *pb.GetUserIDsByFavoriteEventRequest) (*pb.GetUserIDsResponse, error) <span class="cov8" title="1">{
        ids, err := s.getter.GetUserIDsByFavoriteEvent(ctx, int(req.ID))
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "get user ids by favorite", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.GetUserIDsResponse{
                IDs: make([]int32, 0, len(ids)),
        }

        for _, id := range ids </span><span class="cov8" title="1">{
                resp.IDs = append(resp.IDs, int32(id))
        }</span>

        <span class="cov8" title="1">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package grpc

import (
        "context"

        pb "kudago/internal/event/api"
        "kudago/internal/models"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) SearchEvents(ctx context.Context, req *pb.SearchParams) (*pb.Events, error) <span class="cov8" title="1">{
        params := getPaginationParams(req.Params)

        searchParams := models.SearchParams{
                Query:        req.Query,
                EventStart:   req.EventStart,
                EventEnd:     req.EventEnd,
                Tags:         req.Tag,
                Category:     int(req.CategoryID),
                LatitudeMin:  float64(req.LatitudeMin),
                LatitudeMax:  float64(req.LatitudeMax),
                LongitudeMin: float64(req.LongitudeMin),
                LongitudeMax: float64(req.LongitudeMax),
        }

        eventsData, err := s.service.SearchEvents(ctx, searchParams, params)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "search events", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>

        <span class="cov8" title="1">event := writeEventsResponse(eventsData, params.Limit)

        return event, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: event.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        models "kudago/internal/models"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockEventService is a mock of EventService interface.
type MockEventService struct {
        ctrl     *gomock.Controller
        recorder *MockEventServiceMockRecorder
}

// MockEventServiceMockRecorder is the mock recorder for MockEventService.
type MockEventServiceMockRecorder struct {
        mock *MockEventService
}

// NewMockEventService creates a new mock instance.
func NewMockEventService(ctrl *gomock.Controller) *MockEventService <span class="cov8" title="1">{
        mock := &amp;MockEventService{ctrl: ctrl}
        mock.recorder = &amp;MockEventServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventService) EXPECT() *MockEventServiceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AddEvent mocks base method.
func (m *MockEventService) AddEvent(ctx context.Context, event models.Event) (models.Event, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddEvent", ctx, event)
        ret0, _ := ret[0].(models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AddEvent indicates an expected call of AddEvent.
func (mr *MockEventServiceMockRecorder) AddEvent(ctx, event interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddEvent", reflect.TypeOf((*MockEventService)(nil).AddEvent), ctx, event)
}</span>

// AddEventToFavorites mocks base method.
func (m *MockEventService) AddEventToFavorites(ctx context.Context, newFavorite models.FavoriteEvent) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddEventToFavorites", ctx, newFavorite)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AddEventToFavorites indicates an expected call of AddEventToFavorites.
func (mr *MockEventServiceMockRecorder) AddEventToFavorites(ctx, newFavorite interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddEventToFavorites", reflect.TypeOf((*MockEventService)(nil).AddEventToFavorites), ctx, newFavorite)
}</span>

// DeleteEvent mocks base method.
func (m *MockEventService) DeleteEvent(ctx context.Context, ID, authorID int) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteEvent", ctx, ID, authorID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteEvent indicates an expected call of DeleteEvent.
func (mr *MockEventServiceMockRecorder) DeleteEvent(ctx, ID, authorID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteEvent", reflect.TypeOf((*MockEventService)(nil).DeleteEvent), ctx, ID, authorID)
}</span>

// DeleteEventFromFavorites mocks base method.
func (m *MockEventService) DeleteEventFromFavorites(ctx context.Context, newFavorite models.FavoriteEvent) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteEventFromFavorites", ctx, newFavorite)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteEventFromFavorites indicates an expected call of DeleteEventFromFavorites.
func (mr *MockEventServiceMockRecorder) DeleteEventFromFavorites(ctx, newFavorite interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteEventFromFavorites", reflect.TypeOf((*MockEventService)(nil).DeleteEventFromFavorites), ctx, newFavorite)
}</span>

// SearchEvents mocks base method.
func (m *MockEventService) SearchEvents(ctx context.Context, params models.SearchParams, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SearchEvents", ctx, params, paginationParams)
        ret0, _ := ret[0].([]models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SearchEvents indicates an expected call of SearchEvents.
func (mr *MockEventServiceMockRecorder) SearchEvents(ctx, params, paginationParams interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchEvents", reflect.TypeOf((*MockEventService)(nil).SearchEvents), ctx, params, paginationParams)
}</span>

// UpdateEvent mocks base method.
func (m *MockEventService) UpdateEvent(ctx context.Context, event models.Event) (models.Event, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateEvent", ctx, event)
        ret0, _ := ret[0].(models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateEvent indicates an expected call of UpdateEvent.
func (mr *MockEventServiceMockRecorder) UpdateEvent(ctx, event interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateEvent", reflect.TypeOf((*MockEventService)(nil).UpdateEvent), ctx, event)
}</span>

// MockEventsGetter is a mock of EventsGetter interface.
type MockEventsGetter struct {
        ctrl     *gomock.Controller
        recorder *MockEventsGetterMockRecorder
}

// MockEventsGetterMockRecorder is the mock recorder for MockEventsGetter.
type MockEventsGetterMockRecorder struct {
        mock *MockEventsGetter
}

// NewMockEventsGetter creates a new mock instance.
func NewMockEventsGetter(ctrl *gomock.Controller) *MockEventsGetter <span class="cov8" title="1">{
        mock := &amp;MockEventsGetter{ctrl: ctrl}
        mock.recorder = &amp;MockEventsGetterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventsGetter) EXPECT() *MockEventsGetterMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// GetCategories mocks base method.
func (m *MockEventsGetter) GetCategories(ctx context.Context) ([]models.Category, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCategories", ctx)
        ret0, _ := ret[0].([]models.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCategories indicates an expected call of GetCategories.
func (mr *MockEventsGetterMockRecorder) GetCategories(ctx interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCategories", reflect.TypeOf((*MockEventsGetter)(nil).GetCategories), ctx)
}</span>

// GetEventByID mocks base method.
func (m *MockEventsGetter) GetEventByID(ctx context.Context, ID int) (models.Event, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetEventByID", ctx, ID)
        ret0, _ := ret[0].(models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetEventByID indicates an expected call of GetEventByID.
func (mr *MockEventsGetterMockRecorder) GetEventByID(ctx, ID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEventByID", reflect.TypeOf((*MockEventsGetter)(nil).GetEventByID), ctx, ID)
}</span>

// GetEventsByCategory mocks base method.
func (m *MockEventsGetter) GetEventsByCategory(ctx context.Context, categoryID int, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetEventsByCategory", ctx, categoryID, paginationParams)
        ret0, _ := ret[0].([]models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetEventsByCategory indicates an expected call of GetEventsByCategory.
func (mr *MockEventsGetterMockRecorder) GetEventsByCategory(ctx, categoryID, paginationParams interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEventsByCategory", reflect.TypeOf((*MockEventsGetter)(nil).GetEventsByCategory), ctx, categoryID, paginationParams)
}</span>

// GetEventsByIDs mocks base method.
func (m *MockEventsGetter) GetEventsByIDs(ctx context.Context, ids []int) ([]models.Event, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetEventsByIDs", ctx, ids)
        ret0, _ := ret[0].([]models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetEventsByIDs indicates an expected call of GetEventsByIDs.
func (mr *MockEventsGetterMockRecorder) GetEventsByIDs(ctx, ids interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEventsByIDs", reflect.TypeOf((*MockEventsGetter)(nil).GetEventsByIDs), ctx, ids)
}</span>

// GetEventsByUser mocks base method.
func (m *MockEventsGetter) GetEventsByUser(ctx context.Context, userID int, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetEventsByUser", ctx, userID, paginationParams)
        ret0, _ := ret[0].([]models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetEventsByUser indicates an expected call of GetEventsByUser.
func (mr *MockEventsGetterMockRecorder) GetEventsByUser(ctx, userID, paginationParams interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEventsByUser", reflect.TypeOf((*MockEventsGetter)(nil).GetEventsByUser), ctx, userID, paginationParams)
}</span>

// GetFavorites mocks base method.
func (m *MockEventsGetter) GetFavorites(ctx context.Context, userID int, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetFavorites", ctx, userID, paginationParams)
        ret0, _ := ret[0].([]models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetFavorites indicates an expected call of GetFavorites.
func (mr *MockEventsGetterMockRecorder) GetFavorites(ctx, userID, paginationParams interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFavorites", reflect.TypeOf((*MockEventsGetter)(nil).GetFavorites), ctx, userID, paginationParams)
}</span>

// GetPastEvents mocks base method.
func (m *MockEventsGetter) GetPastEvents(ctx context.Context, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetPastEvents", ctx, paginationParams)
        ret0, _ := ret[0].([]models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetPastEvents indicates an expected call of GetPastEvents.
func (mr *MockEventsGetterMockRecorder) GetPastEvents(ctx, paginationParams interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPastEvents", reflect.TypeOf((*MockEventsGetter)(nil).GetPastEvents), ctx, paginationParams)
}</span>

// GetSubscribersIDs mocks base method.
func (m *MockEventsGetter) GetSubscribersIDs(ctx context.Context, id int) ([]int, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSubscribersIDs", ctx, id)
        ret0, _ := ret[0].([]int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSubscribersIDs indicates an expected call of GetSubscribersIDs.
func (mr *MockEventsGetterMockRecorder) GetSubscribersIDs(ctx, id interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubscribersIDs", reflect.TypeOf((*MockEventsGetter)(nil).GetSubscribersIDs), ctx, id)
}</span>

// GetSubscriptionEvents mocks base method.
func (m *MockEventsGetter) GetSubscriptionEvents(ctx context.Context, userID int, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSubscriptionEvents", ctx, userID, paginationParams)
        ret0, _ := ret[0].([]models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSubscriptionEvents indicates an expected call of GetSubscriptionEvents.
func (mr *MockEventsGetterMockRecorder) GetSubscriptionEvents(ctx, userID, paginationParams interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubscriptionEvents", reflect.TypeOf((*MockEventsGetter)(nil).GetSubscriptionEvents), ctx, userID, paginationParams)
}</span>

// GetUpcomingEvents mocks base method.
func (m *MockEventsGetter) GetUpcomingEvents(ctx context.Context, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUpcomingEvents", ctx, paginationParams)
        ret0, _ := ret[0].([]models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUpcomingEvents indicates an expected call of GetUpcomingEvents.
func (mr *MockEventsGetterMockRecorder) GetUpcomingEvents(ctx, paginationParams interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUpcomingEvents", reflect.TypeOf((*MockEventsGetter)(nil).GetUpcomingEvents), ctx, paginationParams)
}</span>

// GetUserIDsByFavoriteEvent mocks base method.
func (m *MockEventsGetter) GetUserIDsByFavoriteEvent(ctx context.Context, eventID int) ([]int, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserIDsByFavoriteEvent", ctx, eventID)
        ret0, _ := ret[0].([]int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserIDsByFavoriteEvent indicates an expected call of GetUserIDsByFavoriteEvent.
func (mr *MockEventsGetterMockRecorder) GetUserIDsByFavoriteEvent(ctx, eventID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserIDsByFavoriteEvent", reflect.TypeOf((*MockEventsGetter)(nil).GetUserIDsByFavoriteEvent), ctx, eventID)
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package grpc

import (
        "context"
        "errors"

        pb "kudago/internal/event/api"
        "kudago/internal/models"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) UpdateEvent(ctx context.Context, req *pb.Event) (*pb.Event, error) <span class="cov8" title="1">{
        newEvent := eventPBToEvent(req)

        eventData, err := s.service.UpdateEvent(ctx, newEvent)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "update event", err)
                switch </span>{
                case errors.Is(err, models.ErrEventNotFound):<span class="cov8" title="1">
                        return nil, status.Error(codes.NotFound, ErrEventNotFound)</span>
                case errors.Is(err, models.ErrAccessDenied):<span class="cov8" title="1">
                        return nil, status.Error(codes.PermissionDenied, ErrPermissionDenied)</span>
                default:<span class="cov8" title="1">
                        return nil, status.Error(codes.Internal, ErrInternal)</span>
                }
        }

        <span class="cov8" title="1">event := eventToEventPB(eventData)

        return event, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package eventRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"

        "github.com/jackc/pgx/v5/pgconn"
        "github.com/pkg/errors"
)

const insertNewFavorite = `
        INSERT INTO FAVORITE_EVENT (user_id, event_id)
        VALUES ($1, $2)
        ON CONFLICT DO NOTHING`

func (db *EventDB) AddEventToFavorites(ctx context.Context, newFavorite models.FavoriteEvent) error <span class="cov0" title="0">{
        result, err := db.pool.Exec(ctx, insertNewFavorite, newFavorite.UserID, newFavorite.EventID)
        if err != nil </span><span class="cov0" title="0">{
                var pgErr *pgconn.PgError
                if errors.As(err, &amp;pgErr) </span><span class="cov0" title="0">{
                        return models.ErrForeignKeyViolation
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("%s: %w", models.LevelDB, err)</span>
        }

        <span class="cov0" title="0">rowsAffected := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                return models.ErrNothingToInsert
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package eventRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

const createEventQuery = `
        INSERT INTO event (title, description, event_start, event_finish, location, capacity, user_id, category_id, lat, lon)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING id`

func (db *EventDB) CreateEvent(ctx context.Context, event models.Event) (models.Event, error) <span class="cov0" title="0">{
        tx, err := db.pool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return models.Event{}, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback(ctx)

        var id int
        err = tx.QueryRow(ctx, createEventQuery, event.Title, event.Description, event.EventStart, event.EventEnd, event.Location, event.Capacity, event.AuthorID, event.CategoryID, event.Latitude, event.Longitude).Scan(&amp;id)
        if err != nil </span><span class="cov0" title="0">{
                return models.Event{}, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov0" title="0">event.ID = id
        err = db.addTagsToEvent(ctx, tx, id, event.Tag)
        if err != nil </span><span class="cov0" title="0">{
                return models.Event{}, err
        }</span>

        <span class="cov0" title="0">err = db.addMediaURL(ctx, tx, id, event.ImageURL)
        if err != nil </span><span class="cov0" title="0">{
                return models.Event{}, err
        }</span>

        <span class="cov0" title="0">err = tx.Commit(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return models.Event{}, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov0" title="0">event.ID = id
        return event, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package eventRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

const deleteEventQuery = `DELETE FROM event WHERE id=$1`

func (db *EventDB) DeleteEvent(ctx context.Context, ID int) error <span class="cov8" title="1">{
        _, err := db.pool.Exec(ctx, deleteEventQuery, ID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package eventRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

const deleteFavorite = `DELETE FROM FAVORITE_EVENT WHERE user_id=$1 AND event_id=$2`

func (db *EventDB) DeleteEventFromFavorites(ctx context.Context, favorite models.FavoriteEvent) error <span class="cov8" title="1">{
        result, err := db.pool.Exec(ctx, deleteFavorite, favorite.UserID, favorite.EventID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov8" title="1">rowsAffected := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov8" title="1">{
                return models.ErrNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">//go:generate mockgen -source /home/ksu/go/pkg/mod/github.com/jackc/pgx/v5@v5.7.1/tx.go -destination=./mocks/mocks_tx.go -package=mocks
//go:generate mockgen -source events.go -destination=./mocks/mocks.go -package=mocks

package eventRepository

import (
        "context"
        "fmt"
        "time"

        "kudago/internal/models"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type EventDB struct {
        pool Pool
}

type Pool interface {
        Begin(ctx context.Context) (pgx.Tx, error)
        Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error)
        Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error)
        QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
        SendBatch(ctx context.Context, b *pgx.Batch) pgx.BatchResults
}

type EventInfo struct {
        ID          int       `db:"id"`
        Title       string    `db:"title"`
        Description string    `db:"description"`
        EventStart  time.Time `db:"event_start"`
        EventFinish time.Time `db:"event_finish"`
        Location    string    `db:"location"`
        Capacity    int       `db:"capacity"`
        CreatedAt   time.Time `db:"created_at"`
        UserID      int       `db:"user_id"`
        CategoryID  int       `db:"category_id"`
        Latitude    float64   `db:"lat"`
        Longitude   float64   `db:"lon"`
        Tags        []string  `db:"tags"`
        ImageURL    *string   `db:"image"`
}

func NewDB(pool Pool) *EventDB <span class="cov8" title="1">{
        return &amp;EventDB{
                pool: pool,
        }
}</span>

const deleteEventTagsQuery = `DELETE FROM event_tag WHERE event_id = $1`

func (db *EventDB) updateTagsForEvent(ctx context.Context, tx pgx.Tx, eventID int, tags []string) error <span class="cov0" title="0">{
        _, err := tx.Exec(ctx, deleteEventTagsQuery, eventID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov0" title="0">return db.addTagsToEvent(ctx, tx, eventID, tags)</span>
}

const deleteMediaURLQuery = `DELETE FROM media_url WHERE event_id = $1`

func (db *EventDB) updateMediaURL(ctx context.Context, tx pgx.Tx, eventID int, imageURL string) error <span class="cov0" title="0">{
        _, err := tx.Exec(ctx, deleteMediaURLQuery, eventID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov0" title="0">return db.addMediaURL(ctx, tx, eventID, imageURL)</span>
}

const insertTagsQuery = `
        INSERT INTO tag (name) 
        VALUES ($1)
        ON CONFLICT (name) DO NOTHING`

const selectTagIDsQuery = `SELECT id FROM tag WHERE name = ANY($1)`

func (db *EventDB) addTagsToEvent(ctx context.Context, tx pgx.Tx, eventID int, tags []string) error <span class="cov0" title="0">{
        tagIDs := make([]int, 0, len(tags))

        for _, tag := range tags </span><span class="cov0" title="0">{
                _, err := tx.Exec(ctx, insertTagsQuery, tag)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>
        }

        <span class="cov0" title="0">rows, err := tx.Query(ctx, selectTagIDsQuery, tags)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var id int
                if err := rows.Scan(&amp;id); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>
                <span class="cov0" title="0">tagIDs = append(tagIDs, id)</span>
        }

        <span class="cov0" title="0">err = db.linkTagsToEvent(ctx, tx, eventID, tagIDs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

const insertEventTagQuery = `
        INSERT INTO event_tag (event_id, tag_id)
        VALUES ($1, $2)`

func (db *EventDB) linkTagsToEvent(ctx context.Context, tx pgx.Tx, eventID int, tagIDs []int) error <span class="cov0" title="0">{
        batch := &amp;pgx.Batch{}
        for _, tagID := range tagIDs </span><span class="cov0" title="0">{
                batch.Queue(insertEventTagQuery, eventID, tagID)
        }</span>
        <span class="cov0" title="0">br := tx.SendBatch(ctx, batch)
        defer br.Close()

        for range tagIDs </span><span class="cov0" title="0">{
                _, err := br.Exec()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

const insertMediaURL = `
        INSERT INTO media_url (event_id, url)
        VALUES ($1, $2)`

func (db *EventDB) addMediaURL(ctx context.Context, tx pgx.Tx, eventID int, imageURL string) error <span class="cov0" title="0">{
        _, err := tx.Exec(ctx, insertMediaURL, eventID, imageURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (db *EventDB) toDomainEvent(ctx context.Context, eventInfo EventInfo) (models.Event, error) <span class="cov0" title="0">{
        url := ""

        if eventInfo.ImageURL != nil </span><span class="cov0" title="0">{
                url = *eventInfo.ImageURL
        }</span>
        <span class="cov0" title="0">return models.Event{
                ID:          eventInfo.ID,
                Title:       eventInfo.Title,
                Description: eventInfo.Description,
                EventStart:  eventInfo.EventStart.Format(time.RFC3339),
                EventEnd:    eventInfo.EventFinish.Format(time.RFC3339),
                AuthorID:    eventInfo.UserID,
                Tag:         eventInfo.Tags,
                Location:    eventInfo.Location,
                Capacity:    eventInfo.Capacity,
                CategoryID:  eventInfo.CategoryID,
                ImageURL:    url,
                Longitude:   eventInfo.Longitude,
                Latitude:    eventInfo.Latitude,
        }, nil</span>
}

func nilIfZero(value int) interface{} <span class="cov0" title="0">{
        if value == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return value</span>
}

func nilIfZeroFloat(value float64) interface{} <span class="cov0" title="0">{
        if value == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return value</span>
}

func nilIfEmpty(value string) interface{} <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return value</span>
}

func tagsToArray(tags []string) interface{} <span class="cov0" title="0">{
        if len(tags) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return tags</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package eventRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

const getCategoriesQuery = `SELECT * FROM category`

func (db *EventDB) GetCategories(ctx context.Context) ([]models.Category, error) <span class="cov8" title="1">{
        rows, err := db.pool.Query(ctx, getCategoriesQuery)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        categories := make([]models.Category, 0, 10)
        for rows.Next() </span><span class="cov8" title="1">{
                var category models.Category
                err = rows.Scan(
                        &amp;category.ID,
                        &amp;category.Name,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>
                <span class="cov8" title="1">categories = append(categories, category)</span>
        }

        <span class="cov8" title="1">return categories, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package eventRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"

        "github.com/jackc/pgx/v5"
        "github.com/pkg/errors"
)

const getEventByIDQuery = `
        SELECT event.id, event.title, event.description, event.event_start, event.event_finish, 
        event.location, event.capacity, event.created_at, event.user_id, event.category_id, event.lat, event.lon, 
        COALESCE(array_agg(COALESCE(tag.name, '')), '{}') AS tags, media_url.url AS media_link
        FROM event
        LEFT JOIN event_tag ON event.id = event_tag.event_id
        LEFT JOIN tag ON tag.id = event_tag.tag_id
        LEFT JOIN media_url ON event.id = media_url.event_id
        WHERE event.id=$1
        GROUP BY event.id, media_url.url`

func (db *EventDB) GetEventByID(ctx context.Context, ID int) (models.Event, error) <span class="cov0" title="0">{
        var eventInfo EventInfo
        err := db.pool.QueryRow(ctx, getEventByIDQuery, ID).Scan(
                &amp;eventInfo.ID,
                &amp;eventInfo.Title,
                &amp;eventInfo.Description,
                &amp;eventInfo.EventStart,
                &amp;eventInfo.EventFinish,
                &amp;eventInfo.Location,
                &amp;eventInfo.Capacity,
                &amp;eventInfo.CreatedAt,
                &amp;eventInfo.UserID,
                &amp;eventInfo.CategoryID,
                &amp;eventInfo.Latitude,
                &amp;eventInfo.Longitude,
                &amp;eventInfo.Tags,
                &amp;eventInfo.ImageURL,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return models.Event{}, fmt.Errorf("%s: %w", models.LevelDB, models.ErrEventNotFound)
                }</span>
                <span class="cov0" title="0">return models.Event{}, fmt.Errorf("%s: %w", models.LevelDB, err)</span>
        }

        <span class="cov0" title="0">event, err := db.toDomainEvent(ctx, eventInfo)
        if err != nil </span><span class="cov0" title="0">{
                return models.Event{}, models.ErrInternal
        }</span>
        <span class="cov0" title="0">return event, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package eventRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

const getEventsByCategoryQuery = `
        SELECT event.id, event.title, event.description, event.event_start, event.event_finish,
                event.location, event.capacity, event.created_at, event.user_id, event.category_id, event.lat, event.lon,
                COALESCE(array_agg(COALESCE(tag.name, '')), '{}') AS tags, media_url.url AS media_link
        FROM event
        LEFT JOIN event_tag ON event.id = event_tag.event_id
        LEFT JOIN tag ON tag.id = event_tag.tag_id
        LEFT JOIN media_url ON event.id = media_url.event_id
        WHERE event.category_id=$1         AND event.event_finish &gt;= NOW()
        GROUP BY event.id, media_url.url
        ORDER BY event.event_finish ASC
        LIMIT $2 OFFSET $3`

func (db *EventDB) GetEventsByCategory(ctx context.Context, categoryID int, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov0" title="0">{
        rows, err := db.pool.Query(ctx, getEventsByCategoryQuery, categoryID, paginationParams.Limit, paginationParams.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var events []models.Event
        for rows.Next() </span><span class="cov0" title="0">{
                var eventInfo EventInfo
                err = rows.Scan(
                        &amp;eventInfo.ID,
                        &amp;eventInfo.Title,
                        &amp;eventInfo.Description,
                        &amp;eventInfo.EventStart,
                        &amp;eventInfo.EventFinish,
                        &amp;eventInfo.Location,
                        &amp;eventInfo.Capacity,
                        &amp;eventInfo.CreatedAt,
                        &amp;eventInfo.UserID,
                        &amp;eventInfo.CategoryID,
                        &amp;eventInfo.Latitude,
                        &amp;eventInfo.Longitude,
                        &amp;eventInfo.Tags,
                        &amp;eventInfo.ImageURL,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>

                <span class="cov0" title="0">event, err := db.toDomainEvent(ctx, eventInfo)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">events = append(events, event)</span>
        }

        <span class="cov0" title="0">return events, nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package eventRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

const getEventsByIDsQuery = `
        SELECT event.id, event.title, event.description, event.event_start, event.event_finish, 
        event.location, event.capacity, event.created_at, event.user_id, event.category_id, event.lat, event.lon, 
        COALESCE(array_agg(COALESCE(tag.name, '')), '{}') AS tags, media_url.url AS media_link
        FROM event
        LEFT JOIN event_tag ON event.id = event_tag.event_id
        LEFT JOIN tag ON tag.id = event_tag.tag_id
        LEFT JOIN media_url ON event.id = media_url.event_id
        WHERE event.id=ANY($1)
        GROUP BY event.id, media_url.url`

func (db *EventDB) GetEventsByIDs(ctx context.Context, IDs []int) ([]models.Event, error) <span class="cov0" title="0">{
        rows, err := db.pool.Query(ctx, getEventsByIDsQuery, IDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var events []models.Event
        for rows.Next() </span><span class="cov0" title="0">{
                var eventInfo EventInfo
                err := rows.Scan(
                        &amp;eventInfo.ID,
                        &amp;eventInfo.Title,
                        &amp;eventInfo.Description,
                        &amp;eventInfo.EventStart,
                        &amp;eventInfo.EventFinish,
                        &amp;eventInfo.Location,
                        &amp;eventInfo.Capacity,
                        &amp;eventInfo.CreatedAt,
                        &amp;eventInfo.UserID,
                        &amp;eventInfo.CategoryID,
                        &amp;eventInfo.Latitude,
                        &amp;eventInfo.Longitude,
                        &amp;eventInfo.Tags,
                        &amp;eventInfo.ImageURL,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>

                <span class="cov0" title="0">event, err := db.toDomainEvent(ctx, eventInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, models.ErrInternal
                }</span>
                <span class="cov0" title="0">events = append(events, event)</span>
        }
        <span class="cov0" title="0">return events, nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package eventRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

const getEventsByUserQuery = `
        SELECT event.id, event.title, event.description, event.event_start, event.event_finish, 
                event.location, event.capacity, event.created_at, event.user_id, event.category_id, event.lat, event.lon, 
                COALESCE(array_agg(COALESCE(tag.name, '')), '{}') AS tags, media_url.url AS media_link
        FROM event
        LEFT JOIN event_tag ON event.id = event_tag.event_id
        LEFT JOIN tag ON tag.id = event_tag.tag_id
        LEFT JOIN media_url ON event.id = media_url.event_id
        WHERE event.user_id=$1 
        GROUP BY event.id, media_url.url
        ORDER BY event.event_finish ASC
        LIMIT $2 OFFSET $3`

func (db *EventDB) GetEventsByUser(ctx context.Context, userID int, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov0" title="0">{
        rows, err := db.pool.Query(ctx, getEventsByUserQuery, userID, paginationParams.Limit, paginationParams.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var events []models.Event
        for rows.Next() </span><span class="cov0" title="0">{
                var eventInfo EventInfo
                err = rows.Scan(
                        &amp;eventInfo.ID,
                        &amp;eventInfo.Title,
                        &amp;eventInfo.Description,
                        &amp;eventInfo.EventStart,
                        &amp;eventInfo.EventFinish,
                        &amp;eventInfo.Location,
                        &amp;eventInfo.Capacity,
                        &amp;eventInfo.CreatedAt,
                        &amp;eventInfo.UserID,
                        &amp;eventInfo.CategoryID,
                        &amp;eventInfo.Latitude,
                        &amp;eventInfo.Longitude,
                        &amp;eventInfo.Tags,
                        &amp;eventInfo.ImageURL,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>

                <span class="cov0" title="0">event, err := db.toDomainEvent(ctx, eventInfo)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">events = append(events, event)</span>
        }

        <span class="cov0" title="0">return events, nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package eventRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

const getFavoriteEventsQuery = `
        SELECT event.id, event.title, event.description, event.event_start, event.event_finish,
                event.location, event.capacity, event.created_at, event.user_id, event.category_id, event.lat, event.lon,
                COALESCE(array_agg(COALESCE(tag.name, '')), '{}') AS tags, media_url.url AS media_link
        FROM event
        JOIN FAVORITE_EVENT ON event.id = FAVORITE_EVENT.event_id
        LEFT JOIN event_tag ON event.id = event_tag.event_id
        LEFT JOIN tag ON tag.id = event_tag.tag_id
        LEFT JOIN media_url ON event.id = media_url.event_id
        WHERE FAVORITE_EVENT.user_id = $1 
        GROUP BY event.id, media_url.url
        ORDER BY event.event_finish ASC
        LIMIT $2 OFFSET $3`

func (db *EventDB) GetFavorites(ctx context.Context, userID int, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov0" title="0">{
        rows, err := db.pool.Query(ctx, getFavoriteEventsQuery, userID, paginationParams.Limit, paginationParams.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var events []models.Event
        for rows.Next() </span><span class="cov0" title="0">{
                var eventInfo EventInfo
                err = rows.Scan(
                        &amp;eventInfo.ID,
                        &amp;eventInfo.Title,
                        &amp;eventInfo.Description,
                        &amp;eventInfo.EventStart,
                        &amp;eventInfo.EventFinish,
                        &amp;eventInfo.Location,
                        &amp;eventInfo.Capacity,
                        &amp;eventInfo.CreatedAt,
                        &amp;eventInfo.UserID,
                        &amp;eventInfo.CategoryID,
                        &amp;eventInfo.Latitude,
                        &amp;eventInfo.Longitude,
                        &amp;eventInfo.Tags,
                        &amp;eventInfo.ImageURL,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>

                <span class="cov0" title="0">event, err := db.toDomainEvent(ctx, eventInfo)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">events = append(events, event)</span>
        }

        <span class="cov0" title="0">return events, nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package eventRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

const selectPastEventsQuery = `
        SELECT event.id, event.title, event.description, event.event_start, event.event_finish,
                event.location, event.capacity, event.created_at, event.user_id, event.category_id, event.lat, event.lon, 
                COALESCE(array_agg(DISTINCT COALESCE(tag.name, '')), '{}') AS tags, media_url.url AS media_link
        FROM event
        LEFT JOIN event_tag ON event.id = event_tag.event_id
        LEFT JOIN tag ON tag.id = event_tag.tag_id
        LEFT JOIN media_url ON event.id = media_url.event_id
        WHERE event.event_finish &lt; NOW()
        GROUP BY event.id, media_url.url
        ORDER BY event.event_start DESC
        LIMIT $1 OFFSET $2`

func (db *EventDB) GetPastEvents(ctx context.Context, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov0" title="0">{
        rows, err := db.pool.Query(ctx, selectPastEventsQuery, paginationParams.Limit, paginationParams.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        events := make([]models.Event, 0, paginationParams.Limit)
        for rows.Next() </span><span class="cov0" title="0">{
                var eventInfo EventInfo
                err = rows.Scan(
                        &amp;eventInfo.ID,
                        &amp;eventInfo.Title,
                        &amp;eventInfo.Description,
                        &amp;eventInfo.EventStart,
                        &amp;eventInfo.EventFinish,
                        &amp;eventInfo.Location,
                        &amp;eventInfo.Capacity,
                        &amp;eventInfo.CreatedAt,
                        &amp;eventInfo.UserID,
                        &amp;eventInfo.CategoryID,
                        &amp;eventInfo.Latitude,
                        &amp;eventInfo.Longitude,
                        &amp;eventInfo.Tags,
                        &amp;eventInfo.ImageURL,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>
                <span class="cov0" title="0">event, err := db.toDomainEvent(ctx, eventInfo)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">events = append(events, event)</span>
        }

        <span class="cov0" title="0">return events, nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package eventRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

const getSubscribersIDsQuery = `
        SELECT subscriber_id
        FROM SUBSCRIPTION
        WHERE follows_id = $1;
`

func (db EventDB) GetSubscribersIDs(ctx context.Context, ID int) ([]int, error) <span class="cov0" title="0">{
        rows, err := db.pool.Query(ctx, getSubscribersIDsQuery, ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var ids []int
        for rows.Next() </span><span class="cov0" title="0">{
                var id int
                err = rows.Scan(&amp;id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>
                <span class="cov0" title="0">ids = append(ids, id)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov0" title="0">return ids, nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package eventRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

const getSubscriptionEventsQuery = `
        SELECT event.id, event.title, event.description, event.event_start, event.event_finish, 
                event.location, event.capacity, event.created_at, event.user_id, event.category_id, event.lat, event.lon, 
                COALESCE(array_agg(COALESCE(tag.name, '')), '{}') AS tags, media_url.url AS media_link
        FROM event
        INNER JOIN SUBSCRIPTION ON event.user_id = SUBSCRIPTION.follows_id
        LEFT JOIN event_tag ON event.id = event_tag.event_id
        LEFT JOIN tag ON tag.id = event_tag.tag_id
        LEFT JOIN media_url ON event.id = media_url.event_id
        WHERE SUBSCRIPTION.subscriber_id=$1 
        GROUP BY event.id, media_url.url
        ORDER BY event.event_finish ASC
        LIMIT $2 OFFSET $3`

func (db *EventDB) GetSubscriptionEvents(ctx context.Context, userID int, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov0" title="0">{
        rows, err := db.pool.Query(ctx, getSubscriptionEventsQuery, userID, paginationParams.Limit, paginationParams.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var events []models.Event
        for rows.Next() </span><span class="cov0" title="0">{
                var eventInfo EventInfo
                err = rows.Scan(
                        &amp;eventInfo.ID,
                        &amp;eventInfo.Title,
                        &amp;eventInfo.Description,
                        &amp;eventInfo.EventStart,
                        &amp;eventInfo.EventFinish,
                        &amp;eventInfo.Location,
                        &amp;eventInfo.Capacity,
                        &amp;eventInfo.CreatedAt,
                        &amp;eventInfo.UserID,
                        &amp;eventInfo.CategoryID,
                        &amp;eventInfo.Latitude,
                        &amp;eventInfo.Longitude,
                        &amp;eventInfo.Tags,
                        &amp;eventInfo.ImageURL,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>

                <span class="cov0" title="0">event, err := db.toDomainEvent(ctx, eventInfo)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">events = append(events, event)</span>
        }

        <span class="cov0" title="0">return events, nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package eventRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

const selectUpcomingEventsQuery = `
        SELECT event.id, event.title, event.description, event.event_start, event.event_finish, 
                event.location, event.capacity, event.created_at, event.user_id, event.category_id, event.lat, event.lon, 
                COALESCE(array_agg(DISTINCT COALESCE(tag.name, '')), '{}') AS tags, media_url.url AS media_link
        FROM event
        LEFT JOIN event_tag ON event.id = event_tag.event_id
        LEFT JOIN tag ON tag.id = event_tag.tag_id
        LEFT JOIN media_url ON event.id = media_url.event_id
        WHERE event.event_finish &gt;= NOW()
        GROUP BY event.id, media_url.url
        ORDER BY event.event_start ASC
        LIMIT $1 OFFSET $2`

func (db *EventDB) GetUpcomingEvents(ctx context.Context, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov0" title="0">{
        rows, err := db.pool.Query(ctx, selectUpcomingEventsQuery, paginationParams.Limit, paginationParams.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        events := make([]models.Event, 0, paginationParams.Limit)
        for rows.Next() </span><span class="cov0" title="0">{
                var eventInfo EventInfo
                err = rows.Scan(
                        &amp;eventInfo.ID,
                        &amp;eventInfo.Title,
                        &amp;eventInfo.Description,
                        &amp;eventInfo.EventStart,
                        &amp;eventInfo.EventFinish,
                        &amp;eventInfo.Location,
                        &amp;eventInfo.Capacity,
                        &amp;eventInfo.CreatedAt,
                        &amp;eventInfo.UserID,
                        &amp;eventInfo.CategoryID,
                        &amp;eventInfo.Latitude,
                        &amp;eventInfo.Longitude,
                        &amp;eventInfo.Tags,
                        &amp;eventInfo.ImageURL,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>
                <span class="cov0" title="0">event, err := db.toDomainEvent(ctx, eventInfo)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">events = append(events, event)</span>
        }

        <span class="cov0" title="0">return events, nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package eventRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

const selectUserIDsByFavoriteEvent = `
        SELECT user_id FROM FAVORITE_EVENT 
        WHERE event_id=$1`

func (db *EventDB) GetUserIDsByFavoriteEvent(ctx context.Context, eventID int) ([]int, error) <span class="cov0" title="0">{
        rows, err := db.pool.Query(ctx, selectUserIDsByFavoriteEvent, eventID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var ids []int
        for rows.Next() </span><span class="cov0" title="0">{
                var temp int
                err = rows.Scan(
                        &amp;temp,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>

                <span class="cov0" title="0">ids = append(ids, temp)</span>
        }

        <span class="cov0" title="0">return ids, nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: events.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        pgx "github.com/jackc/pgx/v5"
        pgconn "github.com/jackc/pgx/v5/pgconn"
)

// MockPool is a mock of Pool interface.
type MockPool struct {
        ctrl     *gomock.Controller
        recorder *MockPoolMockRecorder
}

// MockPoolMockRecorder is the mock recorder for MockPool.
type MockPoolMockRecorder struct {
        mock *MockPool
}

// NewMockPool creates a new mock instance.
func NewMockPool(ctrl *gomock.Controller) *MockPool <span class="cov0" title="0">{
        mock := &amp;MockPool{ctrl: ctrl}
        mock.recorder = &amp;MockPoolMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPool) EXPECT() *MockPoolMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Begin mocks base method.
func (m *MockPool) Begin(ctx context.Context) (pgx.Tx, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Begin", ctx)
        ret0, _ := ret[0].(pgx.Tx)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Begin indicates an expected call of Begin.
func (mr *MockPoolMockRecorder) Begin(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockPool)(nil).Begin), ctx)
}</span>

// Exec mocks base method.
func (m *MockPool) Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, sql}
        for _, a := range arguments </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "Exec", varargs...)
        ret0, _ := ret[0].(pgconn.CommandTag)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Exec indicates an expected call of Exec.
func (mr *MockPoolMockRecorder) Exec(ctx, sql interface{}, arguments ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, sql}, arguments...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockPool)(nil).Exec), varargs...)
}</span>

// Query mocks base method.
func (m *MockPool) Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, sql}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "Query", varargs...)
        ret0, _ := ret[0].(pgx.Rows)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Query indicates an expected call of Query.
func (mr *MockPoolMockRecorder) Query(ctx, sql interface{}, args ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, sql}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockPool)(nil).Query), varargs...)
}</span>

// QueryRow mocks base method.
func (m *MockPool) QueryRow(ctx context.Context, sql string, args ...any) pgx.Row <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, sql}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "QueryRow", varargs...)
        ret0, _ := ret[0].(pgx.Row)
        return ret0</span>
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockPoolMockRecorder) QueryRow(ctx, sql interface{}, args ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, sql}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockPool)(nil).QueryRow), varargs...)
}</span>

// SendBatch mocks base method.
func (m *MockPool) SendBatch(ctx context.Context, b *pgx.Batch) pgx.BatchResults <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SendBatch", ctx, b)
        ret0, _ := ret[0].(pgx.BatchResults)
        return ret0
}</span>

// SendBatch indicates an expected call of SendBatch.
func (mr *MockPoolMockRecorder) SendBatch(ctx, b interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendBatch", reflect.TypeOf((*MockPool)(nil).SendBatch), ctx, b)
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: /home/ksu/go/pkg/mod/github.com/jackc/pgx/v5@v5.7.1/tx.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        pgx "github.com/jackc/pgx/v5"
        pgconn "github.com/jackc/pgx/v5/pgconn"
)

// MockTx is a mock of Tx interface.
type MockTx struct {
        ctrl     *gomock.Controller
        recorder *MockTxMockRecorder
}

// MockTxMockRecorder is the mock recorder for MockTx.
type MockTxMockRecorder struct {
        mock *MockTx
}

// NewMockTx creates a new mock instance.
func NewMockTx(ctrl *gomock.Controller) *MockTx <span class="cov0" title="0">{
        mock := &amp;MockTx{ctrl: ctrl}
        mock.recorder = &amp;MockTxMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTx) EXPECT() *MockTxMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Begin mocks base method.
func (m *MockTx) Begin(ctx context.Context) (pgx.Tx, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Begin", ctx)
        ret0, _ := ret[0].(pgx.Tx)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Begin indicates an expected call of Begin.
func (mr *MockTxMockRecorder) Begin(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockTx)(nil).Begin), ctx)
}</span>

// Commit mocks base method.
func (m *MockTx) Commit(ctx context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Commit", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Commit indicates an expected call of Commit.
func (mr *MockTxMockRecorder) Commit(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockTx)(nil).Commit), ctx)
}</span>

// Conn mocks base method.
func (m *MockTx) Conn() *pgx.Conn <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Conn")
        ret0, _ := ret[0].(*pgx.Conn)
        return ret0
}</span>

// Conn indicates an expected call of Conn.
func (mr *MockTxMockRecorder) Conn() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Conn", reflect.TypeOf((*MockTx)(nil).Conn))
}</span>

// CopyFrom mocks base method.
func (m *MockTx) CopyFrom(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CopyFrom", ctx, tableName, columnNames, rowSrc)
        ret0, _ := ret[0].(int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CopyFrom indicates an expected call of CopyFrom.
func (mr *MockTxMockRecorder) CopyFrom(ctx, tableName, columnNames, rowSrc interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyFrom", reflect.TypeOf((*MockTx)(nil).CopyFrom), ctx, tableName, columnNames, rowSrc)
}</span>

// Exec mocks base method.
func (m *MockTx) Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, sql}
        for _, a := range arguments </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "Exec", varargs...)
        ret0, _ := ret[0].(pgconn.CommandTag)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Exec indicates an expected call of Exec.
func (mr *MockTxMockRecorder) Exec(ctx, sql interface{}, arguments ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, sql}, arguments...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockTx)(nil).Exec), varargs...)
}</span>

// LargeObjects mocks base method.
func (m *MockTx) LargeObjects() pgx.LargeObjects <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "LargeObjects")
        ret0, _ := ret[0].(pgx.LargeObjects)
        return ret0
}</span>

// LargeObjects indicates an expected call of LargeObjects.
func (mr *MockTxMockRecorder) LargeObjects() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LargeObjects", reflect.TypeOf((*MockTx)(nil).LargeObjects))
}</span>

// Prepare mocks base method.
func (m *MockTx) Prepare(ctx context.Context, name, sql string) (*pgconn.StatementDescription, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Prepare", ctx, name, sql)
        ret0, _ := ret[0].(*pgconn.StatementDescription)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Prepare indicates an expected call of Prepare.
func (mr *MockTxMockRecorder) Prepare(ctx, name, sql interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prepare", reflect.TypeOf((*MockTx)(nil).Prepare), ctx, name, sql)
}</span>

// Query mocks base method.
func (m *MockTx) Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, sql}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "Query", varargs...)
        ret0, _ := ret[0].(pgx.Rows)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Query indicates an expected call of Query.
func (mr *MockTxMockRecorder) Query(ctx, sql interface{}, args ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, sql}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockTx)(nil).Query), varargs...)
}</span>

// QueryRow mocks base method.
func (m *MockTx) QueryRow(ctx context.Context, sql string, args ...any) pgx.Row <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, sql}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "QueryRow", varargs...)
        ret0, _ := ret[0].(pgx.Row)
        return ret0</span>
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockTxMockRecorder) QueryRow(ctx, sql interface{}, args ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, sql}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockTx)(nil).QueryRow), varargs...)
}</span>

// Rollback mocks base method.
func (m *MockTx) Rollback(ctx context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Rollback", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Rollback indicates an expected call of Rollback.
func (mr *MockTxMockRecorder) Rollback(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockTx)(nil).Rollback), ctx)
}</span>

// SendBatch mocks base method.
func (m *MockTx) SendBatch(ctx context.Context, b *pgx.Batch) pgx.BatchResults <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SendBatch", ctx, b)
        ret0, _ := ret[0].(pgx.BatchResults)
        return ret0
}</span>

// SendBatch indicates an expected call of SendBatch.
func (mr *MockTxMockRecorder) SendBatch(ctx, b interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendBatch", reflect.TypeOf((*MockTx)(nil).SendBatch), ctx, b)
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package eventRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

/*
const baseSearchQuery = `
SELECT event.id, event.title, event.description, event.event_start, event.event_finish,

        event.location, event.capacity, event.created_at, event.user_id, event.category_id,

COALESCE(array_agg(DISTINCT tag.name) FILTER (WHERE tag.name IS NOT NULL), ARRAY[]::TEXT[]) AS tags,

        COALESCE(media_url.url, '') AS media_link

FROM event
LEFT JOIN event_tag ON event.id = event_tag.event_id
LEFT JOIN tag ON tag.id = event_tag.tag_id
LEFT JOIN media_url ON event.id = media_url.event_id
WHERE

        ($1::TEXT IS NULL OR event.title ILIKE '%' || $1 || '%' OR event.description ILIKE '%' || $1 || '%')
        AND ($2::INT IS NULL OR event.category_id = $2)
        AND ($3::TIMESTAMP IS NULL OR event.event_start &gt;= $3)
        AND ($4::TIMESTAMP IS NULL OR event.event_finish &lt;= $4)

GROUP BY event.id, media_url.url
HAVING (

        $5::TEXT[] IS NULL
        OR array_length($5::TEXT[], 1) = 0
        OR array_length(array_agg(DISTINCT LOWER(tag.name)), 1) = 0
        OR array_agg(DISTINCT LOWER(tag.name)) @&gt; $5::TEXT[]

)
ORDER BY event.event_finish ASC
LIMIT $6 OFFSET $7;
`
*/
const baseSearchQuery = `
    SELECT event.id, event.title, event.description, event.event_start, event.event_finish, 
           event.location, event.capacity, event.created_at, event.user_id, event.category_id, event.lat, event.lon,
           COALESCE(array_agg(DISTINCT tag.name) FILTER (WHERE tag.name IS NOT NULL), ARRAY[]::TEXT[]) AS tags,
           COALESCE(media_url.url, '') AS media_link        
    FROM event
    LEFT JOIN event_tag ON event.id = event_tag.event_id
    LEFT JOIN tag ON tag.id = event_tag.tag_id
    LEFT JOIN media_url ON event.id = media_url.event_id
    WHERE
        ($1::TEXT IS NULL OR event.title ILIKE '%' || $1 || '%' OR event.description ILIKE '%' || $1 || '%')
        AND ($2::INT IS NULL OR event.category_id = $2)
        AND ($3::TIMESTAMP IS NULL OR event.event_start &gt;= $3)
        AND ($4::TIMESTAMP IS NULL OR event.event_finish &lt;= $4)
        AND ($8::DOUBLE PRECISION IS NULL OR event.lat &gt;= $8) -- Минимальная широта
        AND ($9::DOUBLE PRECISION IS NULL OR event.lat &lt;= $9) -- Максимальная широта
        AND ($10::DOUBLE PRECISION IS NULL OR event.lon &gt;= $10) -- Минимальная долгота
        AND ($11::DOUBLE PRECISION IS NULL OR event.lon &lt;= $11) -- Максимальная долгота
    GROUP BY event.id, media_url.url
    HAVING (
        $5::TEXT[] IS NULL 
        OR array_length($5::TEXT[], 1) = 0 
        OR array_length(array_agg(DISTINCT LOWER(tag.name)), 1) = 0 
        OR array_agg(DISTINCT LOWER(tag.name)) @&gt; $5::TEXT[]
    )
    ORDER BY event.event_finish ASC
    LIMIT $6 OFFSET $7;
`

func (db *EventDB) SearchEvents(ctx context.Context, params models.SearchParams, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov0" title="0">{
        args := []interface{}{
                nilIfEmpty(params.Query),
                nilIfZero(params.Category),
                nilIfEmpty(params.EventStart),
                nilIfEmpty(params.EventEnd),
                tagsToArray(params.Tags),
                paginationParams.Limit,
                paginationParams.Offset,
                nilIfFloatZero(params.LatitudeMin),
                nilIfFloatZero(params.LatitudeMax),
                nilIfFloatZero(params.LongitudeMin),
                nilIfFloatZero(params.LongitudeMax),
        }

        rows, err := db.pool.Query(ctx, baseSearchQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        events := make([]models.Event, 0, paginationParams.Limit)
        for rows.Next() </span><span class="cov0" title="0">{
                var eventInfo EventInfo
                err = rows.Scan(
                        &amp;eventInfo.ID,
                        &amp;eventInfo.Title,
                        &amp;eventInfo.Description,
                        &amp;eventInfo.EventStart,
                        &amp;eventInfo.EventFinish,
                        &amp;eventInfo.Location,
                        &amp;eventInfo.Capacity,
                        &amp;eventInfo.CreatedAt,
                        &amp;eventInfo.UserID,
                        &amp;eventInfo.CategoryID,
                        &amp;eventInfo.Latitude,
                        &amp;eventInfo.Longitude,
                        &amp;eventInfo.Tags,
                        &amp;eventInfo.ImageURL,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>

                <span class="cov0" title="0">event, err := db.toDomainEvent(ctx, eventInfo)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">events = append(events, event)</span>
        }

        <span class="cov0" title="0">return events, nil</span>
}

func nilIfFloatZero(value float64) interface{} <span class="cov0" title="0">{
        if value == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return value</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package eventRepository

import (
        "context"
        "fmt"
        "time"

        "kudago/internal/models"
)

const updateEventQuery = `
        UPDATE event
        SET 
                title = COALESCE($2, title), 
                description = COALESCE($3, description), 
                event_start = COALESCE($4, event_start), 
                event_finish = COALESCE($5, event_finish), 
                location = COALESCE($6, location), 
                capacity = COALESCE($7, capacity), 
                category_id = COALESCE($8, category_id), 
                updated_at = $9,
                lat = COALESCE($10, lat),
                lon = COALESCE($11, lon)
        WHERE id = $1
        RETURNING id, title, description, event_start, event_finish, location, capacity, category_id, user_id, lat, lon
`

func (db *EventDB) UpdateEvent(ctx context.Context, updatedEvent models.Event) (models.Event, error) <span class="cov0" title="0">{
        tx, err := db.pool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return models.Event{}, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback(ctx)

        var eventInfo EventInfo
        err = tx.QueryRow(ctx, updateEventQuery,
                updatedEvent.ID,
                nilIfEmpty(updatedEvent.Title),
                nilIfEmpty(updatedEvent.Description),
                nilIfEmpty(updatedEvent.EventStart),
                nilIfEmpty(updatedEvent.EventEnd),
                nilIfEmpty(updatedEvent.Location),
                nilIfZero(updatedEvent.Capacity),
                nilIfZero(updatedEvent.CategoryID),
                time.Now(),
                nilIfZeroFloat(updatedEvent.Latitude),
                nilIfZeroFloat(updatedEvent.Longitude),
        ).Scan(
                &amp;eventInfo.ID,
                &amp;eventInfo.Title,
                &amp;eventInfo.Description,
                &amp;eventInfo.EventStart,
                &amp;eventInfo.EventFinish,
                &amp;eventInfo.Location,
                &amp;eventInfo.Capacity,
                &amp;eventInfo.CategoryID,
                &amp;eventInfo.UserID,
                &amp;eventInfo.Latitude,
                &amp;eventInfo.Longitude,
        )
        if err != nil </span><span class="cov0" title="0">{
                return models.Event{}, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov0" title="0">if len(updatedEvent.Tag) &gt; 0 </span><span class="cov0" title="0">{
                err = db.updateTagsForEvent(ctx, tx, updatedEvent.ID, updatedEvent.Tag)
                if err != nil </span><span class="cov0" title="0">{
                        return models.Event{}, fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>
        }

        <span class="cov0" title="0">if updatedEvent.ImageURL != "" </span><span class="cov0" title="0">{
                err = db.updateMediaURL(ctx, tx, updatedEvent.ID, updatedEvent.ImageURL)
                if err != nil </span><span class="cov0" title="0">{
                        return models.Event{}, fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>
        }

        <span class="cov0" title="0">err = tx.Commit(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return models.Event{}, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov0" title="0">event, err := db.toDomainEvent(ctx, eventInfo)
        if err != nil </span><span class="cov0" title="0">{
                return models.Event{}, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov0" title="0">event.Tag = updatedEvent.Tag
        event.ImageURL = updatedEvent.ImageURL

        return event, nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package service

//go:generate mockgen -source ./event.go -destination=./mocks/events.go -package=mocks

import (
        "context"
        "fmt"
        "strings"

        "kudago/internal/models"
)

type EventService struct {
        EventDB EventDB
}

type EventDB interface {
        GetUpcomingEvents(ctx context.Context, paginationParams models.PaginationParams) ([]models.Event, error)
        GetPastEvents(ctx context.Context, paginationParams models.PaginationParams) ([]models.Event, error)
        GetCategories(ctx context.Context) ([]models.Category, error)
        GetEventsByCategory(ctx context.Context, categoryID int, paginationParams models.PaginationParams) ([]models.Event, error)
        GetEventsByUser(ctx context.Context, userID int, paginationParams models.PaginationParams) ([]models.Event, error)
        GetEventByID(ctx context.Context, ID int) (models.Event, error)
        CreateEvent(ctx context.Context, event models.Event) (models.Event, error)
        DeleteEvent(ctx context.Context, ID int) error
        UpdateEvent(ctx context.Context, event models.Event) (models.Event, error)
        SearchEvents(ctx context.Context, params models.SearchParams, paginationParams models.PaginationParams) ([]models.Event, error)
        AddEventToFavorites(ctx context.Context, newFavorite models.FavoriteEvent) error
        DeleteEventFromFavorites(ctx context.Context, favorite models.FavoriteEvent) error
}

func NewService(eventDB EventDB) EventService <span class="cov8" title="1">{
        return EventService{EventDB: eventDB}
}</span>

func (s *EventService) AddEvent(ctx context.Context, event models.Event) (models.Event, error) <span class="cov0" title="0">{
        return s.EventDB.CreateEvent(ctx, event)
}</span>

func (s *EventService) DeleteEvent(ctx context.Context, ID, AuthorID int) error <span class="cov8" title="1">{
        dbEvent, err := s.EventDB.GetEventByID(ctx, ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if dbEvent.AuthorID != AuthorID </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: %w", models.LevelService, models.ErrAccessDenied)
        }</span>

        <span class="cov8" title="1">return s.EventDB.DeleteEvent(ctx, ID)</span>
}

func (s *EventService) GetEventByID(ctx context.Context, ID int) (models.Event, error) <span class="cov0" title="0">{
        return s.EventDB.GetEventByID(ctx, ID)
}</span>

func (s *EventService) SearchEvents(ctx context.Context, params models.SearchParams, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov8" title="1">{
        for i, tag := range params.Tags </span><span class="cov8" title="1">{
                params.Tags[i] = strings.ToLower(tag)
        }</span>
        <span class="cov8" title="1">return s.EventDB.SearchEvents(ctx, params, paginationParams)</span>
}

func (s *EventService) UpdateEvent(ctx context.Context, event models.Event) (models.Event, error) <span class="cov0" title="0">{
        dbEvent, err := s.EventDB.GetEventByID(ctx, event.ID)
        if err != nil </span><span class="cov0" title="0">{
                return models.Event{}, err
        }</span>

        <span class="cov0" title="0">if dbEvent.AuthorID != event.AuthorID </span><span class="cov0" title="0">{
                return models.Event{}, fmt.Errorf("%s: %w", models.LevelService, models.ErrAccessDenied)
        }</span>

        <span class="cov0" title="0">updatedEvent, err := s.EventDB.UpdateEvent(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return models.Event{}, err
        }</span>

        <span class="cov0" title="0">return updatedEvent, nil</span>
}

func (s *EventService) AddEventToFavorites(ctx context.Context, newFavorite models.FavoriteEvent) error <span class="cov0" title="0">{
        return s.EventDB.AddEventToFavorites(ctx, newFavorite)
}</span>

func (s *EventService) DeleteEventFromFavorites(ctx context.Context, favorite models.FavoriteEvent) error <span class="cov0" title="0">{
        return s.EventDB.DeleteEventFromFavorites(ctx, favorite)
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./event.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        models "kudago/internal/models"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockEventDB is a mock of EventDB interface.
type MockEventDB struct {
        ctrl     *gomock.Controller
        recorder *MockEventDBMockRecorder
}

// MockEventDBMockRecorder is the mock recorder for MockEventDB.
type MockEventDBMockRecorder struct {
        mock *MockEventDB
}

// NewMockEventDB creates a new mock instance.
func NewMockEventDB(ctrl *gomock.Controller) *MockEventDB <span class="cov8" title="1">{
        mock := &amp;MockEventDB{ctrl: ctrl}
        mock.recorder = &amp;MockEventDBMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventDB) EXPECT() *MockEventDBMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AddEventToFavorites mocks base method.
func (m *MockEventDB) AddEventToFavorites(ctx context.Context, newFavorite models.FavoriteEvent) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddEventToFavorites", ctx, newFavorite)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AddEventToFavorites indicates an expected call of AddEventToFavorites.
func (mr *MockEventDBMockRecorder) AddEventToFavorites(ctx, newFavorite interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddEventToFavorites", reflect.TypeOf((*MockEventDB)(nil).AddEventToFavorites), ctx, newFavorite)
}</span>

// CreateEvent mocks base method.
func (m *MockEventDB) CreateEvent(ctx context.Context, event models.Event) (models.Event, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateEvent", ctx, event)
        ret0, _ := ret[0].(models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateEvent indicates an expected call of CreateEvent.
func (mr *MockEventDBMockRecorder) CreateEvent(ctx, event interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateEvent", reflect.TypeOf((*MockEventDB)(nil).CreateEvent), ctx, event)
}</span>

// DeleteEvent mocks base method.
func (m *MockEventDB) DeleteEvent(ctx context.Context, ID int) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteEvent", ctx, ID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteEvent indicates an expected call of DeleteEvent.
func (mr *MockEventDBMockRecorder) DeleteEvent(ctx, ID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteEvent", reflect.TypeOf((*MockEventDB)(nil).DeleteEvent), ctx, ID)
}</span>

// DeleteEventFromFavorites mocks base method.
func (m *MockEventDB) DeleteEventFromFavorites(ctx context.Context, favorite models.FavoriteEvent) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteEventFromFavorites", ctx, favorite)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteEventFromFavorites indicates an expected call of DeleteEventFromFavorites.
func (mr *MockEventDBMockRecorder) DeleteEventFromFavorites(ctx, favorite interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteEventFromFavorites", reflect.TypeOf((*MockEventDB)(nil).DeleteEventFromFavorites), ctx, favorite)
}</span>

// GetCategories mocks base method.
func (m *MockEventDB) GetCategories(ctx context.Context) ([]models.Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCategories", ctx)
        ret0, _ := ret[0].([]models.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCategories indicates an expected call of GetCategories.
func (mr *MockEventDBMockRecorder) GetCategories(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCategories", reflect.TypeOf((*MockEventDB)(nil).GetCategories), ctx)
}</span>

// GetEventByID mocks base method.
func (m *MockEventDB) GetEventByID(ctx context.Context, ID int) (models.Event, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetEventByID", ctx, ID)
        ret0, _ := ret[0].(models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetEventByID indicates an expected call of GetEventByID.
func (mr *MockEventDBMockRecorder) GetEventByID(ctx, ID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEventByID", reflect.TypeOf((*MockEventDB)(nil).GetEventByID), ctx, ID)
}</span>

// GetEventsByCategory mocks base method.
func (m *MockEventDB) GetEventsByCategory(ctx context.Context, categoryID int, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetEventsByCategory", ctx, categoryID, paginationParams)
        ret0, _ := ret[0].([]models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetEventsByCategory indicates an expected call of GetEventsByCategory.
func (mr *MockEventDBMockRecorder) GetEventsByCategory(ctx, categoryID, paginationParams interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEventsByCategory", reflect.TypeOf((*MockEventDB)(nil).GetEventsByCategory), ctx, categoryID, paginationParams)
}</span>

// GetEventsByUser mocks base method.
func (m *MockEventDB) GetEventsByUser(ctx context.Context, userID int, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetEventsByUser", ctx, userID, paginationParams)
        ret0, _ := ret[0].([]models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetEventsByUser indicates an expected call of GetEventsByUser.
func (mr *MockEventDBMockRecorder) GetEventsByUser(ctx, userID, paginationParams interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEventsByUser", reflect.TypeOf((*MockEventDB)(nil).GetEventsByUser), ctx, userID, paginationParams)
}</span>

// GetPastEvents mocks base method.
func (m *MockEventDB) GetPastEvents(ctx context.Context, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetPastEvents", ctx, paginationParams)
        ret0, _ := ret[0].([]models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetPastEvents indicates an expected call of GetPastEvents.
func (mr *MockEventDBMockRecorder) GetPastEvents(ctx, paginationParams interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPastEvents", reflect.TypeOf((*MockEventDB)(nil).GetPastEvents), ctx, paginationParams)
}</span>

// GetUpcomingEvents mocks base method.
func (m *MockEventDB) GetUpcomingEvents(ctx context.Context, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUpcomingEvents", ctx, paginationParams)
        ret0, _ := ret[0].([]models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUpcomingEvents indicates an expected call of GetUpcomingEvents.
func (mr *MockEventDBMockRecorder) GetUpcomingEvents(ctx, paginationParams interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUpcomingEvents", reflect.TypeOf((*MockEventDB)(nil).GetUpcomingEvents), ctx, paginationParams)
}</span>

// SearchEvents mocks base method.
func (m *MockEventDB) SearchEvents(ctx context.Context, params models.SearchParams, paginationParams models.PaginationParams) ([]models.Event, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SearchEvents", ctx, params, paginationParams)
        ret0, _ := ret[0].([]models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SearchEvents indicates an expected call of SearchEvents.
func (mr *MockEventDBMockRecorder) SearchEvents(ctx, params, paginationParams interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchEvents", reflect.TypeOf((*MockEventDB)(nil).SearchEvents), ctx, params, paginationParams)
}</span>

// UpdateEvent mocks base method.
func (m *MockEventDB) UpdateEvent(ctx context.Context, event models.Event) (models.Event, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateEvent", ctx, event)
        ret0, _ := ret[0].(models.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateEvent indicates an expected call of UpdateEvent.
func (mr *MockEventDBMockRecorder) UpdateEvent(ctx, event interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateEvent", reflect.TypeOf((*MockEventDB)(nil).UpdateEvent), ctx, event)
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">//go:generate mockgen -source=../../auth/api/auth_grpc.pb.go -destination=mocks/auth.go -package=mocks
//go:generate easyjson auth.go

package handlers

import (
        "context"
        "net/http"
        "regexp"
        "time"

        auth "kudago/internal/auth/api"
        pb "kudago/internal/auth/api"
        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"
        pbImage "kudago/internal/image/api"
        "kudago/internal/logger"
        "kudago/internal/models"

        "github.com/asaskevich/govalidator"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

type AuthHandlers struct {
        AuthService  pb.AuthServiceClient
        ImageService pbImage.ImageServiceClient
        logger       *logger.Logger
}

var validPasswordRegex = regexp.MustCompile(`^[a-zA-Z0-9+\-*/.;=\]\[\}\{\?]+$`)

func init() <span class="cov8" title="1">{
        govalidator.TagMap["password"] = govalidator.Validator(func(str string) bool </span><span class="cov8" title="1">{
                return validPasswordRegex.MatchString(str)
        }</span>)
}

func NewHandlers(authServiceAddr string, imageServiceAddr string, logger *logger.Logger) (*AuthHandlers, error) <span class="cov0" title="0">{
        authConn, err := grpc.NewClient(authServiceAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">imageConn, err := grpc.NewClient(imageServiceAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;AuthHandlers{
                AuthService:  auth.NewAuthServiceClient(authConn),
                ImageService: pbImage.NewImageServiceClient(imageConn),
                logger:       logger,
        }, nil</span>
}

//easyjson:json
type AuthResponse struct {
        User UserResponse `json:"user"`
}

//easyjson:json
type UserResponse struct {
        ID       int    `json:"id"`
        Username string `json:"username"`
        Email    string `json:"email"`
        ImageURL string `json:"image"`
}

//easyjson:json
type LoginRequest struct {
        Username string `json:"username" valid:"required,alphanum,length(3|50)"`
        Password string `json:"password" valid:"password,required,length(3|50)"`
}

//easyjson:json
type RegisterRequest struct {
        Username string `json:"username" valid:"required,alphanum,length(3|50)"`
        Email    string `json:"email" valid:"email,required"`
        Password string `json:"password" valid:"password,required,length(3|50)"`
}

func userToUserResponse(user *pb.User) AuthResponse <span class="cov8" title="1">{
        resp := AuthResponse{
                User: UserResponse{
                        ID:       int(user.ID),
                        Username: user.Username,
                        Email:    user.Email,
                        ImageURL: user.AvatarUrl,
                },
        }
        return resp
}</span>

func (h *AuthHandlers) setSessionCookie(w http.ResponseWriter, r *http.Request, ID int) error <span class="cov8" title="1">{
        req := &amp;pb.CreateSessionRequest{ID: int32(ID)}

        session, err := h.AuthService.CreateSession(r.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                return models.ErrInternal
        }</span>

        <span class="cov8" title="1">expires, err := time.Parse(time.RFC3339, session.Expires)
        if err != nil </span><span class="cov0" title="0">{
                return models.ErrInternal
        }</span>

        <span class="cov8" title="1">http.SetCookie(w, &amp;http.Cookie{
                Name:     models.SessionToken,
                Value:    session.Token,
                Expires:  expires,
                HttpOnly: true,
        })
        return nil</span>
}

func (h *AuthHandlers) deleteImage(ctx context.Context, url string) <span class="cov0" title="0">{
        if url != "" </span><span class="cov0" title="0">{
                req := &amp;pbImage.DeleteRequest{
                        FileUrl: url,
                }
                h.ImageService.DeleteImage(ctx, req)
        }</span>
}

func (h *AuthHandlers) uploadImage(ctx context.Context, media *pbImage.UploadRequest, w http.ResponseWriter) (string, error) <span class="cov0" title="0">{
        if media != nil </span><span class="cov0" title="0">{
                url, err := h.ImageService.UploadImage(ctx, media)
                if err != nil </span><span class="cov0" title="0">{
                        switch err </span>{
                        case models.ErrInvalidImage:<span class="cov0" title="0">
                                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidImage)</span>
                        case models.ErrInvalidImageFormat:<span class="cov0" title="0">
                                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidImageFormat)</span>
                        default:<span class="cov0" title="0">
                                h.logger.Error(ctx, "upload image", err)
                                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)</span>
                        }
                        <span class="cov0" title="0">return "", err</span>
                }
                <span class="cov0" title="0">return url.FileUrl, nil</span>
        }
        <span class="cov0" title="0">return "", nil</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package handlers

import (
        json "encoding/json"
        easyjson "github.com/mailru/easyjson"
        jlexer "github.com/mailru/easyjson/jlexer"
        jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
        _ *json.RawMessage
        _ *jlexer.Lexer
        _ *jwriter.Writer
        _ easyjson.Marshaler
)

func easyjson4a0f95aaDecodeKudagoInternalGatewayAuth(in *jlexer.Lexer, out *UserResponse) <span class="cov8" title="1">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov8" title="1">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov8" title="1">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov8" title="1">switch key </span>{
                case "id":<span class="cov8" title="1">
                        out.ID = int(in.Int())</span>
                case "username":<span class="cov8" title="1">
                        out.Username = string(in.String())</span>
                case "email":<span class="cov8" title="1">
                        out.Email = string(in.String())</span>
                case "image":<span class="cov8" title="1">
                        out.ImageURL = string(in.String())</span>
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov8" title="1">in.WantComma()</span>
        }
        <span class="cov8" title="1">in.Delim('}')
        if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjson4a0f95aaEncodeKudagoInternalGatewayAuth(out *jwriter.Writer, in UserResponse) <span class="cov8" title="1">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov8" title="1">{
                const prefix string = ",\"id\":"
                out.RawString(prefix[1:])
                out.Int(int(in.ID))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"username\":"
                out.RawString(prefix)
                out.String(string(in.Username))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"email\":"
                out.RawString(prefix)
                out.String(string(in.Email))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"image\":"
                out.RawString(prefix)
                out.String(string(in.ImageURL))
        }</span>
        <span class="cov8" title="1">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v UserResponse) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjson4a0f95aaEncodeKudagoInternalGatewayAuth(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v UserResponse) MarshalEasyJSON(w *jwriter.Writer) <span class="cov8" title="1">{
        easyjson4a0f95aaEncodeKudagoInternalGatewayAuth(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *UserResponse) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        r := jlexer.Lexer{Data: data}
        easyjson4a0f95aaDecodeKudagoInternalGatewayAuth(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *UserResponse) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov8" title="1">{
        easyjson4a0f95aaDecodeKudagoInternalGatewayAuth(l, v)
}</span>
func easyjson4a0f95aaDecodeKudagoInternalGatewayAuth1(in *jlexer.Lexer, out *RegisterRequest) <span class="cov0" title="0">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov0" title="0">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov0" title="0">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov0" title="0">switch key </span>{
                case "username":<span class="cov0" title="0">
                        out.Username = string(in.String())</span>
                case "email":<span class="cov0" title="0">
                        out.Email = string(in.String())</span>
                case "password":<span class="cov0" title="0">
                        out.Password = string(in.String())</span>
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov0" title="0">in.WantComma()</span>
        }
        <span class="cov0" title="0">in.Delim('}')
        if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjson4a0f95aaEncodeKudagoInternalGatewayAuth1(out *jwriter.Writer, in RegisterRequest) <span class="cov0" title="0">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov0" title="0">{
                const prefix string = ",\"username\":"
                out.RawString(prefix[1:])
                out.String(string(in.Username))
        }</span>
        <span class="cov0" title="0">{
                const prefix string = ",\"email\":"
                out.RawString(prefix)
                out.String(string(in.Email))
        }</span>
        <span class="cov0" title="0">{
                const prefix string = ",\"password\":"
                out.RawString(prefix)
                out.String(string(in.Password))
        }</span>
        <span class="cov0" title="0">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v RegisterRequest) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjson4a0f95aaEncodeKudagoInternalGatewayAuth1(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v RegisterRequest) MarshalEasyJSON(w *jwriter.Writer) <span class="cov0" title="0">{
        easyjson4a0f95aaEncodeKudagoInternalGatewayAuth1(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *RegisterRequest) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        r := jlexer.Lexer{Data: data}
        easyjson4a0f95aaDecodeKudagoInternalGatewayAuth1(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *RegisterRequest) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjson4a0f95aaDecodeKudagoInternalGatewayAuth1(l, v)
}</span>
func easyjson4a0f95aaDecodeKudagoInternalGatewayAuth2(in *jlexer.Lexer, out *LoginRequest) <span class="cov8" title="1">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov8" title="1">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov8" title="1">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov8" title="1">switch key </span>{
                case "username":<span class="cov8" title="1">
                        out.Username = string(in.String())</span>
                case "password":<span class="cov8" title="1">
                        out.Password = string(in.String())</span>
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov8" title="1">in.WantComma()</span>
        }
        <span class="cov8" title="1">in.Delim('}')
        if isTopLevel </span><span class="cov8" title="1">{
                in.Consumed()
        }</span>
}
func easyjson4a0f95aaEncodeKudagoInternalGatewayAuth2(out *jwriter.Writer, in LoginRequest) <span class="cov0" title="0">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov0" title="0">{
                const prefix string = ",\"username\":"
                out.RawString(prefix[1:])
                out.String(string(in.Username))
        }</span>
        <span class="cov0" title="0">{
                const prefix string = ",\"password\":"
                out.RawString(prefix)
                out.String(string(in.Password))
        }</span>
        <span class="cov0" title="0">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v LoginRequest) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjson4a0f95aaEncodeKudagoInternalGatewayAuth2(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v LoginRequest) MarshalEasyJSON(w *jwriter.Writer) <span class="cov0" title="0">{
        easyjson4a0f95aaEncodeKudagoInternalGatewayAuth2(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *LoginRequest) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        r := jlexer.Lexer{Data: data}
        easyjson4a0f95aaDecodeKudagoInternalGatewayAuth2(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *LoginRequest) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjson4a0f95aaDecodeKudagoInternalGatewayAuth2(l, v)
}</span>
func easyjson4a0f95aaDecodeKudagoInternalGatewayAuth3(in *jlexer.Lexer, out *AuthResponse) <span class="cov8" title="1">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov8" title="1">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov8" title="1">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov8" title="1">switch key </span>{
                case "user":<span class="cov8" title="1">
                        (out.User).UnmarshalEasyJSON(in)</span>
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov8" title="1">in.WantComma()</span>
        }
        <span class="cov8" title="1">in.Delim('}')
        if isTopLevel </span><span class="cov8" title="1">{
                in.Consumed()
        }</span>
}
func easyjson4a0f95aaEncodeKudagoInternalGatewayAuth3(out *jwriter.Writer, in AuthResponse) <span class="cov8" title="1">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov8" title="1">{
                const prefix string = ",\"user\":"
                out.RawString(prefix[1:])
                (in.User).MarshalEasyJSON(out)
        }</span>
        <span class="cov8" title="1">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v AuthResponse) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjson4a0f95aaEncodeKudagoInternalGatewayAuth3(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v AuthResponse) MarshalEasyJSON(w *jwriter.Writer) <span class="cov8" title="1">{
        easyjson4a0f95aaEncodeKudagoInternalGatewayAuth3(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *AuthResponse) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        r := jlexer.Lexer{Data: data}
        easyjson4a0f95aaDecodeKudagoInternalGatewayAuth3(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *AuthResponse) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjson4a0f95aaDecodeKudagoInternalGatewayAuth3(l, v)
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package handlers

import (
        "net/http"

        pb "kudago/internal/auth/api"
        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"

        grpcCodes "google.golang.org/grpc/codes"
        grpcStatus "google.golang.org/grpc/status"
)

func (h *AuthHandlers) CheckSession(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        session, ok := utils.GetSessionFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                utils.WriteResponse(w, http.StatusOK, httpErrors.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">getUserRequest := &amp;pb.GetUserRequest{
                ID: int32(session.UserID),
        }

        user, err := h.AuthService.GetUser(r.Context(), getUserRequest)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error(r.Context(), "check session", err)
                st, ok := grpcStatus.FromError(err)
                if ok </span><span class="cov8" title="1">{
                        switch st.Code() </span>{
                        case grpcCodes.NotFound:<span class="cov8" title="1">
                                utils.WriteResponse(w, http.StatusForbidden, httpErrors.ErrUserNotFound)
                                return</span>
                        }
                }
                <span class="cov0" title="0">h.logger.Error(r.Context(), "check session", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return</span>
        }

        <span class="cov8" title="1">resp := userToUserResponse(user)

        utils.WriteResponse(w, http.StatusOK, resp)
        return</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package handlers

import (
        "io"
        "net/http"

        pb "kudago/internal/auth/api"
        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"

        "github.com/asaskevich/govalidator"
        grpcCodes "google.golang.org/grpc/codes"
        grpcStatus "google.golang.org/grpc/status"
)

func (h *AuthHandlers) Login(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _, ok := utils.GetSessionFromContext(r.Context())
        if ok </span><span class="cov8" title="1">{
                utils.WriteResponse(w, http.StatusForbidden, httpErrors.ErrUserAlreadyLoggedIn)
                return
        }</span>

        <span class="cov8" title="1">body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidData)
                return
        }</span>
        <span class="cov8" title="1">defer r.Body.Close()

        var req LoginRequest
        err = req.UnmarshalJSON([]byte(body))
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidData)
                return
        }</span>

        <span class="cov8" title="1">_, err = govalidator.ValidateStruct(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                utils.ProcessValidationErrors(w, err)
                return
        }</span>

        <span class="cov8" title="1">creds := &amp;pb.LoginRequest{
                Username: req.Username,
                Password: req.Password,
        }

        user, err := h.AuthService.Login(r.Context(), creds)
        if err != nil </span><span class="cov8" title="1">{
                st, ok := grpcStatus.FromError(err)
                if ok </span><span class="cov8" title="1">{
                        switch st.Code() </span>{
                        case grpcCodes.NotFound:<span class="cov8" title="1">
                                utils.WriteResponse(w, http.StatusForbidden, httpErrors.ErrWrongCredentials)
                                return</span>
                        }
                }
                <span class="cov0" title="0">h.logger.Error(r.Context(), "login", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return</span>
        }

        <span class="cov8" title="1">err = h.setSessionCookie(w, r, int(user.ID))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(r.Context(), "set cookie", err)

                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return
        }</span>

        <span class="cov8" title="1">resp := userToUserResponse(user)
        utils.WriteResponse(w, http.StatusOK, resp)
        return</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package handlers

import (
        "net/http"

        pb "kudago/internal/auth/api"
        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"
        "kudago/internal/models"
)

func (h *AuthHandlers) Logout(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        session, ok := utils.GetSessionFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                utils.WriteResponse(w, http.StatusForbidden, httpErrors.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">req := &amp;pb.LogoutRequest{
                Token: session.Token,
        }

        _, err := h.AuthService.Logout(r.Context(), req)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error(r.Context(), "logout", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return
        }</span>

        <span class="cov8" title="1">http.SetCookie(w, &amp;http.Cookie{
                Name:   models.SessionToken,
                MaxAge: -1, // Устанавливаем истекшее время, чтобы удалить cookie
        })

        w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ../../auth/api/auth_grpc.pb.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        auth "kudago/internal/auth/api"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        grpc "google.golang.org/grpc"
)

// MockAuthServiceClient is a mock of AuthServiceClient interface.
type MockAuthServiceClient struct {
        ctrl     *gomock.Controller
        recorder *MockAuthServiceClientMockRecorder
}

// MockAuthServiceClientMockRecorder is the mock recorder for MockAuthServiceClient.
type MockAuthServiceClientMockRecorder struct {
        mock *MockAuthServiceClient
}

// NewMockAuthServiceClient creates a new mock instance.
func NewMockAuthServiceClient(ctrl *gomock.Controller) *MockAuthServiceClient <span class="cov8" title="1">{
        mock := &amp;MockAuthServiceClient{ctrl: ctrl}
        mock.recorder = &amp;MockAuthServiceClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthServiceClient) EXPECT() *MockAuthServiceClientMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CheckSession mocks base method.
func (m *MockAuthServiceClient) CheckSession(ctx context.Context, in *auth.CheckSessionRequest, opts ...grpc.CallOption) (*auth.Session, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "CheckSession", varargs...)
        ret0, _ := ret[0].(*auth.Session)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// CheckSession indicates an expected call of CheckSession.
func (mr *MockAuthServiceClientMockRecorder) CheckSession(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckSession", reflect.TypeOf((*MockAuthServiceClient)(nil).CheckSession), varargs...)
}</span>

// CreateSession mocks base method.
func (m *MockAuthServiceClient) CreateSession(ctx context.Context, in *auth.CreateSessionRequest, opts ...grpc.CallOption) (*auth.Session, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "CreateSession", varargs...)
        ret0, _ := ret[0].(*auth.Session)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// CreateSession indicates an expected call of CreateSession.
func (mr *MockAuthServiceClientMockRecorder) CreateSession(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateSession", reflect.TypeOf((*MockAuthServiceClient)(nil).CreateSession), varargs...)
}</span>

// DeleteSession mocks base method.
func (m *MockAuthServiceClient) DeleteSession(ctx context.Context, in *auth.DeleteSessionRequest, opts ...grpc.CallOption) (*auth.Empty, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "DeleteSession", varargs...)
        ret0, _ := ret[0].(*auth.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DeleteSession indicates an expected call of DeleteSession.
func (mr *MockAuthServiceClientMockRecorder) DeleteSession(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSession", reflect.TypeOf((*MockAuthServiceClient)(nil).DeleteSession), varargs...)
}</span>

// GetUser mocks base method.
func (m *MockAuthServiceClient) GetUser(ctx context.Context, in *auth.GetUserRequest, opts ...grpc.CallOption) (*auth.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetUser", varargs...)
        ret0, _ := ret[0].(*auth.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetUser indicates an expected call of GetUser.
func (mr *MockAuthServiceClientMockRecorder) GetUser(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockAuthServiceClient)(nil).GetUser), varargs...)
}</span>

// Login mocks base method.
func (m *MockAuthServiceClient) Login(ctx context.Context, in *auth.LoginRequest, opts ...grpc.CallOption) (*auth.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "Login", varargs...)
        ret0, _ := ret[0].(*auth.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Login indicates an expected call of Login.
func (mr *MockAuthServiceClientMockRecorder) Login(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Login", reflect.TypeOf((*MockAuthServiceClient)(nil).Login), varargs...)
}</span>

// Logout mocks base method.
func (m *MockAuthServiceClient) Logout(ctx context.Context, in *auth.LogoutRequest, opts ...grpc.CallOption) (*auth.Empty, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "Logout", varargs...)
        ret0, _ := ret[0].(*auth.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Logout indicates an expected call of Logout.
func (mr *MockAuthServiceClientMockRecorder) Logout(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Logout", reflect.TypeOf((*MockAuthServiceClient)(nil).Logout), varargs...)
}</span>

// Register mocks base method.
func (m *MockAuthServiceClient) Register(ctx context.Context, in *auth.RegisterRequest, opts ...grpc.CallOption) (*auth.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "Register", varargs...)
        ret0, _ := ret[0].(*auth.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Register indicates an expected call of Register.
func (mr *MockAuthServiceClientMockRecorder) Register(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Register", reflect.TypeOf((*MockAuthServiceClient)(nil).Register), varargs...)
}</span>

// MockAuthServiceServer is a mock of AuthServiceServer interface.
type MockAuthServiceServer struct {
        ctrl     *gomock.Controller
        recorder *MockAuthServiceServerMockRecorder
}

// MockAuthServiceServerMockRecorder is the mock recorder for MockAuthServiceServer.
type MockAuthServiceServerMockRecorder struct {
        mock *MockAuthServiceServer
}

// NewMockAuthServiceServer creates a new mock instance.
func NewMockAuthServiceServer(ctrl *gomock.Controller) *MockAuthServiceServer <span class="cov0" title="0">{
        mock := &amp;MockAuthServiceServer{ctrl: ctrl}
        mock.recorder = &amp;MockAuthServiceServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthServiceServer) EXPECT() *MockAuthServiceServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CheckSession mocks base method.
func (m *MockAuthServiceServer) CheckSession(arg0 context.Context, arg1 *auth.CheckSessionRequest) (*auth.Session, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CheckSession", arg0, arg1)
        ret0, _ := ret[0].(*auth.Session)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CheckSession indicates an expected call of CheckSession.
func (mr *MockAuthServiceServerMockRecorder) CheckSession(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckSession", reflect.TypeOf((*MockAuthServiceServer)(nil).CheckSession), arg0, arg1)
}</span>

// CreateSession mocks base method.
func (m *MockAuthServiceServer) CreateSession(arg0 context.Context, arg1 *auth.CreateSessionRequest) (*auth.Session, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateSession", arg0, arg1)
        ret0, _ := ret[0].(*auth.Session)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateSession indicates an expected call of CreateSession.
func (mr *MockAuthServiceServerMockRecorder) CreateSession(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateSession", reflect.TypeOf((*MockAuthServiceServer)(nil).CreateSession), arg0, arg1)
}</span>

// DeleteSession mocks base method.
func (m *MockAuthServiceServer) DeleteSession(arg0 context.Context, arg1 *auth.DeleteSessionRequest) (*auth.Empty, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteSession", arg0, arg1)
        ret0, _ := ret[0].(*auth.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteSession indicates an expected call of DeleteSession.
func (mr *MockAuthServiceServerMockRecorder) DeleteSession(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSession", reflect.TypeOf((*MockAuthServiceServer)(nil).DeleteSession), arg0, arg1)
}</span>

// GetUser mocks base method.
func (m *MockAuthServiceServer) GetUser(arg0 context.Context, arg1 *auth.GetUserRequest) (*auth.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUser", arg0, arg1)
        ret0, _ := ret[0].(*auth.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUser indicates an expected call of GetUser.
func (mr *MockAuthServiceServerMockRecorder) GetUser(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockAuthServiceServer)(nil).GetUser), arg0, arg1)
}</span>

// Login mocks base method.
func (m *MockAuthServiceServer) Login(arg0 context.Context, arg1 *auth.LoginRequest) (*auth.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Login", arg0, arg1)
        ret0, _ := ret[0].(*auth.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Login indicates an expected call of Login.
func (mr *MockAuthServiceServerMockRecorder) Login(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Login", reflect.TypeOf((*MockAuthServiceServer)(nil).Login), arg0, arg1)
}</span>

// Logout mocks base method.
func (m *MockAuthServiceServer) Logout(arg0 context.Context, arg1 *auth.LogoutRequest) (*auth.Empty, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Logout", arg0, arg1)
        ret0, _ := ret[0].(*auth.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Logout indicates an expected call of Logout.
func (mr *MockAuthServiceServerMockRecorder) Logout(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Logout", reflect.TypeOf((*MockAuthServiceServer)(nil).Logout), arg0, arg1)
}</span>

// Register mocks base method.
func (m *MockAuthServiceServer) Register(arg0 context.Context, arg1 *auth.RegisterRequest) (*auth.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Register", arg0, arg1)
        ret0, _ := ret[0].(*auth.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Register indicates an expected call of Register.
func (mr *MockAuthServiceServerMockRecorder) Register(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Register", reflect.TypeOf((*MockAuthServiceServer)(nil).Register), arg0, arg1)
}</span>

// mustEmbedUnimplementedAuthServiceServer mocks base method.
func (m *MockAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedAuthServiceServer")
}</span>

// mustEmbedUnimplementedAuthServiceServer indicates an expected call of mustEmbedUnimplementedAuthServiceServer.
func (mr *MockAuthServiceServerMockRecorder) mustEmbedUnimplementedAuthServiceServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedAuthServiceServer", reflect.TypeOf((*MockAuthServiceServer)(nil).mustEmbedUnimplementedAuthServiceServer))
}</span>

// MockUnsafeAuthServiceServer is a mock of UnsafeAuthServiceServer interface.
type MockUnsafeAuthServiceServer struct {
        ctrl     *gomock.Controller
        recorder *MockUnsafeAuthServiceServerMockRecorder
}

// MockUnsafeAuthServiceServerMockRecorder is the mock recorder for MockUnsafeAuthServiceServer.
type MockUnsafeAuthServiceServerMockRecorder struct {
        mock *MockUnsafeAuthServiceServer
}

// NewMockUnsafeAuthServiceServer creates a new mock instance.
func NewMockUnsafeAuthServiceServer(ctrl *gomock.Controller) *MockUnsafeAuthServiceServer <span class="cov0" title="0">{
        mock := &amp;MockUnsafeAuthServiceServer{ctrl: ctrl}
        mock.recorder = &amp;MockUnsafeAuthServiceServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeAuthServiceServer) EXPECT() *MockUnsafeAuthServiceServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// mustEmbedUnimplementedAuthServiceServer mocks base method.
func (m *MockUnsafeAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedAuthServiceServer")
}</span>

// mustEmbedUnimplementedAuthServiceServer indicates an expected call of mustEmbedUnimplementedAuthServiceServer.
func (mr *MockUnsafeAuthServiceServerMockRecorder) mustEmbedUnimplementedAuthServiceServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedAuthServiceServer", reflect.TypeOf((*MockUnsafeAuthServiceServer)(nil).mustEmbedUnimplementedAuthServiceServer))
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">package handlers

import (
        "net/http"

        pb "kudago/internal/auth/api"
        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"
        pbImage "kudago/internal/image/api"
        "kudago/internal/models"

        grpcCodes "google.golang.org/grpc/codes"
        grpcStatus "google.golang.org/grpc/status"

        "github.com/asaskevich/govalidator"
)

func (h *AuthHandlers) Register(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _, ok := utils.GetSessionFromContext(r.Context())
        if ok </span><span class="cov8" title="1">{
                utils.WriteResponse(w, http.StatusForbidden, httpErrors.ErrUserIsAuthorized)
                return
        }</span>

        <span class="cov8" title="1">req, media, reqErr := parseRegisterData(r)
        if reqErr != nil </span><span class="cov8" title="1">{
                utils.WriteResponse(w, http.StatusBadRequest, reqErr)
                return
        }</span>

        <span class="cov0" title="0">_, err := govalidator.ValidateStruct(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                utils.ProcessValidationErrors(w, err)
                return
        }</span>

        <span class="cov0" title="0">url, err := h.uploadImage(r.Context(), media, w)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">registerRequest := &amp;pb.RegisterRequest{
                Username:  req.Username,
                Password:  req.Password,
                Email:     req.Email,
                AvatarUrl: url,
        }

        user, err := h.AuthService.Register(r.Context(), registerRequest)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(r.Context(), "register", err)

                h.deleteImage(r.Context(), url)
                st, ok := grpcStatus.FromError(err)
                if ok </span><span class="cov0" title="0">{
                        switch st.Code() </span>{
                        case grpcCodes.AlreadyExists:<span class="cov0" title="0">
                                utils.WriteResponse(w, http.StatusConflict, httpErrors.ErrUsernameIsAlredyTaken)
                                return</span>
                        case grpcCodes.Internal:<span class="cov0" title="0">
                                h.logger.Error(r.Context(), "register", st.Err())
                                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                                return</span>
                        }
                }

                <span class="cov0" title="0">h.logger.Error(r.Context(), "register", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return</span>
        }
        <span class="cov0" title="0">h.logger.Error(r.Context(), "set cookie", err)

        err = h.setSessionCookie(w, r, int(user.ID))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(r.Context(), "set cookie", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return
        }</span>

        <span class="cov0" title="0">resp := userToUserResponse(user)

        utils.WriteResponse(w, http.StatusOK, resp)
        return</span>
}

func parseRegisterData(r *http.Request) (models.User, *pbImage.UploadRequest, *httpErrors.HttpError) <span class="cov8" title="1">{
        var req models.User
        jsonData := r.FormValue("json")
        err := req.UnmarshalJSON([]byte(jsonData))
        if err != nil </span><span class="cov8" title="1">{
                return req, nil, httpErrors.ErrInvalidData
        }</span>

        <span class="cov0" title="0">media, err := utils.HandleImageUpload(r)
        if err != nil </span><span class="cov0" title="0">{
                return req, nil, httpErrors.ErrInvalidImage
        }</span>

        <span class="cov0" title="0">return req, media, nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package httpErrors

import (
        json "encoding/json"
        easyjson "github.com/mailru/easyjson"
        jlexer "github.com/mailru/easyjson/jlexer"
        jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
        _ *json.RawMessage
        _ *jlexer.Lexer
        _ *jwriter.Writer
        _ easyjson.Marshaler
)

func easyjsonD31a5a85DecodeKudagoInternalGatewayErrors(in *jlexer.Lexer, out *HttpError) <span class="cov0" title="0">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov0" title="0">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov0" title="0">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov0" title="0">switch key </span>{
                case "message":<span class="cov0" title="0">
                        out.Message = string(in.String())</span>
                case "code":<span class="cov0" title="0">
                        out.Code = string(in.String())</span>
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov0" title="0">in.WantComma()</span>
        }
        <span class="cov0" title="0">in.Delim('}')
        if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjsonD31a5a85EncodeKudagoInternalGatewayErrors(out *jwriter.Writer, in HttpError) <span class="cov8" title="1">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov8" title="1">{
                const prefix string = ",\"message\":"
                out.RawString(prefix[1:])
                out.String(string(in.Message))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"code\":"
                out.RawString(prefix)
                out.String(string(in.Code))
        }</span>
        <span class="cov8" title="1">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v HttpError) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjsonD31a5a85EncodeKudagoInternalGatewayErrors(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v HttpError) MarshalEasyJSON(w *jwriter.Writer) <span class="cov8" title="1">{
        easyjsonD31a5a85EncodeKudagoInternalGatewayErrors(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *HttpError) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        r := jlexer.Lexer{Data: data}
        easyjsonD31a5a85DecodeKudagoInternalGatewayErrors(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *HttpError) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjsonD31a5a85DecodeKudagoInternalGatewayErrors(l, v)
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">package events

import (
        "context"
        "net/http"
        "time"

        pbEvent "kudago/internal/event/api"
        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"
        pbNtf "kudago/internal/notification/api"

        "github.com/asaskevich/govalidator"
        grpcCodes "google.golang.org/grpc/codes"
        grpcStatus "google.golang.org/grpc/status"
)

// AddEvent создает новое событие в системе.
// @Summary Создание события
// @Description Создает новое событие в системе. Необходимо передать JSON-объект с данными события.
// @Tags events
// @Accept  json
// @Produce  json
// @Param json body NewEventRequest true "Данные для создания события"
// @Success 201 {object} NewEventResponse "Событие успешно создано"
// @Failure 400 {object} httpErrors.HttpError "Неверные данные"
// @Failure 401 {object} httpErrors.HttpError "Неавторизован"
// @Failure 500 {object} httpErrors.HttpError "Внутренняя ошибка сервера"
// @Router /events [post]
func (h EventHandler) AddEvent(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        session, ok := utils.GetSessionFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusForbidden, httpErrors.ErrUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">req, media, reqErr := parseEventData(r)
        if reqErr != nil </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusBadRequest, reqErr)
                return
        }</span>

        <span class="cov0" title="0">_, err := govalidator.ValidateStruct(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                utils.ProcessValidationErrors(w, err)
                return
        }</span>

        <span class="cov0" title="0">reqErr = checkNewEventRequest(req)
        if reqErr != nil </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusBadRequest, reqErr)
                return
        }</span>

        <span class="cov0" title="0">url, err := h.uploadImage(r.Context(), media, w)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">event := toPBEvent(req, session.UserID)
        event.Image = url

        event, err = h.EventService.AddEvent(r.Context(), event)
        if err != nil </span><span class="cov0" title="0">{
                h.deleteImage(r.Context(), url)
                st, ok := grpcStatus.FromError(err)
                if ok </span><span class="cov0" title="0">{
                        switch st.Code() </span>{
                        case grpcCodes.InvalidArgument:<span class="cov0" title="0">
                                utils.WriteResponse(w, http.StatusConflict, httpErrors.ErrInvalidData)
                                return</span>
                        }
                }

                <span class="cov0" title="0">h.logger.Error(r.Context(), "add event", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return</span>
        }

        <span class="cov0" title="0">eventResp := eventToEventResponse(event)
        resp := NewEventResponse{
                Event: eventResp,
        }

        err = h.sendCreatedNotifications(r.Context(), int(event.ID), session.UserID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(r.Context(), "send create notifications", err)
        }</span>

        <span class="cov0" title="0">utils.WriteResponse(w, http.StatusOK, resp)</span>
}

func (h EventHandler) sendCreatedNotifications(ctx context.Context, eventID int, userID int) error <span class="cov0" title="0">{
        idsResp, err := h.EventService.GetSubscribersIDs(ctx, &amp;pbEvent.GetSubscribersIDsRequest{UserID: int32(userID)})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">req := &amp;pbNtf.CreateNotificationsRequest{
                UserIDs: make([]int32, 0, len(idsResp.IDs)),
                Notification: &amp;pbNtf.Notification{
                        Message:  CreatedEventMsg,
                        NotifyAt: time.Now().String(),
                        EventID:  int32(eventID),
                },
        }

        for _, id := range idsResp.IDs </span><span class="cov0" title="0">{
                req.UserIDs = append(req.UserIDs, int32(id))
        }</span>

        <span class="cov0" title="0">_, err = h.NotificationService.CreateNotifications(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package events

import (
        "net/http"
        "strconv"

        grpcCodes "google.golang.org/grpc/codes"
        grpcStatus "google.golang.org/grpc/status"
        pb "kudago/internal/event/api"
        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"

        "github.com/gorilla/mux"
)

// @Summary Добавление события в изсбранное
// @Description Добавить событие в избранное
// @Tags events
// @Produce  json
// @Success 200
// @Failure 401 {object} httpErrors.HttpError "Unauthorized"
// @Failure 500 {object} httpErrors.HttpError "Internal Server Error"
// @Router /events/favorites/{id} [post]
func (h EventHandler) AddEventToFavorites(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        session, ok := utils.GetSessionFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusForbidden, httpErrors.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">newFavorite := &amp;pb.FavoriteEvent{
                UserID:  int32(session.UserID),
                EventID: int32(id),
        }

        _, err = h.EventService.AddEventToFavorites(r.Context(), newFavorite)
        if err != nil </span><span class="cov8" title="1">{
                st, ok := grpcStatus.FromError(err)
                if ok </span><span class="cov8" title="1">{
                        switch st.Code() </span>{
                        case grpcCodes.NotFound:<span class="cov8" title="1">
                                utils.WriteResponse(w, http.StatusConflict, httpErrors.ErrEventNotFound)
                                return</span>
                        case grpcCodes.AlreadyExists:<span class="cov8" title="1">
                                utils.WriteResponse(w, http.StatusConflict, httpErrors.ErrEventAlreadyAddedToFavorites)
                                return</span>
                        }
                }

                <span class="cov8" title="1">h.logger.Error(r.Context(), "add event to favorites", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return</span>
        }

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package events

import (
        "io"
        "net/http"
        "time"

        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"
        pb "kudago/internal/notification/api"

        "github.com/asaskevich/govalidator"
)

// @Summary Создание уведомления
// @Description Создание уведомления
// @Tags notifications
// @Accept  json
// @Param json body CreateNotificationRequest true "Данные для создания уведомления"
// @Success 200 {object} string "Notification created successfully"
// @Failure 500 {object} httpErrors.HttpError "Internal Server Error"
// @Router /notifications [post]
func (h EventHandler) CreateInvitationNotification(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, ok := utils.GetSessionFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusForbidden, httpErrors.ErrUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidData)
                return
        }</span>
        <span class="cov0" title="0">defer r.Body.Close()

        req := InviteNotificationRequest{}
        if err := req.UnmarshalJSON(body); err != nil </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidData)
                return
        }</span>

        <span class="cov0" title="0">_, err = govalidator.ValidateStruct(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                utils.ProcessValidationErrors(w, err)
                return
        }</span>

        <span class="cov0" title="0">reqPB := &amp;pb.CreateNotificationsRequest{
                UserIDs: []int32{int32(req.UserID)},
                Notification: &amp;pb.Notification{
                        Message:  InvitationMsg,
                        NotifyAt: time.Now().String(),
                        EventID:  int32(req.EventID),
                },
        }

        _, err = h.NotificationService.CreateNotifications(r.Context(), reqPB)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(r.Context(), "create notification", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package events

import (
        "net/http"
        "strconv"

        pb "kudago/internal/event/api"
        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"

        "github.com/gorilla/mux"
        grpcCodes "google.golang.org/grpc/codes"
        grpcStatus "google.golang.org/grpc/status"
)

// @Summary Удаление события
// @Description Удаляет существующее событие
// @Tags events
// @Produce  json
// @Success 204
// @Failure 401 {object} httpErrors.HttpError "Unauthorized"
// @Failure 403 {object} httpErrors.HttpError "Access Denied"
// @Failure 404 {object} httpErrors.HttpError "Event Not Found"
// @Failure 500 {object} httpErrors.HttpError "Internal Server Error"
// @Router /events/{id} [delete]
func (h EventHandler) DeleteEvent(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        session, ok := utils.GetSessionFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusForbidden, httpErrors.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">authorID := session.UserID

        req := &amp;pb.DeleteEventRequest{
                AuthorID: int32(authorID),
                EventID:  int32(id),
        }
        _, err = h.EventService.DeleteEvent(r.Context(), req)
        if err != nil </span><span class="cov8" title="1">{
                st, ok := grpcStatus.FromError(err)
                if ok </span><span class="cov8" title="1">{
                        switch st.Code() </span>{
                        case grpcCodes.NotFound:<span class="cov8" title="1">
                                utils.WriteResponse(w, http.StatusConflict, httpErrors.ErrEventNotFound)
                                return</span>
                        case grpcCodes.PermissionDenied:<span class="cov8" title="1">
                                utils.WriteResponse(w, http.StatusForbidden, httpErrors.ErrAccessDenied)
                                return</span>
                        }
                }

                <span class="cov8" title="1">h.logger.Error(r.Context(), "delete event", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return</span>
        }
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package events

import (
        "net/http"
        "strconv"

        pb "kudago/internal/event/api"

        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"

        "github.com/gorilla/mux"
        grpcCodes "google.golang.org/grpc/codes"
        grpcStatus "google.golang.org/grpc/status"
)

// @Summary Удаление события из избранного
// @Description Удаляет событие из списка избранного
// @Tags events
// @Produce  json
// @Success 200
// @Failure 401 {object} httpErrors.HttpError "Unauthorized"
// @Failure 500 {object} httpErrors.HttpError "Internal Server Error"
// @Router /events/favorites/{id} [delete]
func (h EventHandler) DeleteEventFromFavorites(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        session, ok := utils.GetSessionFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusForbidden, httpErrors.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">newFavorite := &amp;pb.FavoriteEvent{
                UserID:  int32(session.UserID),
                EventID: int32(id),
        }

        _, err = h.EventService.DeleteEventFromFavorites(r.Context(), newFavorite)
        if err != nil </span><span class="cov8" title="1">{
                st, ok := grpcStatus.FromError(err)
                if ok </span><span class="cov8" title="1">{
                        switch st.Code() </span>{
                        case grpcCodes.NotFound:<span class="cov8" title="1">
                                utils.WriteResponse(w, http.StatusConflict, httpErrors.ErrEventNotFound)
                                return</span>
                        }
                }

                <span class="cov8" title="1">h.logger.Error(r.Context(), "delete event from favorites", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return</span>
        }

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">//go:generate mockgen -source=../../event/api/event_grpc.pb.go -destination=mocks/event.go -package=mocks
//go:generate mockgen -source=../../notification/api/notification_grpc.pb.go -destination=mocks/notification.go -package=mocks

//go:generate easyjson event.go
package events

import (
        "context"
        "net/http"
        "strconv"
        "time"

        pbEvent "kudago/internal/event/api"
        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"
        pbImage "kudago/internal/image/api"
        "kudago/internal/logger"
        pbNotification "kudago/internal/notification/api"

        "kudago/internal/models"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

const (
        defaultPage  = 0
        defaultLimit = 30

        UpdatedEventMsg = "Информация о событии обновилась. Посмотреть тут:"
        CreatedEventMsg = "У вас новое мероприятие в подписках! . Посмотреть тут:"
        InvitationMsg   = "Вас пригласили на новое мероприятие: "
)

type EventHandler struct {
        EventService        pbEvent.EventServiceClient
        ImageService        pbImage.ImageServiceClient
        NotificationService pbNotification.NotificationServiceClient
        logger              *logger.Logger
}

func NewHandlers(eventServiceAddr string, imageServiceAddr string, notificationServiceAddr string, logger *logger.Logger) (*EventHandler, error) <span class="cov0" title="0">{
        eventConn, err := grpc.NewClient(eventServiceAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">imageConn, err := grpc.NewClient(imageServiceAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">notificationConn, err := grpc.NewClient(notificationServiceAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;EventHandler{
                EventService:        pbEvent.NewEventServiceClient(eventConn),
                ImageService:        pbImage.NewImageServiceClient(imageConn),
                NotificationService: pbNotification.NewNotificationServiceClient(notificationConn),
                logger:              logger,
        }, nil</span>
}

var maxDate = time.Date(2030, 12, 31, 0, 0, 0, 0, time.UTC)

//easyjson:json
type EventResponse struct {
        ID          int      `json:"id"`
        Title       string   `json:"title"`
        Description string   `json:"description"`
        Location    string   `json:"location"`
        Category    int      `json:"category_id"`
        Capacity    int      `json:"capacity"`
        Tag         []string `json:"tag"`
        AuthorID    int      `json:"author"`
        EventStart  string   `json:"event_start"`
        EventEnd    string   `json:"event_end"`
        ImageURL    string   `json:"image"`
        Latitude    float64  `json:"Latitude"`
        Longitude   float64  `json:"Longitude"`
}

//easyjson:json
type InviteNotificationRequest struct {
        UserID  int `json:"user_id" valid:"range(1|20000)"`
        EventID int `json:"event_id" valid:"range(1|20000)"`
}

//easyjson:json
type GetEventsResponse struct {
        Events []EventResponse `json:"events"`
}

//easyjson:json
type NewEventRequest struct {
        Title       string   `json:"title" valid:"required,length(3|100)"`
        Description string   `json:"description" valid:"required,length(3|1000)" `
        Location    string   `json:"location" valid:"length(3|100)"`
        Category    int      `json:"category_id" valid:"required,range(1|8)"`
        Capacity    int      `json:"capacity" valid:"range(1|20000)"`
        Tag         []string `json:"tag"`
        EventStart  string   `json:"event_start" valid:"rfc3339,required"`
        EventEnd    string   `json:"event_end" valid:"rfc3339,required"`
        Latitude    float64  `json:"Latitude"`
        Longitude   float64  `json:"Longitude"`
}

//easyjson:json
type NewEventResponse struct {
        Event EventResponse `json:"event"`
}

//easyjson:json
type GetNotificationsResponse struct {
        Notifications []NotificationWithEvent `json:"notifications"`
}

//easyjson:json
type NotificationWithEvent struct {
        Notification models.Notification `json:"notification"`
        Event        models.Event        `json:"event"`
}

//easyjson:json
type GetCategoriesResponse struct {
        Categories []models.Category `json:"categories"`
}

func checkNewEventRequest(req NewEventRequest) *httpErrors.HttpError <span class="cov0" title="0">{
        if len(req.Tag) &gt; 3 </span><span class="cov0" title="0">{
                return httpErrors.ErrTooManyTags
        }</span>

        <span class="cov0" title="0">for _, tag := range req.Tag </span><span class="cov0" title="0">{
                if len(tag) &gt; 20 || len(tag) == 0 </span><span class="cov0" title="0">{
                        return httpErrors.ErrBadTagLength
                }</span>
        }

        <span class="cov0" title="0">eventStart, err := time.Parse(time.RFC3339, req.EventStart)
        if err != nil </span><span class="cov0" title="0">{
                return httpErrors.ErrInvalidTime
        }</span>

        <span class="cov0" title="0">eventEnd, err := time.Parse(time.RFC3339, req.EventEnd)
        if err != nil </span><span class="cov0" title="0">{
                return httpErrors.ErrInvalidTime
        }</span>

        <span class="cov0" title="0">if !eventEnd.After(eventStart) </span><span class="cov0" title="0">{
                return httpErrors.ErrEventStartAfterEventEnd
        }</span>

        <span class="cov0" title="0">if eventStart.Before(time.Now()) || eventEnd.After(maxDate) </span><span class="cov0" title="0">{
                return httpErrors.ErrBadEventTiming
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func parseEventData(r *http.Request) (NewEventRequest, *pbImage.UploadRequest, *httpErrors.HttpError) <span class="cov0" title="0">{
        var req NewEventRequest
        jsonData := r.FormValue("json")
        err := req.UnmarshalJSON([]byte(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return req, nil, httpErrors.ErrInvalidData
        }</span>

        <span class="cov0" title="0">media, err := utils.HandleImageUpload(r)
        if err != nil </span><span class="cov0" title="0">{
                return req, nil, httpErrors.ErrInvalidImage
        }</span>

        <span class="cov0" title="0">return req, media, nil</span>
}

func toModelEvent(req NewEventRequest, authorID int) models.Event <span class="cov0" title="0">{
        return models.Event{
                Title:       req.Title,
                Description: req.Description,
                Location:    req.Location,
                EventStart:  req.EventStart,
                EventEnd:    req.EventEnd,
                AuthorID:    authorID,
                CategoryID:  req.Category,
                Capacity:    req.Capacity,
                Tag:         req.Tag,
        }
}</span>

func toPBEvent(req NewEventRequest, authorID int) *pbEvent.Event <span class="cov0" title="0">{
        return &amp;pbEvent.Event{
                Title:       req.Title,
                Description: req.Description,
                Location:    req.Location,
                EventStart:  req.EventStart,
                EventEnd:    req.EventEnd,
                AuthorID:    int32(authorID),
                CategoryID:  int32(req.Category),
                Capacity:    int32(req.Capacity),
                Tag:         req.Tag,
                Latitude:    float64(req.Latitude),
                Longitude:   float64(req.Longitude),
        }
}</span>

func toEvent(event *pbEvent.Event) models.Event <span class="cov0" title="0">{
        return models.Event{
                Title:       event.Title,
                Description: event.Description,
                Location:    event.Location,
                EventStart:  event.EventStart,
                EventEnd:    event.EventEnd,
                AuthorID:    int(event.AuthorID),
                CategoryID:  int(event.CategoryID),
                Capacity:    int(event.Capacity),
                Tag:         event.Tag,
        }
}</span>

func eventToEventResponse(event *pbEvent.Event) EventResponse <span class="cov8" title="1">{
        return EventResponse{
                ID:          int(event.ID),
                Title:       event.Title,
                Description: event.Description,
                EventStart:  event.EventStart,
                EventEnd:    event.EventEnd,
                Tag:         event.Tag,
                AuthorID:    int(event.AuthorID),
                Category:    int(event.CategoryID),
                ImageURL:    event.Image,
                Capacity:    int(event.Capacity),
                Longitude:   float64(event.Longitude),
                Latitude:    float64(event.Latitude),
        }
}</span>

func writeEventsResponse(events []*pbEvent.Event, limit int) GetEventsResponse <span class="cov8" title="1">{
        resp := GetEventsResponse{make([]EventResponse, 0, limit)}

        for _, event := range events </span><span class="cov8" title="1">{
                eventResp := eventToEventResponse(event)
                resp.Events = append(resp.Events, eventResp)
        }</span>
        <span class="cov8" title="1">return resp</span>
}

func GetQueryParamInt(r *http.Request, key string, defaultValue int) int <span class="cov8" title="1">{
        valueStr := r.URL.Query().Get(key)
        value, err := strconv.Atoi(valueStr)

        if err != nil || value &lt;= 0 </span><span class="cov8" title="1">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">return value</span>
}

func GetPaginationParams(r *http.Request) *pbEvent.PaginationParams <span class="cov8" title="1">{
        page := GetQueryParamInt(r, "page", defaultPage)
        limit := GetQueryParamInt(r, "limit", defaultLimit)
        offset := page * limit
        return &amp;pbEvent.PaginationParams{
                Offset: int32(offset),
                Limit:  int32(limit),
        }
}</span>

func (h *EventHandler) deleteImage(ctx context.Context, url string) <span class="cov0" title="0">{
        if url != "" </span><span class="cov0" title="0">{
                req := &amp;pbImage.DeleteRequest{
                        FileUrl: url,
                }
                h.ImageService.DeleteImage(ctx, req)
        }</span>
}

func (h *EventHandler) uploadImage(ctx context.Context, media *pbImage.UploadRequest, w http.ResponseWriter) (string, error) <span class="cov0" title="0">{
        if media != nil </span><span class="cov0" title="0">{
                url, err := h.ImageService.UploadImage(ctx, media)
                if err != nil </span><span class="cov0" title="0">{
                        switch err </span>{
                        case models.ErrInvalidImage:<span class="cov0" title="0">
                                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidImage)</span>
                        case models.ErrInvalidImageFormat:<span class="cov0" title="0">
                                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidImageFormat)</span>
                        default:<span class="cov0" title="0">
                                h.logger.Error(ctx, "upload image", err)
                                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)</span>
                        }
                        <span class="cov0" title="0">return "", err</span>
                }
                <span class="cov0" title="0">return url.FileUrl, nil</span>
        }
        <span class="cov0" title="0">return "", nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package events

import (
        json "encoding/json"
        easyjson "github.com/mailru/easyjson"
        jlexer "github.com/mailru/easyjson/jlexer"
        jwriter "github.com/mailru/easyjson/jwriter"
        models "kudago/internal/models"
)

// suppress unused package warning
var (
        _ *json.RawMessage
        _ *jlexer.Lexer
        _ *jwriter.Writer
        _ easyjson.Marshaler
)

func easyjsonF642ad3eDecodeKudagoInternalGatewayEvent(in *jlexer.Lexer, out *NotificationWithEvent) <span class="cov8" title="1">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov8" title="1">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov8" title="1">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov8" title="1">switch key </span>{
                case "notification":<span class="cov8" title="1">
                        (out.Notification).UnmarshalEasyJSON(in)</span>
                case "event":<span class="cov8" title="1">
                        easyjsonF642ad3eDecodeKudagoInternalModels(in, &amp;out.Event)</span>
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov8" title="1">in.WantComma()</span>
        }
        <span class="cov8" title="1">in.Delim('}')
        if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjsonF642ad3eEncodeKudagoInternalGatewayEvent(out *jwriter.Writer, in NotificationWithEvent) <span class="cov8" title="1">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov8" title="1">{
                const prefix string = ",\"notification\":"
                out.RawString(prefix[1:])
                (in.Notification).MarshalEasyJSON(out)
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"event\":"
                out.RawString(prefix)
                easyjsonF642ad3eEncodeKudagoInternalModels(out, in.Event)
        }</span>
        <span class="cov8" title="1">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v NotificationWithEvent) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjsonF642ad3eEncodeKudagoInternalGatewayEvent(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v NotificationWithEvent) MarshalEasyJSON(w *jwriter.Writer) <span class="cov8" title="1">{
        easyjsonF642ad3eEncodeKudagoInternalGatewayEvent(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *NotificationWithEvent) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        r := jlexer.Lexer{Data: data}
        easyjsonF642ad3eDecodeKudagoInternalGatewayEvent(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *NotificationWithEvent) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov8" title="1">{
        easyjsonF642ad3eDecodeKudagoInternalGatewayEvent(l, v)
}</span>
func easyjsonF642ad3eDecodeKudagoInternalModels(in *jlexer.Lexer, out *models.Event) <span class="cov8" title="1">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov8" title="1">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov8" title="1">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov8" title="1">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov8" title="1">switch key </span>{
                case "id":<span class="cov8" title="1">
                        out.ID = int(in.Int())</span>
                case "title":<span class="cov8" title="1">
                        out.Title = string(in.String())</span>
                case "description":<span class="cov8" title="1">
                        out.Description = string(in.String())</span>
                case "event_start":<span class="cov8" title="1">
                        out.EventStart = string(in.String())</span>
                case "event_finish":<span class="cov8" title="1">
                        out.EventEnd = string(in.String())</span>
                case "location":<span class="cov8" title="1">
                        out.Location = string(in.String())</span>
                case "capacity":<span class="cov8" title="1">
                        out.Capacity = int(in.Int())</span>
                case "created_at":<span class="cov8" title="1">
                        if data := in.Raw(); in.Ok() </span><span class="cov8" title="1">{
                                in.AddError((out.CreatedAt).UnmarshalJSON(data))
                        }</span>
                case "category_id":<span class="cov8" title="1">
                        out.CategoryID = int(in.Int())</span>
                case "author":<span class="cov8" title="1">
                        out.AuthorID = int(in.Int())</span>
                case "Latitude":<span class="cov8" title="1">
                        out.Latitude = float64(in.Float64())</span>
                case "Longitude":<span class="cov8" title="1">
                        out.Longitude = float64(in.Float64())</span>
                case "tag":<span class="cov0" title="0">
                        if in.IsNull() </span><span class="cov0" title="0">{
                                in.Skip()
                                out.Tag = nil
                        }</span> else<span class="cov0" title="0"> {
                                in.Delim('[')
                                if out.Tag == nil </span><span class="cov0" title="0">{
                                        if !in.IsDelim(']') </span><span class="cov0" title="0">{
                                                out.Tag = make([]string, 0, 4)
                                        }</span> else<span class="cov0" title="0"> {
                                                out.Tag = []string{}
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        out.Tag = (out.Tag)[:0]
                                }</span>
                                <span class="cov0" title="0">for !in.IsDelim(']') </span><span class="cov0" title="0">{
                                        var v1 string
                                        v1 = string(in.String())
                                        out.Tag = append(out.Tag, v1)
                                        in.WantComma()
                                }</span>
                                <span class="cov0" title="0">in.Delim(']')</span>
                        }
                case "image":<span class="cov8" title="1">
                        out.ImageURL = string(in.String())</span>
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov8" title="1">in.WantComma()</span>
        }
        <span class="cov8" title="1">in.Delim('}')
        if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjsonF642ad3eEncodeKudagoInternalModels(out *jwriter.Writer, in models.Event) <span class="cov8" title="1">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov8" title="1">{
                const prefix string = ",\"id\":"
                out.RawString(prefix[1:])
                out.Int(int(in.ID))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"title\":"
                out.RawString(prefix)
                out.String(string(in.Title))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"description\":"
                out.RawString(prefix)
                out.String(string(in.Description))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"event_start\":"
                out.RawString(prefix)
                out.String(string(in.EventStart))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"event_finish\":"
                out.RawString(prefix)
                out.String(string(in.EventEnd))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"location\":"
                out.RawString(prefix)
                out.String(string(in.Location))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"capacity\":"
                out.RawString(prefix)
                out.Int(int(in.Capacity))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"created_at\":"
                out.RawString(prefix)
                out.Raw((in.CreatedAt).MarshalJSON())
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"category_id\":"
                out.RawString(prefix)
                out.Int(int(in.CategoryID))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"author\":"
                out.RawString(prefix)
                out.Int(int(in.AuthorID))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"Latitude\":"
                out.RawString(prefix)
                out.Float64(float64(in.Latitude))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"Longitude\":"
                out.RawString(prefix)
                out.Float64(float64(in.Longitude))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"tag\":"
                out.RawString(prefix)
                if in.Tag == nil &amp;&amp; (out.Flags&amp;jwriter.NilSliceAsEmpty) == 0 </span><span class="cov8" title="1">{
                        out.RawString("null")
                }</span> else<span class="cov0" title="0"> {
                        out.RawByte('[')
                        for v2, v3 := range in.Tag </span><span class="cov0" title="0">{
                                if v2 &gt; 0 </span><span class="cov0" title="0">{
                                        out.RawByte(',')
                                }</span>
                                <span class="cov0" title="0">out.String(string(v3))</span>
                        }
                        <span class="cov0" title="0">out.RawByte(']')</span>
                }
        }
        <span class="cov8" title="1">{
                const prefix string = ",\"image\":"
                out.RawString(prefix)
                out.String(string(in.ImageURL))
        }</span>
        <span class="cov8" title="1">out.RawByte('}')</span>
}
func easyjsonF642ad3eDecodeKudagoInternalGatewayEvent1(in *jlexer.Lexer, out *NewEventResponse) <span class="cov0" title="0">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov0" title="0">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov0" title="0">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov0" title="0">switch key </span>{
                case "event":<span class="cov0" title="0">
                        (out.Event).UnmarshalEasyJSON(in)</span>
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov0" title="0">in.WantComma()</span>
        }
        <span class="cov0" title="0">in.Delim('}')
        if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjsonF642ad3eEncodeKudagoInternalGatewayEvent1(out *jwriter.Writer, in NewEventResponse) <span class="cov0" title="0">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov0" title="0">{
                const prefix string = ",\"event\":"
                out.RawString(prefix[1:])
                (in.Event).MarshalEasyJSON(out)
        }</span>
        <span class="cov0" title="0">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v NewEventResponse) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjsonF642ad3eEncodeKudagoInternalGatewayEvent1(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v NewEventResponse) MarshalEasyJSON(w *jwriter.Writer) <span class="cov0" title="0">{
        easyjsonF642ad3eEncodeKudagoInternalGatewayEvent1(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *NewEventResponse) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        r := jlexer.Lexer{Data: data}
        easyjsonF642ad3eDecodeKudagoInternalGatewayEvent1(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *NewEventResponse) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjsonF642ad3eDecodeKudagoInternalGatewayEvent1(l, v)
}</span>
func easyjsonF642ad3eDecodeKudagoInternalGatewayEvent2(in *jlexer.Lexer, out *NewEventRequest) <span class="cov0" title="0">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov0" title="0">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov0" title="0">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov0" title="0">switch key </span>{
                case "title":<span class="cov0" title="0">
                        out.Title = string(in.String())</span>
                case "description":<span class="cov0" title="0">
                        out.Description = string(in.String())</span>
                case "location":<span class="cov0" title="0">
                        out.Location = string(in.String())</span>
                case "category_id":<span class="cov0" title="0">
                        out.Category = int(in.Int())</span>
                case "capacity":<span class="cov0" title="0">
                        out.Capacity = int(in.Int())</span>
                case "tag":<span class="cov0" title="0">
                        if in.IsNull() </span><span class="cov0" title="0">{
                                in.Skip()
                                out.Tag = nil
                        }</span> else<span class="cov0" title="0"> {
                                in.Delim('[')
                                if out.Tag == nil </span><span class="cov0" title="0">{
                                        if !in.IsDelim(']') </span><span class="cov0" title="0">{
                                                out.Tag = make([]string, 0, 4)
                                        }</span> else<span class="cov0" title="0"> {
                                                out.Tag = []string{}
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        out.Tag = (out.Tag)[:0]
                                }</span>
                                <span class="cov0" title="0">for !in.IsDelim(']') </span><span class="cov0" title="0">{
                                        var v4 string
                                        v4 = string(in.String())
                                        out.Tag = append(out.Tag, v4)
                                        in.WantComma()
                                }</span>
                                <span class="cov0" title="0">in.Delim(']')</span>
                        }
                case "event_start":<span class="cov0" title="0">
                        out.EventStart = string(in.String())</span>
                case "event_end":<span class="cov0" title="0">
                        out.EventEnd = string(in.String())</span>
                case "Latitude":<span class="cov0" title="0">
                        out.Latitude = float64(in.Float64())</span>
                case "Longitude":<span class="cov0" title="0">
                        out.Longitude = float64(in.Float64())</span>
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov0" title="0">in.WantComma()</span>
        }
        <span class="cov0" title="0">in.Delim('}')
        if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjsonF642ad3eEncodeKudagoInternalGatewayEvent2(out *jwriter.Writer, in NewEventRequest) <span class="cov0" title="0">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov0" title="0">{
                const prefix string = ",\"title\":"
                out.RawString(prefix[1:])
                out.String(string(in.Title))
        }</span>
        <span class="cov0" title="0">{
                const prefix string = ",\"description\":"
                out.RawString(prefix)
                out.String(string(in.Description))
        }</span>
        <span class="cov0" title="0">{
                const prefix string = ",\"location\":"
                out.RawString(prefix)
                out.String(string(in.Location))
        }</span>
        <span class="cov0" title="0">{
                const prefix string = ",\"category_id\":"
                out.RawString(prefix)
                out.Int(int(in.Category))
        }</span>
        <span class="cov0" title="0">{
                const prefix string = ",\"capacity\":"
                out.RawString(prefix)
                out.Int(int(in.Capacity))
        }</span>
        <span class="cov0" title="0">{
                const prefix string = ",\"tag\":"
                out.RawString(prefix)
                if in.Tag == nil &amp;&amp; (out.Flags&amp;jwriter.NilSliceAsEmpty) == 0 </span><span class="cov0" title="0">{
                        out.RawString("null")
                }</span> else<span class="cov0" title="0"> {
                        out.RawByte('[')
                        for v5, v6 := range in.Tag </span><span class="cov0" title="0">{
                                if v5 &gt; 0 </span><span class="cov0" title="0">{
                                        out.RawByte(',')
                                }</span>
                                <span class="cov0" title="0">out.String(string(v6))</span>
                        }
                        <span class="cov0" title="0">out.RawByte(']')</span>
                }
        }
        <span class="cov0" title="0">{
                const prefix string = ",\"event_start\":"
                out.RawString(prefix)
                out.String(string(in.EventStart))
        }</span>
        <span class="cov0" title="0">{
                const prefix string = ",\"event_end\":"
                out.RawString(prefix)
                out.String(string(in.EventEnd))
        }</span>
        <span class="cov0" title="0">{
                const prefix string = ",\"Latitude\":"
                out.RawString(prefix)
                out.Float64(float64(in.Latitude))
        }</span>
        <span class="cov0" title="0">{
                const prefix string = ",\"Longitude\":"
                out.RawString(prefix)
                out.Float64(float64(in.Longitude))
        }</span>
        <span class="cov0" title="0">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v NewEventRequest) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjsonF642ad3eEncodeKudagoInternalGatewayEvent2(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v NewEventRequest) MarshalEasyJSON(w *jwriter.Writer) <span class="cov0" title="0">{
        easyjsonF642ad3eEncodeKudagoInternalGatewayEvent2(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *NewEventRequest) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        r := jlexer.Lexer{Data: data}
        easyjsonF642ad3eDecodeKudagoInternalGatewayEvent2(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *NewEventRequest) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjsonF642ad3eDecodeKudagoInternalGatewayEvent2(l, v)
}</span>
func easyjsonF642ad3eDecodeKudagoInternalGatewayEvent3(in *jlexer.Lexer, out *InviteNotificationRequest) <span class="cov0" title="0">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov0" title="0">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov0" title="0">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov0" title="0">switch key </span>{
                case "user_id":<span class="cov0" title="0">
                        out.UserID = int(in.Int())</span>
                case "event_id":<span class="cov0" title="0">
                        out.EventID = int(in.Int())</span>
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov0" title="0">in.WantComma()</span>
        }
        <span class="cov0" title="0">in.Delim('}')
        if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjsonF642ad3eEncodeKudagoInternalGatewayEvent3(out *jwriter.Writer, in InviteNotificationRequest) <span class="cov0" title="0">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov0" title="0">{
                const prefix string = ",\"user_id\":"
                out.RawString(prefix[1:])
                out.Int(int(in.UserID))
        }</span>
        <span class="cov0" title="0">{
                const prefix string = ",\"event_id\":"
                out.RawString(prefix)
                out.Int(int(in.EventID))
        }</span>
        <span class="cov0" title="0">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v InviteNotificationRequest) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjsonF642ad3eEncodeKudagoInternalGatewayEvent3(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v InviteNotificationRequest) MarshalEasyJSON(w *jwriter.Writer) <span class="cov0" title="0">{
        easyjsonF642ad3eEncodeKudagoInternalGatewayEvent3(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *InviteNotificationRequest) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        r := jlexer.Lexer{Data: data}
        easyjsonF642ad3eDecodeKudagoInternalGatewayEvent3(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *InviteNotificationRequest) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjsonF642ad3eDecodeKudagoInternalGatewayEvent3(l, v)
}</span>
func easyjsonF642ad3eDecodeKudagoInternalGatewayEvent4(in *jlexer.Lexer, out *GetNotificationsResponse) <span class="cov8" title="1">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov8" title="1">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov8" title="1">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov8" title="1">switch key </span>{
                case "notifications":<span class="cov8" title="1">
                        if in.IsNull() </span><span class="cov0" title="0">{
                                in.Skip()
                                out.Notifications = nil
                        }</span> else<span class="cov8" title="1"> {
                                in.Delim('[')
                                if out.Notifications == nil </span><span class="cov8" title="1">{
                                        if !in.IsDelim(']') </span><span class="cov8" title="1">{
                                                out.Notifications = make([]NotificationWithEvent, 0, 0)
                                        }</span> else<span class="cov0" title="0"> {
                                                out.Notifications = []NotificationWithEvent{}
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        out.Notifications = (out.Notifications)[:0]
                                }</span>
                                <span class="cov8" title="1">for !in.IsDelim(']') </span><span class="cov8" title="1">{
                                        var v7 NotificationWithEvent
                                        (v7).UnmarshalEasyJSON(in)
                                        out.Notifications = append(out.Notifications, v7)
                                        in.WantComma()
                                }</span>
                                <span class="cov8" title="1">in.Delim(']')</span>
                        }
                default:<span class="cov8" title="1">
                        in.SkipRecursive()</span>
                }
                <span class="cov8" title="1">in.WantComma()</span>
        }
        <span class="cov8" title="1">in.Delim('}')
        if isTopLevel </span><span class="cov8" title="1">{
                in.Consumed()
        }</span>
}
func easyjsonF642ad3eEncodeKudagoInternalGatewayEvent4(out *jwriter.Writer, in GetNotificationsResponse) <span class="cov8" title="1">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov8" title="1">{
                const prefix string = ",\"notifications\":"
                out.RawString(prefix[1:])
                if in.Notifications == nil &amp;&amp; (out.Flags&amp;jwriter.NilSliceAsEmpty) == 0 </span><span class="cov0" title="0">{
                        out.RawString("null")
                }</span> else<span class="cov8" title="1"> {
                        out.RawByte('[')
                        for v8, v9 := range in.Notifications </span><span class="cov8" title="1">{
                                if v8 &gt; 0 </span><span class="cov0" title="0">{
                                        out.RawByte(',')
                                }</span>
                                <span class="cov8" title="1">(v9).MarshalEasyJSON(out)</span>
                        }
                        <span class="cov8" title="1">out.RawByte(']')</span>
                }
        }
        <span class="cov8" title="1">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v GetNotificationsResponse) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjsonF642ad3eEncodeKudagoInternalGatewayEvent4(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v GetNotificationsResponse) MarshalEasyJSON(w *jwriter.Writer) <span class="cov8" title="1">{
        easyjsonF642ad3eEncodeKudagoInternalGatewayEvent4(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *GetNotificationsResponse) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        r := jlexer.Lexer{Data: data}
        easyjsonF642ad3eDecodeKudagoInternalGatewayEvent4(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *GetNotificationsResponse) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjsonF642ad3eDecodeKudagoInternalGatewayEvent4(l, v)
}</span>
func easyjsonF642ad3eDecodeKudagoInternalGatewayEvent5(in *jlexer.Lexer, out *GetEventsResponse) <span class="cov8" title="1">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov8" title="1">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov8" title="1">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov8" title="1">switch key </span>{
                case "events":<span class="cov8" title="1">
                        if in.IsNull() </span><span class="cov0" title="0">{
                                in.Skip()
                                out.Events = nil
                        }</span> else<span class="cov8" title="1"> {
                                in.Delim('[')
                                if out.Events == nil </span><span class="cov8" title="1">{
                                        if !in.IsDelim(']') </span><span class="cov8" title="1">{
                                                out.Events = make([]EventResponse, 0, 0)
                                        }</span> else<span class="cov0" title="0"> {
                                                out.Events = []EventResponse{}
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        out.Events = (out.Events)[:0]
                                }</span>
                                <span class="cov8" title="1">for !in.IsDelim(']') </span><span class="cov8" title="1">{
                                        var v10 EventResponse
                                        (v10).UnmarshalEasyJSON(in)
                                        out.Events = append(out.Events, v10)
                                        in.WantComma()
                                }</span>
                                <span class="cov8" title="1">in.Delim(']')</span>
                        }
                default:<span class="cov8" title="1">
                        in.SkipRecursive()</span>
                }
                <span class="cov8" title="1">in.WantComma()</span>
        }
        <span class="cov8" title="1">in.Delim('}')
        if isTopLevel </span><span class="cov8" title="1">{
                in.Consumed()
        }</span>
}
func easyjsonF642ad3eEncodeKudagoInternalGatewayEvent5(out *jwriter.Writer, in GetEventsResponse) <span class="cov8" title="1">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov8" title="1">{
                const prefix string = ",\"events\":"
                out.RawString(prefix[1:])
                if in.Events == nil &amp;&amp; (out.Flags&amp;jwriter.NilSliceAsEmpty) == 0 </span><span class="cov0" title="0">{
                        out.RawString("null")
                }</span> else<span class="cov8" title="1"> {
                        out.RawByte('[')
                        for v11, v12 := range in.Events </span><span class="cov8" title="1">{
                                if v11 &gt; 0 </span><span class="cov0" title="0">{
                                        out.RawByte(',')
                                }</span>
                                <span class="cov8" title="1">(v12).MarshalEasyJSON(out)</span>
                        }
                        <span class="cov8" title="1">out.RawByte(']')</span>
                }
        }
        <span class="cov8" title="1">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v GetEventsResponse) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjsonF642ad3eEncodeKudagoInternalGatewayEvent5(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v GetEventsResponse) MarshalEasyJSON(w *jwriter.Writer) <span class="cov8" title="1">{
        easyjsonF642ad3eEncodeKudagoInternalGatewayEvent5(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *GetEventsResponse) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        r := jlexer.Lexer{Data: data}
        easyjsonF642ad3eDecodeKudagoInternalGatewayEvent5(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *GetEventsResponse) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjsonF642ad3eDecodeKudagoInternalGatewayEvent5(l, v)
}</span>
func easyjsonF642ad3eDecodeKudagoInternalGatewayEvent6(in *jlexer.Lexer, out *GetCategoriesResponse) <span class="cov8" title="1">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov8" title="1">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov8" title="1">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov8" title="1">switch key </span>{
                case "categories":<span class="cov8" title="1">
                        if in.IsNull() </span><span class="cov0" title="0">{
                                in.Skip()
                                out.Categories = nil
                        }</span> else<span class="cov8" title="1"> {
                                in.Delim('[')
                                if out.Categories == nil </span><span class="cov8" title="1">{
                                        if !in.IsDelim(']') </span><span class="cov8" title="1">{
                                                out.Categories = make([]models.Category, 0, 2)
                                        }</span> else<span class="cov0" title="0"> {
                                                out.Categories = []models.Category{}
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        out.Categories = (out.Categories)[:0]
                                }</span>
                                <span class="cov8" title="1">for !in.IsDelim(']') </span><span class="cov8" title="1">{
                                        var v13 models.Category
                                        easyjsonF642ad3eDecodeKudagoInternalModels1(in, &amp;v13)
                                        out.Categories = append(out.Categories, v13)
                                        in.WantComma()
                                }</span>
                                <span class="cov8" title="1">in.Delim(']')</span>
                        }
                default:<span class="cov8" title="1">
                        in.SkipRecursive()</span>
                }
                <span class="cov8" title="1">in.WantComma()</span>
        }
        <span class="cov8" title="1">in.Delim('}')
        if isTopLevel </span><span class="cov8" title="1">{
                in.Consumed()
        }</span>
}
func easyjsonF642ad3eEncodeKudagoInternalGatewayEvent6(out *jwriter.Writer, in GetCategoriesResponse) <span class="cov8" title="1">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov8" title="1">{
                const prefix string = ",\"categories\":"
                out.RawString(prefix[1:])
                if in.Categories == nil &amp;&amp; (out.Flags&amp;jwriter.NilSliceAsEmpty) == 0 </span><span class="cov0" title="0">{
                        out.RawString("null")
                }</span> else<span class="cov8" title="1"> {
                        out.RawByte('[')
                        for v14, v15 := range in.Categories </span><span class="cov8" title="1">{
                                if v14 &gt; 0 </span><span class="cov0" title="0">{
                                        out.RawByte(',')
                                }</span>
                                <span class="cov8" title="1">easyjsonF642ad3eEncodeKudagoInternalModels1(out, v15)</span>
                        }
                        <span class="cov8" title="1">out.RawByte(']')</span>
                }
        }
        <span class="cov8" title="1">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v GetCategoriesResponse) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjsonF642ad3eEncodeKudagoInternalGatewayEvent6(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v GetCategoriesResponse) MarshalEasyJSON(w *jwriter.Writer) <span class="cov8" title="1">{
        easyjsonF642ad3eEncodeKudagoInternalGatewayEvent6(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *GetCategoriesResponse) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        r := jlexer.Lexer{Data: data}
        easyjsonF642ad3eDecodeKudagoInternalGatewayEvent6(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *GetCategoriesResponse) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjsonF642ad3eDecodeKudagoInternalGatewayEvent6(l, v)
}</span>
func easyjsonF642ad3eDecodeKudagoInternalModels1(in *jlexer.Lexer, out *models.Category) <span class="cov8" title="1">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov8" title="1">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov8" title="1">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov8" title="1">switch key </span>{
                case "id":<span class="cov8" title="1">
                        out.ID = int(in.Int())</span>
                case "name":<span class="cov8" title="1">
                        out.Name = string(in.String())</span>
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov8" title="1">in.WantComma()</span>
        }
        <span class="cov8" title="1">in.Delim('}')
        if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjsonF642ad3eEncodeKudagoInternalModels1(out *jwriter.Writer, in models.Category) <span class="cov8" title="1">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov8" title="1">{
                const prefix string = ",\"id\":"
                out.RawString(prefix[1:])
                out.Int(int(in.ID))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"name\":"
                out.RawString(prefix)
                out.String(string(in.Name))
        }</span>
        <span class="cov8" title="1">out.RawByte('}')</span>
}
func easyjsonF642ad3eDecodeKudagoInternalGatewayEvent7(in *jlexer.Lexer, out *EventResponse) <span class="cov8" title="1">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov8" title="1">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov8" title="1">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov8" title="1">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov8" title="1">switch key </span>{
                case "id":<span class="cov8" title="1">
                        out.ID = int(in.Int())</span>
                case "title":<span class="cov8" title="1">
                        out.Title = string(in.String())</span>
                case "description":<span class="cov8" title="1">
                        out.Description = string(in.String())</span>
                case "location":<span class="cov8" title="1">
                        out.Location = string(in.String())</span>
                case "category_id":<span class="cov8" title="1">
                        out.Category = int(in.Int())</span>
                case "capacity":<span class="cov8" title="1">
                        out.Capacity = int(in.Int())</span>
                case "tag":<span class="cov0" title="0">
                        if in.IsNull() </span><span class="cov0" title="0">{
                                in.Skip()
                                out.Tag = nil
                        }</span> else<span class="cov0" title="0"> {
                                in.Delim('[')
                                if out.Tag == nil </span><span class="cov0" title="0">{
                                        if !in.IsDelim(']') </span><span class="cov0" title="0">{
                                                out.Tag = make([]string, 0, 4)
                                        }</span> else<span class="cov0" title="0"> {
                                                out.Tag = []string{}
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        out.Tag = (out.Tag)[:0]
                                }</span>
                                <span class="cov0" title="0">for !in.IsDelim(']') </span><span class="cov0" title="0">{
                                        var v16 string
                                        v16 = string(in.String())
                                        out.Tag = append(out.Tag, v16)
                                        in.WantComma()
                                }</span>
                                <span class="cov0" title="0">in.Delim(']')</span>
                        }
                case "author":<span class="cov8" title="1">
                        out.AuthorID = int(in.Int())</span>
                case "event_start":<span class="cov8" title="1">
                        out.EventStart = string(in.String())</span>
                case "event_end":<span class="cov8" title="1">
                        out.EventEnd = string(in.String())</span>
                case "image":<span class="cov8" title="1">
                        out.ImageURL = string(in.String())</span>
                case "Latitude":<span class="cov8" title="1">
                        out.Latitude = float64(in.Float64())</span>
                case "Longitude":<span class="cov8" title="1">
                        out.Longitude = float64(in.Float64())</span>
                default:<span class="cov8" title="1">
                        in.SkipRecursive()</span>
                }
                <span class="cov8" title="1">in.WantComma()</span>
        }
        <span class="cov8" title="1">in.Delim('}')
        if isTopLevel </span><span class="cov8" title="1">{
                in.Consumed()
        }</span>
}
func easyjsonF642ad3eEncodeKudagoInternalGatewayEvent7(out *jwriter.Writer, in EventResponse) <span class="cov8" title="1">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov8" title="1">{
                const prefix string = ",\"id\":"
                out.RawString(prefix[1:])
                out.Int(int(in.ID))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"title\":"
                out.RawString(prefix)
                out.String(string(in.Title))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"description\":"
                out.RawString(prefix)
                out.String(string(in.Description))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"location\":"
                out.RawString(prefix)
                out.String(string(in.Location))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"category_id\":"
                out.RawString(prefix)
                out.Int(int(in.Category))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"capacity\":"
                out.RawString(prefix)
                out.Int(int(in.Capacity))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"tag\":"
                out.RawString(prefix)
                if in.Tag == nil &amp;&amp; (out.Flags&amp;jwriter.NilSliceAsEmpty) == 0 </span><span class="cov8" title="1">{
                        out.RawString("null")
                }</span> else<span class="cov0" title="0"> {
                        out.RawByte('[')
                        for v17, v18 := range in.Tag </span><span class="cov0" title="0">{
                                if v17 &gt; 0 </span><span class="cov0" title="0">{
                                        out.RawByte(',')
                                }</span>
                                <span class="cov0" title="0">out.String(string(v18))</span>
                        }
                        <span class="cov0" title="0">out.RawByte(']')</span>
                }
        }
        <span class="cov8" title="1">{
                const prefix string = ",\"author\":"
                out.RawString(prefix)
                out.Int(int(in.AuthorID))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"event_start\":"
                out.RawString(prefix)
                out.String(string(in.EventStart))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"event_end\":"
                out.RawString(prefix)
                out.String(string(in.EventEnd))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"image\":"
                out.RawString(prefix)
                out.String(string(in.ImageURL))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"Latitude\":"
                out.RawString(prefix)
                out.Float64(float64(in.Latitude))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"Longitude\":"
                out.RawString(prefix)
                out.Float64(float64(in.Longitude))
        }</span>
        <span class="cov8" title="1">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v EventResponse) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjsonF642ad3eEncodeKudagoInternalGatewayEvent7(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v EventResponse) MarshalEasyJSON(w *jwriter.Writer) <span class="cov8" title="1">{
        easyjsonF642ad3eEncodeKudagoInternalGatewayEvent7(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *EventResponse) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        r := jlexer.Lexer{Data: data}
        easyjsonF642ad3eDecodeKudagoInternalGatewayEvent7(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *EventResponse) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov8" title="1">{
        easyjsonF642ad3eDecodeKudagoInternalGatewayEvent7(l, v)
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">package events

import (
        "net/http"

        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"
        "kudago/internal/models"
)

// @Summary Получить все категории
// @Description Получить список всех доступных категорий событий
// @Tags categories
// @Accept  json
// @Produce  json
// @Success 200 {array} models.Category "Список категорий"
// @Failure 500 {object} httpErrors.HttpError "Internal Server Error"
// @Router /categories [get]
func (h EventHandler) GetCategories(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        categories, err := h.EventService.GetCategories(r.Context(), nil)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error(r.Context(), "get categories", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return
        }</span>

        <span class="cov8" title="1">convertedCategories := make([]models.Category, 0, len(categories.Categories))
        for _, cat := range categories.Categories </span><span class="cov8" title="1">{
                convertedCategories = append(convertedCategories, models.Category{
                        ID:   int(cat.ID),
                        Name: cat.Name,
                })
        }</span>

        <span class="cov8" title="1">resp := GetCategoriesResponse{
                Categories: convertedCategories,
        }
        utils.WriteResponse(w, http.StatusOK, resp)</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package events

import (
        "net/http"
        "strconv"

        pb "kudago/internal/event/api"
        httpErrors "kudago/internal/gateway/errors"

        "kudago/internal/gateway/utils"

        "github.com/gorilla/mux"
        grpcCodes "google.golang.org/grpc/codes"
        grpcStatus "google.golang.org/grpc/status"
)

// @Summary Получение события по ID
// @Description Возвращает информацию о событии по его идентификатору
// @Tags events
// @Produce  json
// @Success 200 {object} EventResponse
// @Failure 404 {object} httpErrors.HttpError "Event Not Found"
// @Failure 500 {object} httpErrors.HttpError "Internal Server Error"
// @Router /events/{id} [get]
func (h EventHandler) GetEventByID(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">event, err := h.EventService.GetEventByID(r.Context(), &amp;pb.GetEventByIDRequest{ID: int32(id)})
        if err != nil </span><span class="cov8" title="1">{
                st, ok := grpcStatus.FromError(err)
                if ok </span><span class="cov8" title="1">{
                        switch st.Code() </span>{
                        case grpcCodes.NotFound:<span class="cov8" title="1">
                                utils.WriteResponse(w, http.StatusNotFound, httpErrors.ErrEventNotFound)
                                return</span>
                        }
                }

                <span class="cov8" title="1">h.logger.Error(r.Context(), "get event by id", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return</span>
        }

        <span class="cov8" title="1">resp := eventToEventResponse(event)
        utils.WriteResponse(w, http.StatusOK, resp)</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package events

import (
        "net/http"
        "strconv"

        pb "kudago/internal/event/api"
        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"

        "github.com/gorilla/mux"
        grpcCodes "google.golang.org/grpc/codes"
        grpcStatus "google.golang.org/grpc/status"
)

// @Summary Получение событий по категори
// @Description Возвращает события по ID категории
// @Tags events
// @Produce  json
// @Success 200 {object} GetEventsResponse
// @Failure 500 {object} httpErrors.HttpError "Internal Server Error"
// @Router /events/categories/{category} [get]
func (h EventHandler) GetEventsByCategory(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        paginationParams := GetPaginationParams(r)
        vars := mux.Vars(r)
        category := vars["category"]
        categoryID, err := strconv.Atoi(category)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error(r.Context(), "getEventsByCategory", err)
                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidCategory)
                return
        }</span>

        <span class="cov8" title="1">req := &amp;pb.GetEventsByCategoryRequest{
                CategoryID: int32(categoryID),
                Params:     paginationParams,
        }

        events, err := h.EventService.GetEventsByCategory(r.Context(), req)
        if err != nil </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        st, ok := grpcStatus.FromError(err)
                        if ok </span><span class="cov8" title="1">{
                                switch st.Code() </span>{
                                case grpcCodes.InvalidArgument:<span class="cov0" title="0">
                                        utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidCategory)
                                        return</span>
                                }
                        }

                        <span class="cov8" title="1">h.logger.Error(r.Context(), "get events by category", err)
                        utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                        return</span>
                }
        }

        <span class="cov8" title="1">resp := writeEventsResponse(events.Events, int(paginationParams.Limit))

        utils.WriteResponse(w, http.StatusOK, resp)</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package events

import (
        "context"

        pb "kudago/internal/event/api"
        "kudago/internal/models"
)

func (h EventHandler) getEventsByIDs(ctx context.Context, ids []int) (map[int]models.Event, error) <span class="cov8" title="1">{
        req := &amp;pb.GetEventsByIDsRequest{
                IDs: make([]int32, 0, len(ids)),
        }

        for _, id := range ids </span><span class="cov8" title="1">{
                req.IDs = append(req.IDs, int32(id))
        }</span>

        <span class="cov8" title="1">resp, err := h.EventService.GetEventsByIDs(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">eventMap := make(map[int]models.Event, len(resp.Events))
        for _, e := range resp.Events </span><span class="cov8" title="1">{
                eventMap[int(e.ID)] = models.Event{
                        ID:          int(e.ID),
                        Title:       e.Title,
                        Description: e.Description,
                        EventStart:  e.EventStart,
                        EventEnd:    e.EventEnd,
                        ImageURL:    e.Image,
                        Location:    e.Location,
                        Latitude:    e.Latitude,
                        Capacity:    int(e.Capacity),
                        CategoryID:  int(e.CategoryID),
                        AuthorID:    int(e.AuthorID),
                        Tag:         e.Tag,
                }
        }</span>

        <span class="cov8" title="1">return eventMap, nil</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package events

import (
        "net/http"
        "strconv"

        pb "kudago/internal/event/api"
        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"

        "github.com/gorilla/mux"
)

// @Summary Получение событий пользователя
// @Description Возвращает события пользователя
// @Tags events
// @Produce  json
// @Success 200 {object} GetEventsResponse
// @Failure 500 {object} httpErrors.HttpError "Internal Server Error"
// @Router /events/user/{id} [get]
func (h EventHandler) GetEventsByUser(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        paginationParams := GetPaginationParams(r)

        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">req := &amp;pb.GetEventsByUserRequest{
                UserID: int32(id),
                Params: paginationParams,
        }

        events, err := h.EventService.GetEventsByUser(r.Context(), req)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error(r.Context(), "get events by user", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return
        }</span>

        <span class="cov8" title="1">resp := writeEventsResponse(events.Events, int(paginationParams.Limit))

        utils.WriteResponse(w, http.StatusOK, resp)</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package events

import (
        "net/http"

        pb "kudago/internal/event/api"
        httpErrors "kudago/internal/gateway/errors"

        "kudago/internal/gateway/utils"
)

// @Summary Получение избранных событий
// @Description Возвращает избранные события
// @Tags events
// @Produce  json
// @Param page query int false "Номер страницы (по умолчанию 1)"
// @Param limit query int false "Количество событий на странице (по умолчанию 30)"
// @Success 200 {object} GetEventsResponse
// @Failure 401 {object} httpErrors.HttpError "Unauthorized"
// @Failure 500 {object} httpErrors.HttpError "Internal Server Error"
// @Router /events/favorites [get]
func (h EventHandler) GetFavorites(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        paginationParams := GetPaginationParams(r)

        session, ok := utils.GetSessionFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusForbidden, httpErrors.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">req := &amp;pb.GetFavoritesRequest{
                UserID: int32(session.UserID),
                Params: paginationParams,
        }

        events, err := h.EventService.GetFavorites(r.Context(), req)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error(r.Context(), "getFavorites", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return
        }</span>

        <span class="cov8" title="1">resp := writeEventsResponse(events.Events, int(paginationParams.Limit))

        utils.WriteResponse(w, http.StatusOK, resp)</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package events

import (
        "net/http"
        "time"

        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"
        "kudago/internal/models"
        pb "kudago/internal/notification/api"
)

// @Summary Получение уведомлений по ID пользователя
// @Description Возвращает уведомления по идентификатору пользователя
// @Tags notifications
// @Produce  json
// @Success 200 {object} GetNotificationsResponse
// @Failure 404 {object} httpErrors.HttpError "Notification Not Found"
// @Failure 500 {object} httpErrors.HttpError "Internal Server Error"
// @Router /notifications [get]
func (h EventHandler) GetNotifications(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        session, ok := utils.GetSessionFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusForbidden, httpErrors.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">req := &amp;pb.GetNotificationsRequest{UserID: int32(session.UserID)}
        notifications, err := h.NotificationService.GetNotifications(r.Context(), req)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error(r.Context(), "get notifications", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return
        }</span>

        <span class="cov8" title="1">ids := make([]int, 0, len(notifications.Notifications))
        for _, n := range notifications.Notifications </span><span class="cov8" title="1">{
                ids = append(ids, int(n.EventID))
        }</span>

        <span class="cov8" title="1">events, err := h.getEventsByIDs(r.Context(), ids)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(r.Context(), "get events by ids", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return
        }</span>

        <span class="cov8" title="1">resp := writeNotificationsResponse(notifications.Notifications, events)
        utils.WriteResponse(w, http.StatusOK, resp)</span>
}

func writeNotificationsResponse(notifications []*pb.Notification, events map[int]models.Event) GetNotificationsResponse <span class="cov8" title="1">{
        layout := "2006-01-02 15:04:05 -0700 MST"

        response := GetNotificationsResponse{
                Notifications: make([]NotificationWithEvent, 0, len(notifications)),
        }

        for _, n := range notifications </span><span class="cov8" title="1">{
                notifyAt, _ := time.Parse(layout, n.NotifyAt)
                event, ok := events[int(n.EventID)]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">response.Notifications = append(response.Notifications, NotificationWithEvent{
                        Notification: models.Notification{
                                ID:       int(n.Id),
                                UserID:   int(n.UserID),
                                EventID:  int(n.EventID),
                                Message:  n.Message,
                                NotifyAt: notifyAt,
                        },
                        Event: event,
                })</span>
        }

        <span class="cov8" title="1">return response</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package events

import (
        "net/http"

        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"
)

// @Summary Получить все прошедшие события
// @Description Получить все прошедшие события
// @Tags events
// @Accept  json
// @Produce  json
// @Param page query int false "Номер страницы (по умолчанию 1)"
// @Param limit query int false "Количество событий на странице (по умолчанию 30)"
// @Success 200 {object} GetEventsResponse
// @Failure 500 {object} httpErrors.HttpError "Internal Server Error"
// @Router /events [get]
func (h EventHandler) GetPastEvents(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        paginationParams := GetPaginationParams(r)

        events, err := h.EventService.GetPastEvents(r.Context(), paginationParams)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error(r.Context(), "getPastEvents", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return
        }</span>
        <span class="cov8" title="1">resp := writeEventsResponse(events.Events, int(paginationParams.Limit))

        utils.WriteResponse(w, http.StatusOK, resp)</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package events

import (
        "net/http"

        pb "kudago/internal/event/api"
        httpErrors "kudago/internal/gateway/errors"

        "kudago/internal/gateway/utils"
)

// @Summary Получение событий по подпискам пользователя
// @Description Возвращает события пользователя
// @Tags events
// @Produce  json
// @Success 200 {object} GetEventsResponse
// @Failure 403 {object} httpErrors.HttpError "Status forbidden"
// @Failure 500 {object} httpErrors.HttpError "Internal Server Error"
// @Router /events/subscription [get]
func (h *EventHandler) GetSubscriptionEvents(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        paginationParams := GetPaginationParams(r)

        session, ok := utils.GetSessionFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                utils.WriteResponse(w, http.StatusForbidden, httpErrors.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">req := &amp;pb.GetSubscriptionsRequest{
                ID:     int32(session.UserID),
                Params: paginationParams,
        }

        events, err := h.EventService.GetSubscriptionsEvents(r.Context(), req)
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return
        }</span>

        <span class="cov8" title="1">resp := writeEventsResponse(events.Events, int(paginationParams.Limit))

        utils.WriteResponse(w, http.StatusOK, resp)</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">package events

import (
        "net/http"

        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"
)

// @Summary Получить все грядущие события
// @Description Получить все грядущие события
// @Tags events
// @Accept  json
// @Produce  json
// @Param page query int false "Номер страницы (по умолчанию 1)"
// @Param limit query int false "Количество событий на странице (по умолчанию 30)"
// @Success 200 {object} GetEventsResponse
// @Failure 500 {object} httpErrors.HttpError "Internal Server Error"
// @Router /events [get]
func (h EventHandler) GetUpcomingEvents(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        paginationParams := GetPaginationParams(r)
        events, err := h.EventService.GetUpcomingEvents(r.Context(), paginationParams)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error(r.Context(), "getUpcomingEvents", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return
        }</span>
        <span class="cov8" title="1">resp := writeEventsResponse(events.Events, int(paginationParams.Limit))

        utils.WriteResponse(w, http.StatusOK, resp)</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ../../event/api/event_grpc.pb.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        event "kudago/internal/event/api"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        grpc "google.golang.org/grpc"
)

// MockEventServiceClient is a mock of EventServiceClient interface.
type MockEventServiceClient struct {
        ctrl     *gomock.Controller
        recorder *MockEventServiceClientMockRecorder
}

// MockEventServiceClientMockRecorder is the mock recorder for MockEventServiceClient.
type MockEventServiceClientMockRecorder struct {
        mock *MockEventServiceClient
}

// NewMockEventServiceClient creates a new mock instance.
func NewMockEventServiceClient(ctrl *gomock.Controller) *MockEventServiceClient <span class="cov8" title="1">{
        mock := &amp;MockEventServiceClient{ctrl: ctrl}
        mock.recorder = &amp;MockEventServiceClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventServiceClient) EXPECT() *MockEventServiceClientMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AddEvent mocks base method.
func (m *MockEventServiceClient) AddEvent(ctx context.Context, in *event.Event, opts ...grpc.CallOption) (*event.Event, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "AddEvent", varargs...)
        ret0, _ := ret[0].(*event.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// AddEvent indicates an expected call of AddEvent.
func (mr *MockEventServiceClientMockRecorder) AddEvent(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddEvent", reflect.TypeOf((*MockEventServiceClient)(nil).AddEvent), varargs...)
}</span>

// AddEventToFavorites mocks base method.
func (m *MockEventServiceClient) AddEventToFavorites(ctx context.Context, in *event.FavoriteEvent, opts ...grpc.CallOption) (*event.Empty, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "AddEventToFavorites", varargs...)
        ret0, _ := ret[0].(*event.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// AddEventToFavorites indicates an expected call of AddEventToFavorites.
func (mr *MockEventServiceClientMockRecorder) AddEventToFavorites(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddEventToFavorites", reflect.TypeOf((*MockEventServiceClient)(nil).AddEventToFavorites), varargs...)
}</span>

// DeleteEvent mocks base method.
func (m *MockEventServiceClient) DeleteEvent(ctx context.Context, in *event.DeleteEventRequest, opts ...grpc.CallOption) (*event.Empty, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "DeleteEvent", varargs...)
        ret0, _ := ret[0].(*event.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DeleteEvent indicates an expected call of DeleteEvent.
func (mr *MockEventServiceClientMockRecorder) DeleteEvent(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteEvent", reflect.TypeOf((*MockEventServiceClient)(nil).DeleteEvent), varargs...)
}</span>

// DeleteEventFromFavorites mocks base method.
func (m *MockEventServiceClient) DeleteEventFromFavorites(ctx context.Context, in *event.FavoriteEvent, opts ...grpc.CallOption) (*event.Empty, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "DeleteEventFromFavorites", varargs...)
        ret0, _ := ret[0].(*event.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DeleteEventFromFavorites indicates an expected call of DeleteEventFromFavorites.
func (mr *MockEventServiceClientMockRecorder) DeleteEventFromFavorites(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteEventFromFavorites", reflect.TypeOf((*MockEventServiceClient)(nil).DeleteEventFromFavorites), varargs...)
}</span>

// GetCategories mocks base method.
func (m *MockEventServiceClient) GetCategories(ctx context.Context, in *event.Empty, opts ...grpc.CallOption) (*event.GetCategoriesResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetCategories", varargs...)
        ret0, _ := ret[0].(*event.GetCategoriesResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetCategories indicates an expected call of GetCategories.
func (mr *MockEventServiceClientMockRecorder) GetCategories(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCategories", reflect.TypeOf((*MockEventServiceClient)(nil).GetCategories), varargs...)
}</span>

// GetEventByID mocks base method.
func (m *MockEventServiceClient) GetEventByID(ctx context.Context, in *event.GetEventByIDRequest, opts ...grpc.CallOption) (*event.Event, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetEventByID", varargs...)
        ret0, _ := ret[0].(*event.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetEventByID indicates an expected call of GetEventByID.
func (mr *MockEventServiceClientMockRecorder) GetEventByID(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEventByID", reflect.TypeOf((*MockEventServiceClient)(nil).GetEventByID), varargs...)
}</span>

// GetEventsByCategory mocks base method.
func (m *MockEventServiceClient) GetEventsByCategory(ctx context.Context, in *event.GetEventsByCategoryRequest, opts ...grpc.CallOption) (*event.Events, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetEventsByCategory", varargs...)
        ret0, _ := ret[0].(*event.Events)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetEventsByCategory indicates an expected call of GetEventsByCategory.
func (mr *MockEventServiceClientMockRecorder) GetEventsByCategory(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEventsByCategory", reflect.TypeOf((*MockEventServiceClient)(nil).GetEventsByCategory), varargs...)
}</span>

// GetEventsByIDs mocks base method.
func (m *MockEventServiceClient) GetEventsByIDs(ctx context.Context, in *event.GetEventsByIDsRequest, opts ...grpc.CallOption) (*event.Events, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetEventsByIDs", varargs...)
        ret0, _ := ret[0].(*event.Events)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetEventsByIDs indicates an expected call of GetEventsByIDs.
func (mr *MockEventServiceClientMockRecorder) GetEventsByIDs(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEventsByIDs", reflect.TypeOf((*MockEventServiceClient)(nil).GetEventsByIDs), varargs...)
}</span>

// GetEventsByUser mocks base method.
func (m *MockEventServiceClient) GetEventsByUser(ctx context.Context, in *event.GetEventsByUserRequest, opts ...grpc.CallOption) (*event.Events, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetEventsByUser", varargs...)
        ret0, _ := ret[0].(*event.Events)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetEventsByUser indicates an expected call of GetEventsByUser.
func (mr *MockEventServiceClientMockRecorder) GetEventsByUser(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEventsByUser", reflect.TypeOf((*MockEventServiceClient)(nil).GetEventsByUser), varargs...)
}</span>

// GetFavorites mocks base method.
func (m *MockEventServiceClient) GetFavorites(ctx context.Context, in *event.GetFavoritesRequest, opts ...grpc.CallOption) (*event.Events, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetFavorites", varargs...)
        ret0, _ := ret[0].(*event.Events)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetFavorites indicates an expected call of GetFavorites.
func (mr *MockEventServiceClientMockRecorder) GetFavorites(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFavorites", reflect.TypeOf((*MockEventServiceClient)(nil).GetFavorites), varargs...)
}</span>

// GetPastEvents mocks base method.
func (m *MockEventServiceClient) GetPastEvents(ctx context.Context, in *event.PaginationParams, opts ...grpc.CallOption) (*event.Events, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetPastEvents", varargs...)
        ret0, _ := ret[0].(*event.Events)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetPastEvents indicates an expected call of GetPastEvents.
func (mr *MockEventServiceClientMockRecorder) GetPastEvents(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPastEvents", reflect.TypeOf((*MockEventServiceClient)(nil).GetPastEvents), varargs...)
}</span>

// GetSubscribersIDs mocks base method.
func (m *MockEventServiceClient) GetSubscribersIDs(ctx context.Context, in *event.GetSubscribersIDsRequest, opts ...grpc.CallOption) (*event.GetUserIDsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetSubscribersIDs", varargs...)
        ret0, _ := ret[0].(*event.GetUserIDsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetSubscribersIDs indicates an expected call of GetSubscribersIDs.
func (mr *MockEventServiceClientMockRecorder) GetSubscribersIDs(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubscribersIDs", reflect.TypeOf((*MockEventServiceClient)(nil).GetSubscribersIDs), varargs...)
}</span>

// GetSubscriptionsEvents mocks base method.
func (m *MockEventServiceClient) GetSubscriptionsEvents(ctx context.Context, in *event.GetSubscriptionsRequest, opts ...grpc.CallOption) (*event.Events, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetSubscriptionsEvents", varargs...)
        ret0, _ := ret[0].(*event.Events)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetSubscriptionsEvents indicates an expected call of GetSubscriptionsEvents.
func (mr *MockEventServiceClientMockRecorder) GetSubscriptionsEvents(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubscriptionsEvents", reflect.TypeOf((*MockEventServiceClient)(nil).GetSubscriptionsEvents), varargs...)
}</span>

// GetUpcomingEvents mocks base method.
func (m *MockEventServiceClient) GetUpcomingEvents(ctx context.Context, in *event.PaginationParams, opts ...grpc.CallOption) (*event.Events, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetUpcomingEvents", varargs...)
        ret0, _ := ret[0].(*event.Events)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetUpcomingEvents indicates an expected call of GetUpcomingEvents.
func (mr *MockEventServiceClientMockRecorder) GetUpcomingEvents(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUpcomingEvents", reflect.TypeOf((*MockEventServiceClient)(nil).GetUpcomingEvents), varargs...)
}</span>

// GetUserIDsByFavoriteEvent mocks base method.
func (m *MockEventServiceClient) GetUserIDsByFavoriteEvent(ctx context.Context, in *event.GetUserIDsByFavoriteEventRequest, opts ...grpc.CallOption) (*event.GetUserIDsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetUserIDsByFavoriteEvent", varargs...)
        ret0, _ := ret[0].(*event.GetUserIDsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetUserIDsByFavoriteEvent indicates an expected call of GetUserIDsByFavoriteEvent.
func (mr *MockEventServiceClientMockRecorder) GetUserIDsByFavoriteEvent(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserIDsByFavoriteEvent", reflect.TypeOf((*MockEventServiceClient)(nil).GetUserIDsByFavoriteEvent), varargs...)
}</span>

// SearchEvents mocks base method.
func (m *MockEventServiceClient) SearchEvents(ctx context.Context, in *event.SearchParams, opts ...grpc.CallOption) (*event.Events, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "SearchEvents", varargs...)
        ret0, _ := ret[0].(*event.Events)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// SearchEvents indicates an expected call of SearchEvents.
func (mr *MockEventServiceClientMockRecorder) SearchEvents(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchEvents", reflect.TypeOf((*MockEventServiceClient)(nil).SearchEvents), varargs...)
}</span>

// UpdateEvent mocks base method.
func (m *MockEventServiceClient) UpdateEvent(ctx context.Context, in *event.Event, opts ...grpc.CallOption) (*event.Event, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "UpdateEvent", varargs...)
        ret0, _ := ret[0].(*event.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// UpdateEvent indicates an expected call of UpdateEvent.
func (mr *MockEventServiceClientMockRecorder) UpdateEvent(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateEvent", reflect.TypeOf((*MockEventServiceClient)(nil).UpdateEvent), varargs...)
}</span>

// MockEventServiceServer is a mock of EventServiceServer interface.
type MockEventServiceServer struct {
        ctrl     *gomock.Controller
        recorder *MockEventServiceServerMockRecorder
}

// MockEventServiceServerMockRecorder is the mock recorder for MockEventServiceServer.
type MockEventServiceServerMockRecorder struct {
        mock *MockEventServiceServer
}

// NewMockEventServiceServer creates a new mock instance.
func NewMockEventServiceServer(ctrl *gomock.Controller) *MockEventServiceServer <span class="cov0" title="0">{
        mock := &amp;MockEventServiceServer{ctrl: ctrl}
        mock.recorder = &amp;MockEventServiceServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventServiceServer) EXPECT() *MockEventServiceServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AddEvent mocks base method.
func (m *MockEventServiceServer) AddEvent(arg0 context.Context, arg1 *event.Event) (*event.Event, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddEvent", arg0, arg1)
        ret0, _ := ret[0].(*event.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AddEvent indicates an expected call of AddEvent.
func (mr *MockEventServiceServerMockRecorder) AddEvent(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddEvent", reflect.TypeOf((*MockEventServiceServer)(nil).AddEvent), arg0, arg1)
}</span>

// AddEventToFavorites mocks base method.
func (m *MockEventServiceServer) AddEventToFavorites(arg0 context.Context, arg1 *event.FavoriteEvent) (*event.Empty, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddEventToFavorites", arg0, arg1)
        ret0, _ := ret[0].(*event.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AddEventToFavorites indicates an expected call of AddEventToFavorites.
func (mr *MockEventServiceServerMockRecorder) AddEventToFavorites(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddEventToFavorites", reflect.TypeOf((*MockEventServiceServer)(nil).AddEventToFavorites), arg0, arg1)
}</span>

// DeleteEvent mocks base method.
func (m *MockEventServiceServer) DeleteEvent(arg0 context.Context, arg1 *event.DeleteEventRequest) (*event.Empty, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteEvent", arg0, arg1)
        ret0, _ := ret[0].(*event.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteEvent indicates an expected call of DeleteEvent.
func (mr *MockEventServiceServerMockRecorder) DeleteEvent(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteEvent", reflect.TypeOf((*MockEventServiceServer)(nil).DeleteEvent), arg0, arg1)
}</span>

// DeleteEventFromFavorites mocks base method.
func (m *MockEventServiceServer) DeleteEventFromFavorites(arg0 context.Context, arg1 *event.FavoriteEvent) (*event.Empty, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteEventFromFavorites", arg0, arg1)
        ret0, _ := ret[0].(*event.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteEventFromFavorites indicates an expected call of DeleteEventFromFavorites.
func (mr *MockEventServiceServerMockRecorder) DeleteEventFromFavorites(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteEventFromFavorites", reflect.TypeOf((*MockEventServiceServer)(nil).DeleteEventFromFavorites), arg0, arg1)
}</span>

// GetCategories mocks base method.
func (m *MockEventServiceServer) GetCategories(arg0 context.Context, arg1 *event.Empty) (*event.GetCategoriesResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCategories", arg0, arg1)
        ret0, _ := ret[0].(*event.GetCategoriesResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCategories indicates an expected call of GetCategories.
func (mr *MockEventServiceServerMockRecorder) GetCategories(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCategories", reflect.TypeOf((*MockEventServiceServer)(nil).GetCategories), arg0, arg1)
}</span>

// GetEventByID mocks base method.
func (m *MockEventServiceServer) GetEventByID(arg0 context.Context, arg1 *event.GetEventByIDRequest) (*event.Event, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetEventByID", arg0, arg1)
        ret0, _ := ret[0].(*event.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetEventByID indicates an expected call of GetEventByID.
func (mr *MockEventServiceServerMockRecorder) GetEventByID(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEventByID", reflect.TypeOf((*MockEventServiceServer)(nil).GetEventByID), arg0, arg1)
}</span>

// GetEventsByCategory mocks base method.
func (m *MockEventServiceServer) GetEventsByCategory(arg0 context.Context, arg1 *event.GetEventsByCategoryRequest) (*event.Events, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetEventsByCategory", arg0, arg1)
        ret0, _ := ret[0].(*event.Events)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetEventsByCategory indicates an expected call of GetEventsByCategory.
func (mr *MockEventServiceServerMockRecorder) GetEventsByCategory(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEventsByCategory", reflect.TypeOf((*MockEventServiceServer)(nil).GetEventsByCategory), arg0, arg1)
}</span>

// GetEventsByIDs mocks base method.
func (m *MockEventServiceServer) GetEventsByIDs(arg0 context.Context, arg1 *event.GetEventsByIDsRequest) (*event.Events, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetEventsByIDs", arg0, arg1)
        ret0, _ := ret[0].(*event.Events)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetEventsByIDs indicates an expected call of GetEventsByIDs.
func (mr *MockEventServiceServerMockRecorder) GetEventsByIDs(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEventsByIDs", reflect.TypeOf((*MockEventServiceServer)(nil).GetEventsByIDs), arg0, arg1)
}</span>

// GetEventsByUser mocks base method.
func (m *MockEventServiceServer) GetEventsByUser(arg0 context.Context, arg1 *event.GetEventsByUserRequest) (*event.Events, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetEventsByUser", arg0, arg1)
        ret0, _ := ret[0].(*event.Events)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetEventsByUser indicates an expected call of GetEventsByUser.
func (mr *MockEventServiceServerMockRecorder) GetEventsByUser(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEventsByUser", reflect.TypeOf((*MockEventServiceServer)(nil).GetEventsByUser), arg0, arg1)
}</span>

// GetFavorites mocks base method.
func (m *MockEventServiceServer) GetFavorites(arg0 context.Context, arg1 *event.GetFavoritesRequest) (*event.Events, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetFavorites", arg0, arg1)
        ret0, _ := ret[0].(*event.Events)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetFavorites indicates an expected call of GetFavorites.
func (mr *MockEventServiceServerMockRecorder) GetFavorites(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFavorites", reflect.TypeOf((*MockEventServiceServer)(nil).GetFavorites), arg0, arg1)
}</span>

// GetPastEvents mocks base method.
func (m *MockEventServiceServer) GetPastEvents(arg0 context.Context, arg1 *event.PaginationParams) (*event.Events, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetPastEvents", arg0, arg1)
        ret0, _ := ret[0].(*event.Events)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetPastEvents indicates an expected call of GetPastEvents.
func (mr *MockEventServiceServerMockRecorder) GetPastEvents(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPastEvents", reflect.TypeOf((*MockEventServiceServer)(nil).GetPastEvents), arg0, arg1)
}</span>

// GetSubscribersIDs mocks base method.
func (m *MockEventServiceServer) GetSubscribersIDs(arg0 context.Context, arg1 *event.GetSubscribersIDsRequest) (*event.GetUserIDsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSubscribersIDs", arg0, arg1)
        ret0, _ := ret[0].(*event.GetUserIDsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSubscribersIDs indicates an expected call of GetSubscribersIDs.
func (mr *MockEventServiceServerMockRecorder) GetSubscribersIDs(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubscribersIDs", reflect.TypeOf((*MockEventServiceServer)(nil).GetSubscribersIDs), arg0, arg1)
}</span>

// GetSubscriptionsEvents mocks base method.
func (m *MockEventServiceServer) GetSubscriptionsEvents(arg0 context.Context, arg1 *event.GetSubscriptionsRequest) (*event.Events, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSubscriptionsEvents", arg0, arg1)
        ret0, _ := ret[0].(*event.Events)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSubscriptionsEvents indicates an expected call of GetSubscriptionsEvents.
func (mr *MockEventServiceServerMockRecorder) GetSubscriptionsEvents(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubscriptionsEvents", reflect.TypeOf((*MockEventServiceServer)(nil).GetSubscriptionsEvents), arg0, arg1)
}</span>

// GetUpcomingEvents mocks base method.
func (m *MockEventServiceServer) GetUpcomingEvents(arg0 context.Context, arg1 *event.PaginationParams) (*event.Events, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUpcomingEvents", arg0, arg1)
        ret0, _ := ret[0].(*event.Events)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUpcomingEvents indicates an expected call of GetUpcomingEvents.
func (mr *MockEventServiceServerMockRecorder) GetUpcomingEvents(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUpcomingEvents", reflect.TypeOf((*MockEventServiceServer)(nil).GetUpcomingEvents), arg0, arg1)
}</span>

// GetUserIDsByFavoriteEvent mocks base method.
func (m *MockEventServiceServer) GetUserIDsByFavoriteEvent(arg0 context.Context, arg1 *event.GetUserIDsByFavoriteEventRequest) (*event.GetUserIDsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserIDsByFavoriteEvent", arg0, arg1)
        ret0, _ := ret[0].(*event.GetUserIDsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserIDsByFavoriteEvent indicates an expected call of GetUserIDsByFavoriteEvent.
func (mr *MockEventServiceServerMockRecorder) GetUserIDsByFavoriteEvent(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserIDsByFavoriteEvent", reflect.TypeOf((*MockEventServiceServer)(nil).GetUserIDsByFavoriteEvent), arg0, arg1)
}</span>

// SearchEvents mocks base method.
func (m *MockEventServiceServer) SearchEvents(arg0 context.Context, arg1 *event.SearchParams) (*event.Events, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SearchEvents", arg0, arg1)
        ret0, _ := ret[0].(*event.Events)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SearchEvents indicates an expected call of SearchEvents.
func (mr *MockEventServiceServerMockRecorder) SearchEvents(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchEvents", reflect.TypeOf((*MockEventServiceServer)(nil).SearchEvents), arg0, arg1)
}</span>

// UpdateEvent mocks base method.
func (m *MockEventServiceServer) UpdateEvent(arg0 context.Context, arg1 *event.Event) (*event.Event, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateEvent", arg0, arg1)
        ret0, _ := ret[0].(*event.Event)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateEvent indicates an expected call of UpdateEvent.
func (mr *MockEventServiceServerMockRecorder) UpdateEvent(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateEvent", reflect.TypeOf((*MockEventServiceServer)(nil).UpdateEvent), arg0, arg1)
}</span>

// mustEmbedUnimplementedEventServiceServer mocks base method.
func (m *MockEventServiceServer) mustEmbedUnimplementedEventServiceServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedEventServiceServer")
}</span>

// mustEmbedUnimplementedEventServiceServer indicates an expected call of mustEmbedUnimplementedEventServiceServer.
func (mr *MockEventServiceServerMockRecorder) mustEmbedUnimplementedEventServiceServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedEventServiceServer", reflect.TypeOf((*MockEventServiceServer)(nil).mustEmbedUnimplementedEventServiceServer))
}</span>

// MockUnsafeEventServiceServer is a mock of UnsafeEventServiceServer interface.
type MockUnsafeEventServiceServer struct {
        ctrl     *gomock.Controller
        recorder *MockUnsafeEventServiceServerMockRecorder
}

// MockUnsafeEventServiceServerMockRecorder is the mock recorder for MockUnsafeEventServiceServer.
type MockUnsafeEventServiceServerMockRecorder struct {
        mock *MockUnsafeEventServiceServer
}

// NewMockUnsafeEventServiceServer creates a new mock instance.
func NewMockUnsafeEventServiceServer(ctrl *gomock.Controller) *MockUnsafeEventServiceServer <span class="cov0" title="0">{
        mock := &amp;MockUnsafeEventServiceServer{ctrl: ctrl}
        mock.recorder = &amp;MockUnsafeEventServiceServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeEventServiceServer) EXPECT() *MockUnsafeEventServiceServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// mustEmbedUnimplementedEventServiceServer mocks base method.
func (m *MockUnsafeEventServiceServer) mustEmbedUnimplementedEventServiceServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedEventServiceServer")
}</span>

// mustEmbedUnimplementedEventServiceServer indicates an expected call of mustEmbedUnimplementedEventServiceServer.
func (mr *MockUnsafeEventServiceServerMockRecorder) mustEmbedUnimplementedEventServiceServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedEventServiceServer", reflect.TypeOf((*MockUnsafeEventServiceServer)(nil).mustEmbedUnimplementedEventServiceServer))
}</span>
</pre>
		
		<pre class="file" id="file100" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ../../notification/api/notification_grpc.pb.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        notification "kudago/internal/notification/api"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        grpc "google.golang.org/grpc"
)

// MockNotificationServiceClient is a mock of NotificationServiceClient interface.
type MockNotificationServiceClient struct {
        ctrl     *gomock.Controller
        recorder *MockNotificationServiceClientMockRecorder
}

// MockNotificationServiceClientMockRecorder is the mock recorder for MockNotificationServiceClient.
type MockNotificationServiceClientMockRecorder struct {
        mock *MockNotificationServiceClient
}

// NewMockNotificationServiceClient creates a new mock instance.
func NewMockNotificationServiceClient(ctrl *gomock.Controller) *MockNotificationServiceClient <span class="cov8" title="1">{
        mock := &amp;MockNotificationServiceClient{ctrl: ctrl}
        mock.recorder = &amp;MockNotificationServiceClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNotificationServiceClient) EXPECT() *MockNotificationServiceClientMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CreateNotifications mocks base method.
func (m *MockNotificationServiceClient) CreateNotifications(ctx context.Context, in *notification.CreateNotificationsRequest, opts ...grpc.CallOption) (*notification.Empty, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "CreateNotifications", varargs...)
        ret0, _ := ret[0].(*notification.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// CreateNotifications indicates an expected call of CreateNotifications.
func (mr *MockNotificationServiceClientMockRecorder) CreateNotifications(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateNotifications", reflect.TypeOf((*MockNotificationServiceClient)(nil).CreateNotifications), varargs...)
}</span>

// DeleteNotification mocks base method.
func (m *MockNotificationServiceClient) DeleteNotification(ctx context.Context, in *notification.DeleteNotificationRequest, opts ...grpc.CallOption) (*notification.Empty, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "DeleteNotification", varargs...)
        ret0, _ := ret[0].(*notification.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DeleteNotification indicates an expected call of DeleteNotification.
func (mr *MockNotificationServiceClientMockRecorder) DeleteNotification(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteNotification", reflect.TypeOf((*MockNotificationServiceClient)(nil).DeleteNotification), varargs...)
}</span>

// GetNotifications mocks base method.
func (m *MockNotificationServiceClient) GetNotifications(ctx context.Context, in *notification.GetNotificationsRequest, opts ...grpc.CallOption) (*notification.GetNotificationsResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetNotifications", varargs...)
        ret0, _ := ret[0].(*notification.GetNotificationsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetNotifications indicates an expected call of GetNotifications.
func (mr *MockNotificationServiceClientMockRecorder) GetNotifications(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNotifications", reflect.TypeOf((*MockNotificationServiceClient)(nil).GetNotifications), varargs...)
}</span>

// MockNotificationServiceServer is a mock of NotificationServiceServer interface.
type MockNotificationServiceServer struct {
        ctrl     *gomock.Controller
        recorder *MockNotificationServiceServerMockRecorder
}

// MockNotificationServiceServerMockRecorder is the mock recorder for MockNotificationServiceServer.
type MockNotificationServiceServerMockRecorder struct {
        mock *MockNotificationServiceServer
}

// NewMockNotificationServiceServer creates a new mock instance.
func NewMockNotificationServiceServer(ctrl *gomock.Controller) *MockNotificationServiceServer <span class="cov0" title="0">{
        mock := &amp;MockNotificationServiceServer{ctrl: ctrl}
        mock.recorder = &amp;MockNotificationServiceServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNotificationServiceServer) EXPECT() *MockNotificationServiceServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateNotifications mocks base method.
func (m *MockNotificationServiceServer) CreateNotifications(arg0 context.Context, arg1 *notification.CreateNotificationsRequest) (*notification.Empty, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateNotifications", arg0, arg1)
        ret0, _ := ret[0].(*notification.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateNotifications indicates an expected call of CreateNotifications.
func (mr *MockNotificationServiceServerMockRecorder) CreateNotifications(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateNotifications", reflect.TypeOf((*MockNotificationServiceServer)(nil).CreateNotifications), arg0, arg1)
}</span>

// DeleteNotification mocks base method.
func (m *MockNotificationServiceServer) DeleteNotification(arg0 context.Context, arg1 *notification.DeleteNotificationRequest) (*notification.Empty, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteNotification", arg0, arg1)
        ret0, _ := ret[0].(*notification.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteNotification indicates an expected call of DeleteNotification.
func (mr *MockNotificationServiceServerMockRecorder) DeleteNotification(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteNotification", reflect.TypeOf((*MockNotificationServiceServer)(nil).DeleteNotification), arg0, arg1)
}</span>

// GetNotifications mocks base method.
func (m *MockNotificationServiceServer) GetNotifications(arg0 context.Context, arg1 *notification.GetNotificationsRequest) (*notification.GetNotificationsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetNotifications", arg0, arg1)
        ret0, _ := ret[0].(*notification.GetNotificationsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetNotifications indicates an expected call of GetNotifications.
func (mr *MockNotificationServiceServerMockRecorder) GetNotifications(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNotifications", reflect.TypeOf((*MockNotificationServiceServer)(nil).GetNotifications), arg0, arg1)
}</span>

// mustEmbedUnimplementedNotificationServiceServer mocks base method.
func (m *MockNotificationServiceServer) mustEmbedUnimplementedNotificationServiceServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedNotificationServiceServer")
}</span>

// mustEmbedUnimplementedNotificationServiceServer indicates an expected call of mustEmbedUnimplementedNotificationServiceServer.
func (mr *MockNotificationServiceServerMockRecorder) mustEmbedUnimplementedNotificationServiceServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedNotificationServiceServer", reflect.TypeOf((*MockNotificationServiceServer)(nil).mustEmbedUnimplementedNotificationServiceServer))
}</span>

// MockUnsafeNotificationServiceServer is a mock of UnsafeNotificationServiceServer interface.
type MockUnsafeNotificationServiceServer struct {
        ctrl     *gomock.Controller
        recorder *MockUnsafeNotificationServiceServerMockRecorder
}

// MockUnsafeNotificationServiceServerMockRecorder is the mock recorder for MockUnsafeNotificationServiceServer.
type MockUnsafeNotificationServiceServerMockRecorder struct {
        mock *MockUnsafeNotificationServiceServer
}

// NewMockUnsafeNotificationServiceServer creates a new mock instance.
func NewMockUnsafeNotificationServiceServer(ctrl *gomock.Controller) *MockUnsafeNotificationServiceServer <span class="cov0" title="0">{
        mock := &amp;MockUnsafeNotificationServiceServer{ctrl: ctrl}
        mock.recorder = &amp;MockUnsafeNotificationServiceServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeNotificationServiceServer) EXPECT() *MockUnsafeNotificationServiceServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// mustEmbedUnimplementedNotificationServiceServer mocks base method.
func (m *MockUnsafeNotificationServiceServer) mustEmbedUnimplementedNotificationServiceServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedNotificationServiceServer")
}</span>

// mustEmbedUnimplementedNotificationServiceServer indicates an expected call of mustEmbedUnimplementedNotificationServiceServer.
func (mr *MockUnsafeNotificationServiceServerMockRecorder) mustEmbedUnimplementedNotificationServiceServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedNotificationServiceServer", reflect.TypeOf((*MockUnsafeNotificationServiceServer)(nil).mustEmbedUnimplementedNotificationServiceServer))
}</span>
</pre>
		
		<pre class="file" id="file101" style="display: none">package events

import (
        "net/http"
        "strconv"

        pb "kudago/internal/event/api"
        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"
)

// @Summary Поиск событий
// @Description Поиск событий по ключевым словам, датам, тегам и категории
// @Tags events
// @Accept json
// @Produce json
// @Param page query int false "Номер страницы (по умолчанию 1)"
// @Param limit query int false "Количество событий на странице (по умолчанию 30)"
// @Param query query string false "Ключевые слова для поиска"
// @Param event_start query string false "Дата начала события в формате YYYY-MM-DD"
// @Param event_end query string false "Дата окончания события в формате YYYY-MM-DD"
// @Param tags query []string false "Список тегов"
// @Param category_id query int false "ID категории"
// @Success 200 {object} GetEventsResponse "Список событий"
// @Failure 400 {object} httpErrors.HttpError "Invalid Data"
// @Failure 500 {object} httpErrors.HttpError "Internal Server Error"
// @Router /events [get]
func (h EventHandler) SearchEvents(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        paginationParams := GetPaginationParams(r)

        query := r.URL.Query().Get("query")
        eventStart := r.URL.Query().Get("event_start")
        eventEnd := r.URL.Query().Get("event_end")
        categoryIDStr := r.URL.Query().Get("category_id")
        tags := r.URL.Query()["tags"]

        categoryID, err := strconv.Atoi(categoryIDStr)
        if err != nil </span><span class="cov8" title="1">{
                categoryID = 0
        }</span>

        <span class="cov8" title="1">params := &amp;pb.SearchParams{
                Query:      query,
                EventStart: eventStart,
                EventEnd:   eventEnd,
                Tag:        tags,
                CategoryID: int32(categoryID),
                Params:     paginationParams,
        }

        events, err := h.EventService.SearchEvents(r.Context(), params)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error(r.Context(), "search", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return
        }</span>

        <span class="cov8" title="1">resp := writeEventsResponse(events.Events, int(paginationParams.Limit))
        utils.WriteResponse(w, http.StatusOK, resp)</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package events

import (
        "context"
        "net/http"
        "strconv"
        "time"

        pbEvent "kudago/internal/event/api"
        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"
        pbNtf "kudago/internal/notification/api"

        "github.com/asaskevich/govalidator"
        "github.com/gorilla/mux"
        grpcCodes "google.golang.org/grpc/codes"
        grpcStatus "google.golang.org/grpc/status"
)

// UpdateEvent обновляет данные существующего события.
// @Summary Обновление события
// @Description Обновляет данные существующего события. Необходимо передать JSON-объект с данными события и идентификатором события в URL.
// @Tags events
// @Accept  json
// @Produce  json
// @Param id path int true "Идентификатор события"
// @Param json body NewEventRequest true "Данные для обновления события"
// @Param image formData file false "Изображение события"
// @Success 200 {object} NewEventResponse "Успешное обновление события"
// @Failure 400 {object} httpErrors.HttpError "Неверные данные"
// @Failure 401 {object} httpErrors.HttpError "Неавторизован"
// @Failure 403 {object} httpErrors.HttpError "Доступ запрещен"
// @Failure 404 {object} httpErrors.HttpError "Событие не найдено"
// @Failure 500 {object} httpErrors.HttpError "Внутренняя ошибка сервера"
// @Router /events/{id} [put]
func (h EventHandler) UpdateEvent(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        session, ok := utils.GetSessionFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusForbidden, httpErrors.ErrUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">req, media, reqErr := parseEventData(r)
        if reqErr != nil </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusBadRequest, reqErr)
                return
        }</span>

        <span class="cov0" title="0">_, err := govalidator.ValidateStruct(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                utils.ProcessValidationErrors(w, err)
                return
        }</span>

        <span class="cov0" title="0">reqErr = checkNewEventRequest(req)
        if reqErr != nil </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusBadRequest, reqErr)
                return
        }</span>

        <span class="cov0" title="0">vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidID)
                return
        }</span>

        <span class="cov0" title="0">url, err := h.uploadImage(r.Context(), media, w)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">event := toPBEvent(req, session.UserID)
        event.ID = int32(id)
        event.Image = url

        event, err = h.EventService.UpdateEvent(r.Context(), event)
        if err != nil </span><span class="cov0" title="0">{
                h.deleteImage(r.Context(), url)
                st, ok := grpcStatus.FromError(err)
                if ok </span><span class="cov0" title="0">{
                        switch st.Code() </span>{
                        case grpcCodes.NotFound:<span class="cov0" title="0">
                                utils.WriteResponse(w, http.StatusConflict, httpErrors.ErrEventNotFound)
                                return</span>
                        case grpcCodes.PermissionDenied:<span class="cov0" title="0">
                                utils.WriteResponse(w, http.StatusForbidden, httpErrors.ErrAccessDenied)
                                return</span>
                        case grpcCodes.Internal:<span class="cov0" title="0">
                                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                                return</span>
                        }
                }

                <span class="cov0" title="0">h.logger.Error(r.Context(), "update event", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return</span>
        }

        <span class="cov0" title="0">err = h.sendUpdateNotifications(r.Context(), int(event.ID))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(r.Context(), "send update notifications", err)
        }</span>

        <span class="cov0" title="0">eventResp := eventToEventResponse(event)
        resp := NewEventResponse{
                Event: eventResp,
        }
        utils.WriteResponse(w, http.StatusOK, resp)</span>
}

func (h EventHandler) sendUpdateNotifications(ctx context.Context, eventID int) error <span class="cov0" title="0">{
        idsResp, err := h.EventService.GetUserIDsByFavoriteEvent(ctx, &amp;pbEvent.GetUserIDsByFavoriteEventRequest{ID: int32(eventID)})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">req := &amp;pbNtf.CreateNotificationsRequest{
                UserIDs: make([]int32, len(idsResp.IDs)),
                Notification: &amp;pbNtf.Notification{
                        Message:  UpdatedEventMsg,
                        NotifyAt: time.Now().String(),
                        EventID:  int32(eventID),
                },
        }

        for _, id := range idsResp.IDs </span><span class="cov0" title="0">{
                req.UserIDs = append(req.UserIDs, int32(id))
        }</span>

        <span class="cov0" title="0">_, err = h.NotificationService.CreateNotifications(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package handlers

import (
        "net/http"

        httpErrors "kudago/internal/gateway/errors"
        pb "kudago/internal/user/api"

        "kudago/internal/gateway/utils"
)

// @Summary Получение избранных событий
// @Description Возвращает избранные события
// @Tags events
// @Produce  json
// @Param page query int false "Номер страницы (по умолчанию 1)"
// @Param limit query int false "Количество событий на странице (по умолчанию 30)"
// @Success 200 {object} GetEventsResponse
// @Failure 401 {object} httpErrors.HttpError "Unauthorized"
// @Failure 500 {object} httpErrors.HttpError "Internal Server Error"
// @Router /events/favorites [get]
func (h *UserHandlers) GetSubscribers(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        session, ok := utils.GetSessionFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                utils.WriteResponse(w, http.StatusForbidden, httpErrors.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">req := &amp;pb.GetSubscribersRequest{
                ID: int32(session.UserID),
        }

        users, err := h.UserService.GetSubscribers(r.Context(), req)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error(r.Context(), "get subscribers", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return
        }</span>

        <span class="cov8" title="1">resp := writeUsersResponse(users.Users, len(users.Users))

        utils.WriteResponse(w, http.StatusOK, resp)</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"
        pb "kudago/internal/user/api"

        "github.com/gorilla/mux"
        grpcCodes "google.golang.org/grpc/codes"
        grpcStatus "google.golang.org/grpc/status"
)

func (h *UserHandlers) GetSubscriptions(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        paginationParams := utils.GetPaginationParams(r)
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">users, err := h.UserService.GetSubscriptions(r.Context(), &amp;pb.GetSubscriptionsRequest{ID: int32(id)})
        if err != nil </span><span class="cov8" title="1">{
                st, ok := grpcStatus.FromError(err)
                if ok </span><span class="cov8" title="1">{
                        switch st.Code() </span>{
                        case grpcCodes.NotFound:<span class="cov8" title="1">
                                utils.WriteResponse(w, http.StatusConflict, httpErrors.ErrSubscriptionNotFound)
                                return</span>
                        }
                }

                <span class="cov8" title="1">h.logger.Error(r.Context(), "get subscriptions", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return</span>
        }

        <span class="cov8" title="1">resp := writeUsersResponse(users.Users, paginationParams.Limit)

        utils.WriteResponse(w, http.StatusOK, resp)</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ../../user/api/user_grpc.pb.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        user "kudago/internal/user/api"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        grpc "google.golang.org/grpc"
)

// MockUserServiceClient is a mock of UserServiceClient interface.
type MockUserServiceClient struct {
        ctrl     *gomock.Controller
        recorder *MockUserServiceClientMockRecorder
}

// MockUserServiceClientMockRecorder is the mock recorder for MockUserServiceClient.
type MockUserServiceClientMockRecorder struct {
        mock *MockUserServiceClient
}

// NewMockUserServiceClient creates a new mock instance.
func NewMockUserServiceClient(ctrl *gomock.Controller) *MockUserServiceClient <span class="cov8" title="1">{
        mock := &amp;MockUserServiceClient{ctrl: ctrl}
        mock.recorder = &amp;MockUserServiceClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserServiceClient) EXPECT() *MockUserServiceClientMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// GetSubscribers mocks base method.
func (m *MockUserServiceClient) GetSubscribers(ctx context.Context, in *user.GetSubscribersRequest, opts ...grpc.CallOption) (*user.GetSubscribersResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetSubscribers", varargs...)
        ret0, _ := ret[0].(*user.GetSubscribersResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetSubscribers indicates an expected call of GetSubscribers.
func (mr *MockUserServiceClientMockRecorder) GetSubscribers(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubscribers", reflect.TypeOf((*MockUserServiceClient)(nil).GetSubscribers), varargs...)
}</span>

// GetSubscriptions mocks base method.
func (m *MockUserServiceClient) GetSubscriptions(ctx context.Context, in *user.GetSubscriptionsRequest, opts ...grpc.CallOption) (*user.GetSubscriptionsResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetSubscriptions", varargs...)
        ret0, _ := ret[0].(*user.GetSubscriptionsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetSubscriptions indicates an expected call of GetSubscriptions.
func (mr *MockUserServiceClientMockRecorder) GetSubscriptions(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubscriptions", reflect.TypeOf((*MockUserServiceClient)(nil).GetSubscriptions), varargs...)
}</span>

// GetUserByID mocks base method.
func (m *MockUserServiceClient) GetUserByID(ctx context.Context, in *user.GetUserByIDRequest, opts ...grpc.CallOption) (*user.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetUserByID", varargs...)
        ret0, _ := ret[0].(*user.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetUserByID indicates an expected call of GetUserByID.
func (mr *MockUserServiceClientMockRecorder) GetUserByID(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByID", reflect.TypeOf((*MockUserServiceClient)(nil).GetUserByID), varargs...)
}</span>

// Subscribe mocks base method.
func (m *MockUserServiceClient) Subscribe(ctx context.Context, in *user.Subscription, opts ...grpc.CallOption) (*user.Empty, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "Subscribe", varargs...)
        ret0, _ := ret[0].(*user.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockUserServiceClientMockRecorder) Subscribe(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockUserServiceClient)(nil).Subscribe), varargs...)
}</span>

// Unsubscribe mocks base method.
func (m *MockUserServiceClient) Unsubscribe(ctx context.Context, in *user.Subscription, opts ...grpc.CallOption) (*user.Empty, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "Unsubscribe", varargs...)
        ret0, _ := ret[0].(*user.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Unsubscribe indicates an expected call of Unsubscribe.
func (mr *MockUserServiceClientMockRecorder) Unsubscribe(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockUserServiceClient)(nil).Unsubscribe), varargs...)
}</span>

// UpdateUser mocks base method.
func (m *MockUserServiceClient) UpdateUser(ctx context.Context, in *user.User, opts ...grpc.CallOption) (*user.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "UpdateUser", varargs...)
        ret0, _ := ret[0].(*user.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// UpdateUser indicates an expected call of UpdateUser.
func (mr *MockUserServiceClientMockRecorder) UpdateUser(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUser", reflect.TypeOf((*MockUserServiceClient)(nil).UpdateUser), varargs...)
}</span>

// MockUserServiceServer is a mock of UserServiceServer interface.
type MockUserServiceServer struct {
        ctrl     *gomock.Controller
        recorder *MockUserServiceServerMockRecorder
}

// MockUserServiceServerMockRecorder is the mock recorder for MockUserServiceServer.
type MockUserServiceServerMockRecorder struct {
        mock *MockUserServiceServer
}

// NewMockUserServiceServer creates a new mock instance.
func NewMockUserServiceServer(ctrl *gomock.Controller) *MockUserServiceServer <span class="cov0" title="0">{
        mock := &amp;MockUserServiceServer{ctrl: ctrl}
        mock.recorder = &amp;MockUserServiceServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserServiceServer) EXPECT() *MockUserServiceServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetSubscribers mocks base method.
func (m *MockUserServiceServer) GetSubscribers(arg0 context.Context, arg1 *user.GetSubscribersRequest) (*user.GetSubscribersResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSubscribers", arg0, arg1)
        ret0, _ := ret[0].(*user.GetSubscribersResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSubscribers indicates an expected call of GetSubscribers.
func (mr *MockUserServiceServerMockRecorder) GetSubscribers(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubscribers", reflect.TypeOf((*MockUserServiceServer)(nil).GetSubscribers), arg0, arg1)
}</span>

// GetSubscriptions mocks base method.
func (m *MockUserServiceServer) GetSubscriptions(arg0 context.Context, arg1 *user.GetSubscriptionsRequest) (*user.GetSubscriptionsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSubscriptions", arg0, arg1)
        ret0, _ := ret[0].(*user.GetSubscriptionsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSubscriptions indicates an expected call of GetSubscriptions.
func (mr *MockUserServiceServerMockRecorder) GetSubscriptions(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubscriptions", reflect.TypeOf((*MockUserServiceServer)(nil).GetSubscriptions), arg0, arg1)
}</span>

// GetUserByID mocks base method.
func (m *MockUserServiceServer) GetUserByID(arg0 context.Context, arg1 *user.GetUserByIDRequest) (*user.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByID", arg0, arg1)
        ret0, _ := ret[0].(*user.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByID indicates an expected call of GetUserByID.
func (mr *MockUserServiceServerMockRecorder) GetUserByID(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByID", reflect.TypeOf((*MockUserServiceServer)(nil).GetUserByID), arg0, arg1)
}</span>

// Subscribe mocks base method.
func (m *MockUserServiceServer) Subscribe(arg0 context.Context, arg1 *user.Subscription) (*user.Empty, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Subscribe", arg0, arg1)
        ret0, _ := ret[0].(*user.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Subscribe indicates an expected call of Subscribe.
func (mr *MockUserServiceServerMockRecorder) Subscribe(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockUserServiceServer)(nil).Subscribe), arg0, arg1)
}</span>

// Unsubscribe mocks base method.
func (m *MockUserServiceServer) Unsubscribe(arg0 context.Context, arg1 *user.Subscription) (*user.Empty, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Unsubscribe", arg0, arg1)
        ret0, _ := ret[0].(*user.Empty)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Unsubscribe indicates an expected call of Unsubscribe.
func (mr *MockUserServiceServerMockRecorder) Unsubscribe(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockUserServiceServer)(nil).Unsubscribe), arg0, arg1)
}</span>

// UpdateUser mocks base method.
func (m *MockUserServiceServer) UpdateUser(arg0 context.Context, arg1 *user.User) (*user.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateUser", arg0, arg1)
        ret0, _ := ret[0].(*user.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateUser indicates an expected call of UpdateUser.
func (mr *MockUserServiceServerMockRecorder) UpdateUser(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUser", reflect.TypeOf((*MockUserServiceServer)(nil).UpdateUser), arg0, arg1)
}</span>

// mustEmbedUnimplementedUserServiceServer mocks base method.
func (m *MockUserServiceServer) mustEmbedUnimplementedUserServiceServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedUserServiceServer")
}</span>

// mustEmbedUnimplementedUserServiceServer indicates an expected call of mustEmbedUnimplementedUserServiceServer.
func (mr *MockUserServiceServerMockRecorder) mustEmbedUnimplementedUserServiceServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedUserServiceServer", reflect.TypeOf((*MockUserServiceServer)(nil).mustEmbedUnimplementedUserServiceServer))
}</span>

// MockUnsafeUserServiceServer is a mock of UnsafeUserServiceServer interface.
type MockUnsafeUserServiceServer struct {
        ctrl     *gomock.Controller
        recorder *MockUnsafeUserServiceServerMockRecorder
}

// MockUnsafeUserServiceServerMockRecorder is the mock recorder for MockUnsafeUserServiceServer.
type MockUnsafeUserServiceServerMockRecorder struct {
        mock *MockUnsafeUserServiceServer
}

// NewMockUnsafeUserServiceServer creates a new mock instance.
func NewMockUnsafeUserServiceServer(ctrl *gomock.Controller) *MockUnsafeUserServiceServer <span class="cov0" title="0">{
        mock := &amp;MockUnsafeUserServiceServer{ctrl: ctrl}
        mock.recorder = &amp;MockUnsafeUserServiceServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeUserServiceServer) EXPECT() *MockUnsafeUserServiceServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// mustEmbedUnimplementedUserServiceServer mocks base method.
func (m *MockUnsafeUserServiceServer) mustEmbedUnimplementedUserServiceServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedUserServiceServer")
}</span>

// mustEmbedUnimplementedUserServiceServer indicates an expected call of mustEmbedUnimplementedUserServiceServer.
func (mr *MockUnsafeUserServiceServerMockRecorder) mustEmbedUnimplementedUserServiceServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedUserServiceServer", reflect.TypeOf((*MockUnsafeUserServiceServer)(nil).mustEmbedUnimplementedUserServiceServer))
}</span>
</pre>
		
		<pre class="file" id="file106" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        pb "kudago/internal/user/api"

        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"

        "github.com/gorilla/mux"
        grpcCodes "google.golang.org/grpc/codes"
        grpcStatus "google.golang.org/grpc/status"
)

// @Summary Профиль пользователя
// @Description Возвращает информацию о профиле текущего пользователя
// @Tags profile
// @Success 200 {object} ProfileResponse
// @Failure 401 {object} httpErrors.HttpError "Unauthorized"
// @Router /profile/{id} [get]
func (h *UserHandlers) Profile(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">user, err := h.UserService.GetUserByID(r.Context(), &amp;pb.GetUserByIDRequest{ID: int32(id)})
        if err != nil </span><span class="cov8" title="1">{
                st, ok := grpcStatus.FromError(err)
                if ok </span><span class="cov8" title="1">{
                        switch st.Code() </span>{
                        case grpcCodes.NotFound:<span class="cov8" title="1">
                                utils.WriteResponse(w, http.StatusNotFound, httpErrors.ErrUserNotFound)
                                return</span>
                        }
                }

                <span class="cov8" title="1">h.logger.Error(r.Context(), "profile", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return</span>
        }

        <span class="cov8" title="1">userResponse := userToProfileResponse(user)
        utils.WriteResponse(w, http.StatusOK, userResponse)</span>
}

func userToProfileResponse(user *pb.User) ProfileResponse <span class="cov8" title="1">{
        return ProfileResponse{
                ID:       int(user.ID),
                Username: user.Username,
                Email:    user.Email,
                ImageURL: user.AvatarUrl,
        }
}</span>
</pre>
		
		<pre class="file" id="file107" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"
        pb "kudago/internal/user/api"

        "github.com/gorilla/mux"
        grpcCodes "google.golang.org/grpc/codes"
        grpcStatus "google.golang.org/grpc/status"
)

// @Summary Подписка на пользователя
// @Description Подписка на пользователя
// @Tags auth
// @Produce  json
// @Success 200
// @Failure 401 {object} httpErrors.HttpError "Unauthorized"
// @Failure 404 {object} httpErrors.HttpError "Invalid ID"
// @Failure 409 {object} httpErrors.HttpError "Self subscription"
// @Failure 500 {object} httpErrors.HttpError "Internal Server Error"
// @Router /profile/subscribe/{id} [post]
func (h *UserHandlers) Subscribe(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        session, ok := utils.GetSessionFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusUnauthorized, httpErrors.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">if id == session.UserID </span><span class="cov8" title="1">{
                utils.WriteResponse(w, http.StatusConflict, httpErrors.ErrSelfSubscription)
                return
        }</span>

        <span class="cov8" title="1">subscription := pb.Subscription{
                SubscriberID: int32(session.UserID),
                FollowsID:    int32(id),
        }

        _, err = h.UserService.Subscribe(r.Context(), &amp;subscription)
        if err != nil </span><span class="cov8" title="1">{
                st, ok := grpcStatus.FromError(err)
                if ok </span><span class="cov8" title="1">{
                        switch st.Code() </span>{
                        case grpcCodes.NotFound:<span class="cov8" title="1">
                                utils.WriteResponse(w, http.StatusConflict, httpErrors.ErrUserNotFound)
                                return</span>
                        case grpcCodes.AlreadyExists:<span class="cov8" title="1">
                                utils.WriteResponse(w, http.StatusConflict, httpErrors.ErrSubscriptionAlreadyExists)
                                return</span>
                        case grpcCodes.Internal:<span class="cov8" title="1">
                                h.logger.Error(r.Context(), "subscribe", st.Err())
                                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                                return</span>
                        }
                }

                <span class="cov0" title="0">h.logger.Error(r.Context(), "subscribe", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return</span>
        }

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"
        pb "kudago/internal/user/api"

        "github.com/gorilla/mux"
        grpcCodes "google.golang.org/grpc/codes"
        grpcStatus "google.golang.org/grpc/status"
)

// @Summary Отписаться от пользователя
// @Description Отписаться от пользователя
// @Tags auth
// @Produce  json
// @Success 200
// @Failure 401 {object} httpErrors.HttpError "Unauthorized"
// @Failure 404 {object} httpErrors.HttpError "Invalid ID"
// @Failure 409 {object} httpErrors.HttpError "No subscription"
// @Failure 500 {object} httpErrors.HttpError "Internal Server Error"
// @Router /profile/subscribe/{id} [delete]
func (h *UserHandlers) Unsubscribe(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        session, ok := utils.GetSessionFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusUnauthorized, httpErrors.ErrUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">vars := mux.Vars(r)
        id, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov8" title="1">{
                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidID)
                return
        }</span>

        <span class="cov8" title="1">if id == session.UserID </span><span class="cov8" title="1">{
                utils.WriteResponse(w, http.StatusConflict, httpErrors.ErrSelfSubscription)
                return
        }</span>

        <span class="cov8" title="1">subscription := pb.Subscription{
                SubscriberID: int32(session.UserID),
                FollowsID:    int32(id),
        }

        _, err = h.UserService.Unsubscribe(r.Context(), &amp;subscription)
        if err != nil </span><span class="cov8" title="1">{
                st, ok := grpcStatus.FromError(err)
                if ok </span><span class="cov8" title="1">{
                        switch st.Code() </span>{
                        case grpcCodes.NotFound:<span class="cov8" title="1">
                                utils.WriteResponse(w, http.StatusConflict, httpErrors.ErrSubscriptionNotFound)
                                return</span>
                        }
                }

                <span class="cov8" title="1">h.logger.Error(r.Context(), "unsubscribe", err)
                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                return</span>
        }

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package handlers

import (
        "context"
        "net/http"

        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"
        pbImage "kudago/internal/image/api"
        "kudago/internal/models"
        pb "kudago/internal/user/api"

        grpcCodes "google.golang.org/grpc/codes"
        grpcStatus "google.golang.org/grpc/status"

        "github.com/asaskevich/govalidator"
)

func (h *UserHandlers) UpdateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        session, ok := utils.GetSessionFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusForbidden, httpErrors.ErrUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">req, media, reqErr := parseUpdateData(r)
        if reqErr != nil </span><span class="cov0" title="0">{
                utils.WriteResponse(w, http.StatusBadRequest, reqErr)
                return
        }</span>

        <span class="cov0" title="0">_, err := govalidator.ValidateStruct(req)
        if err != nil </span><span class="cov0" title="0">{
                utils.ProcessValidationErrors(w, err)
                return
        }</span>

        <span class="cov0" title="0">url, err := h.uploadImage(r.Context(), media, w)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">req.AvatarUrl = url
        req.ID = int32(session.UserID)

        user, err := h.UserService.UpdateUser(r.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                h.deleteImage(r.Context(), url)
                st, ok := grpcStatus.FromError(err)
                if ok </span><span class="cov0" title="0">{
                        switch st.Code() </span>{
                        case grpcCodes.AlreadyExists:<span class="cov0" title="0">
                                utils.WriteResponse(w, http.StatusConflict, httpErrors.ErrUsernameIsAlredyTaken)
                                return</span>
                        }
                        <span class="cov0" title="0">h.logger.Error(r.Context(), "update user", err)
                        utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)
                        return</span>
                }
        }

        <span class="cov0" title="0">resp := userToUserResponse(user)

        utils.WriteResponse(w, http.StatusOK, resp)
        return</span>
}

func parseUpdateData(r *http.Request) (*pb.User, *pbImage.UploadRequest, *httpErrors.HttpError) <span class="cov0" title="0">{
        var req models.User
        jsonData := r.FormValue("json")

        err := req.UnmarshalJSON([]byte(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, httpErrors.ErrInvalidData
        }</span>

        <span class="cov0" title="0">media, err := utils.HandleImageUpload(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, httpErrors.ErrInvalidImage
        }</span>

        <span class="cov0" title="0">user := &amp;pb.User{
                ID:        int32(req.ID),
                Username:  req.Username,
                Email:     req.Email,
                AvatarUrl: req.ImageURL,
        }
        return user, media, nil</span>
}

func (h *UserHandlers) uploadImage(ctx context.Context, media *pbImage.UploadRequest, w http.ResponseWriter) (string, error) <span class="cov0" title="0">{
        if media != nil </span><span class="cov0" title="0">{
                url, err := h.ImageService.UploadImage(ctx, media)
                if err != nil </span><span class="cov0" title="0">{
                        switch err </span>{
                        case models.ErrInvalidImage:<span class="cov0" title="0">
                                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidImage)</span>
                        case models.ErrInvalidImageFormat:<span class="cov0" title="0">
                                utils.WriteResponse(w, http.StatusBadRequest, httpErrors.ErrInvalidImageFormat)</span>
                        default:<span class="cov0" title="0">
                                h.logger.Error(ctx, "upload image", err)
                                utils.WriteResponse(w, http.StatusInternalServerError, httpErrors.ErrInternal)</span>
                        }
                        <span class="cov0" title="0">return "", err</span>
                }
                <span class="cov0" title="0">return url.FileUrl, nil</span>
        }
        <span class="cov0" title="0">return "", nil</span>
}

func (h *UserHandlers) deleteImage(ctx context.Context, url string) <span class="cov0" title="0">{
        if url != "" </span><span class="cov0" title="0">{
                req := &amp;pbImage.DeleteRequest{
                        FileUrl: url,
                }
                h.ImageService.DeleteImage(ctx, req)
        }</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">//go:generate mockgen -source=../../user/api/user_grpc.pb.go -destination=mocks/user.go -package=mocks

//go:generate easyjson user.go
package handlers

import (
        "regexp"

        pbImage "kudago/internal/image/api"
        "kudago/internal/logger"
        pb "kudago/internal/user/api"
        user "kudago/internal/user/api"

        "github.com/asaskevich/govalidator"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

var validPasswordRegex = regexp.MustCompile(`^[a-zA-Z0-9+\-*/.;=\]\[\}\{\?]+$`)

func init() <span class="cov8" title="1">{
        govalidator.TagMap["password"] = govalidator.Validator(func(str string) bool </span><span class="cov0" title="0">{
                return validPasswordRegex.MatchString(str)
        }</span>)
}

type UserHandlers struct {
        UserService  pb.UserServiceClient
        ImageService pbImage.ImageServiceClient
        logger       *logger.Logger
}

func NewHandlers(userServiceAddr string, logger *logger.Logger) (*UserHandlers, error) <span class="cov0" title="0">{
        authConn, err := grpc.NewClient(userServiceAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;UserHandlers{
                UserService: user.NewUserServiceClient(authConn),
                logger:      logger,
        }, nil</span>
}

//easyjson:json
type AuthResponse struct {
        User UserResponse `json:"user"`
}

//easyjson:json
type ProfileResponse struct {
        ID       int    `json:"id"`
        Username string `json:"username"`
        Email    string `json:"email"`
        ImageURL string `json:"image"`
}

//easyjson:json
type UserResponse struct {
        ID       int    `json:"id"`
        Username string `json:"username"`
        Email    string `json:"email"`
        ImageURL string `json:"image"`
}

//easyjson:json
type GetUsersResponse struct {
        Users []UserResponse `json:"users"`
}

func userToUserResponse(user *pb.User) UserResponse <span class="cov8" title="1">{
        return UserResponse{
                ID:       int(user.ID),
                Username: user.Username,
                Email:    user.Email,
                ImageURL: user.AvatarUrl,
        }
}</span>

func subscriptionToSubscriptionPB(subscription *pb.Subscription) pb.Subscription <span class="cov0" title="0">{
        return pb.Subscription{
                SubscriberID: int32(subscription.SubscriberID),
                FollowsID:    int32(subscription.SubscriberID),
        }
}</span>

func writeUsersResponse(users []*pb.User, limit int) GetUsersResponse <span class="cov8" title="1">{
        resp := GetUsersResponse{Users: make([]UserResponse, 0, limit)}

        for _, user := range users </span><span class="cov8" title="1">{
                userResp := userToUserResponse(user)
                resp.Users = append(resp.Users, userResp)
        }</span>
        <span class="cov8" title="1">return resp</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package handlers

import (
        json "encoding/json"
        easyjson "github.com/mailru/easyjson"
        jlexer "github.com/mailru/easyjson/jlexer"
        jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
        _ *json.RawMessage
        _ *jlexer.Lexer
        _ *jwriter.Writer
        _ easyjson.Marshaler
)

func easyjson9e1087fdDecodeKudagoInternalGatewayUser(in *jlexer.Lexer, out *UserResponse) <span class="cov8" title="1">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov8" title="1">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov8" title="1">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov8" title="1">switch key </span>{
                case "id":<span class="cov8" title="1">
                        out.ID = int(in.Int())</span>
                case "username":<span class="cov8" title="1">
                        out.Username = string(in.String())</span>
                case "email":<span class="cov8" title="1">
                        out.Email = string(in.String())</span>
                case "image":<span class="cov8" title="1">
                        out.ImageURL = string(in.String())</span>
                default:<span class="cov8" title="1">
                        in.SkipRecursive()</span>
                }
                <span class="cov8" title="1">in.WantComma()</span>
        }
        <span class="cov8" title="1">in.Delim('}')
        if isTopLevel </span><span class="cov8" title="1">{
                in.Consumed()
        }</span>
}
func easyjson9e1087fdEncodeKudagoInternalGatewayUser(out *jwriter.Writer, in UserResponse) <span class="cov8" title="1">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov8" title="1">{
                const prefix string = ",\"id\":"
                out.RawString(prefix[1:])
                out.Int(int(in.ID))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"username\":"
                out.RawString(prefix)
                out.String(string(in.Username))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"email\":"
                out.RawString(prefix)
                out.String(string(in.Email))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"image\":"
                out.RawString(prefix)
                out.String(string(in.ImageURL))
        }</span>
        <span class="cov8" title="1">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v UserResponse) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjson9e1087fdEncodeKudagoInternalGatewayUser(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v UserResponse) MarshalEasyJSON(w *jwriter.Writer) <span class="cov8" title="1">{
        easyjson9e1087fdEncodeKudagoInternalGatewayUser(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *UserResponse) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        r := jlexer.Lexer{Data: data}
        easyjson9e1087fdDecodeKudagoInternalGatewayUser(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *UserResponse) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov8" title="1">{
        easyjson9e1087fdDecodeKudagoInternalGatewayUser(l, v)
}</span>
func easyjson9e1087fdDecodeKudagoInternalGatewayUser1(in *jlexer.Lexer, out *ProfileResponse) <span class="cov0" title="0">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov0" title="0">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov0" title="0">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov0" title="0">switch key </span>{
                case "id":<span class="cov0" title="0">
                        out.ID = int(in.Int())</span>
                case "username":<span class="cov0" title="0">
                        out.Username = string(in.String())</span>
                case "email":<span class="cov0" title="0">
                        out.Email = string(in.String())</span>
                case "image":<span class="cov0" title="0">
                        out.ImageURL = string(in.String())</span>
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov0" title="0">in.WantComma()</span>
        }
        <span class="cov0" title="0">in.Delim('}')
        if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjson9e1087fdEncodeKudagoInternalGatewayUser1(out *jwriter.Writer, in ProfileResponse) <span class="cov8" title="1">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov8" title="1">{
                const prefix string = ",\"id\":"
                out.RawString(prefix[1:])
                out.Int(int(in.ID))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"username\":"
                out.RawString(prefix)
                out.String(string(in.Username))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"email\":"
                out.RawString(prefix)
                out.String(string(in.Email))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"image\":"
                out.RawString(prefix)
                out.String(string(in.ImageURL))
        }</span>
        <span class="cov8" title="1">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v ProfileResponse) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjson9e1087fdEncodeKudagoInternalGatewayUser1(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v ProfileResponse) MarshalEasyJSON(w *jwriter.Writer) <span class="cov8" title="1">{
        easyjson9e1087fdEncodeKudagoInternalGatewayUser1(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *ProfileResponse) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        r := jlexer.Lexer{Data: data}
        easyjson9e1087fdDecodeKudagoInternalGatewayUser1(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *ProfileResponse) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjson9e1087fdDecodeKudagoInternalGatewayUser1(l, v)
}</span>
func easyjson9e1087fdDecodeKudagoInternalGatewayUser2(in *jlexer.Lexer, out *GetUsersResponse) <span class="cov8" title="1">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov8" title="1">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov8" title="1">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov8" title="1">switch key </span>{
                case "users":<span class="cov8" title="1">
                        if in.IsNull() </span><span class="cov0" title="0">{
                                in.Skip()
                                out.Users = nil
                        }</span> else<span class="cov8" title="1"> {
                                in.Delim('[')
                                if out.Users == nil </span><span class="cov8" title="1">{
                                        if !in.IsDelim(']') </span><span class="cov8" title="1">{
                                                out.Users = make([]UserResponse, 0, 1)
                                        }</span> else<span class="cov0" title="0"> {
                                                out.Users = []UserResponse{}
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        out.Users = (out.Users)[:0]
                                }</span>
                                <span class="cov8" title="1">for !in.IsDelim(']') </span><span class="cov8" title="1">{
                                        var v1 UserResponse
                                        (v1).UnmarshalEasyJSON(in)
                                        out.Users = append(out.Users, v1)
                                        in.WantComma()
                                }</span>
                                <span class="cov8" title="1">in.Delim(']')</span>
                        }
                default:<span class="cov8" title="1">
                        in.SkipRecursive()</span>
                }
                <span class="cov8" title="1">in.WantComma()</span>
        }
        <span class="cov8" title="1">in.Delim('}')
        if isTopLevel </span><span class="cov8" title="1">{
                in.Consumed()
        }</span>
}
func easyjson9e1087fdEncodeKudagoInternalGatewayUser2(out *jwriter.Writer, in GetUsersResponse) <span class="cov8" title="1">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov8" title="1">{
                const prefix string = ",\"users\":"
                out.RawString(prefix[1:])
                if in.Users == nil &amp;&amp; (out.Flags&amp;jwriter.NilSliceAsEmpty) == 0 </span><span class="cov0" title="0">{
                        out.RawString("null")
                }</span> else<span class="cov8" title="1"> {
                        out.RawByte('[')
                        for v2, v3 := range in.Users </span><span class="cov8" title="1">{
                                if v2 &gt; 0 </span><span class="cov0" title="0">{
                                        out.RawByte(',')
                                }</span>
                                <span class="cov8" title="1">(v3).MarshalEasyJSON(out)</span>
                        }
                        <span class="cov8" title="1">out.RawByte(']')</span>
                }
        }
        <span class="cov8" title="1">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v GetUsersResponse) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjson9e1087fdEncodeKudagoInternalGatewayUser2(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v GetUsersResponse) MarshalEasyJSON(w *jwriter.Writer) <span class="cov8" title="1">{
        easyjson9e1087fdEncodeKudagoInternalGatewayUser2(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *GetUsersResponse) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        r := jlexer.Lexer{Data: data}
        easyjson9e1087fdDecodeKudagoInternalGatewayUser2(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *GetUsersResponse) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjson9e1087fdDecodeKudagoInternalGatewayUser2(l, v)
}</span>
func easyjson9e1087fdDecodeKudagoInternalGatewayUser3(in *jlexer.Lexer, out *AuthResponse) <span class="cov0" title="0">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov0" title="0">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov0" title="0">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov0" title="0">switch key </span>{
                case "user":<span class="cov0" title="0">
                        (out.User).UnmarshalEasyJSON(in)</span>
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov0" title="0">in.WantComma()</span>
        }
        <span class="cov0" title="0">in.Delim('}')
        if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjson9e1087fdEncodeKudagoInternalGatewayUser3(out *jwriter.Writer, in AuthResponse) <span class="cov0" title="0">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov0" title="0">{
                const prefix string = ",\"user\":"
                out.RawString(prefix[1:])
                (in.User).MarshalEasyJSON(out)
        }</span>
        <span class="cov0" title="0">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v AuthResponse) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjson9e1087fdEncodeKudagoInternalGatewayUser3(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v AuthResponse) MarshalEasyJSON(w *jwriter.Writer) <span class="cov0" title="0">{
        easyjson9e1087fdEncodeKudagoInternalGatewayUser3(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *AuthResponse) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        r := jlexer.Lexer{Data: data}
        easyjson9e1087fdDecodeKudagoInternalGatewayUser3(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *AuthResponse) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjson9e1087fdDecodeKudagoInternalGatewayUser3(l, v)
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">//go:generate easyjson utils.go

package utils

import (
        "context"
        "crypto/rand"
        "encoding/base64"
        "errors"
        "fmt"
        "io"
        "mime/multipart"
        "net/http"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        pbImage "kudago/internal/image/api"
        "kudago/internal/models"

        "github.com/asaskevich/govalidator"
        easyjson "github.com/mailru/easyjson"
        "go.uber.org/zap"
)

const (
        defaultPage   = 0
        defaultLimit  = 30
        maxUploadSize = 10 * 1024 * 1024 // 10Mb
)

func WriteResponse(w http.ResponseWriter, status int, body easyjson.Marshaler) <span class="cov8" title="1">{
        w.WriteHeader(status)
        _, _ = easyjson.MarshalToWriter(body, w)
}</span>

func HandleImageUpload(r *http.Request) (*pbImage.UploadRequest, error) <span class="cov0" title="0">{
        err := r.ParseMultipartForm(maxUploadSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, models.ErrInvalidImage
        }</span>

        <span class="cov0" title="0">file, header, err := r.FormFile("image")
        if err != nil </span><span class="cov0" title="0">{
                if err != http.ErrMissingFile </span><span class="cov0" title="0">{
                        return nil, models.ErrInvalidImage
                }</span>
                <span class="cov0" title="0">return nil, nil</span>
        }
        <span class="cov0" title="0">defer file.Close()

        err = GenerateFilename(header)
        if err != nil </span><span class="cov0" title="0">{
                return nil, models.ErrInvalidImage
        }</span>

        <span class="cov0" title="0">fileData, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, models.ErrInvalidImage
        }</span>

        <span class="cov0" title="0">return &amp;pbImage.UploadRequest{
                Filename: header.Filename,
                File:     fileData,
        }, nil</span>
}

func GenerateFilename(header *multipart.FileHeader) error <span class="cov0" title="0">{
        bytes := make([]byte, 12)
        _, err := rand.Read(bytes)
        if err != nil </span><span class="cov0" title="0">{
                return models.ErrInvalidImage
        }</span>

        <span class="cov0" title="0">token := base64.URLEncoding.EncodeToString(bytes)
        timestamp := time.Now().UnixNano() / int64(time.Millisecond)

        filename := fmt.Sprintf("%s_%d", token, timestamp)
        extension := getFileExtension(header.Filename)

        switch extension </span>{
        case "jpeg", "jpg", "gif", "png":<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return models.ErrInvalidImageFormat</span>
        }
        <span class="cov0" title="0">header.Filename = fmt.Sprintf("%s.%s", filename, extension)
        return nil</span>
}

func getFileExtension(fileName string) string <span class="cov0" title="0">{
        extension := strings.ToLower(strings.TrimPrefix(filepath.Ext(fileName), "."))
        return extension
}</span>

//easyjson:json
type ValidationErrResponse struct {
        Errors []models.AuthError `json:"errors"`
}

type sessionKeyType struct{}

var sessionKey sessionKeyType

type requestIDKeyType struct{}

var requestIDKey requestIDKeyType

func GetSessionFromContext(ctx context.Context) (models.Session, bool) <span class="cov8" title="1">{
        session, ok := ctx.Value(sessionKey).(models.Session)
        if !ok || session.Token == "" </span><span class="cov8" title="1">{
                return session, false
        }</span>
        <span class="cov8" title="1">return session, true</span>
}

func SetSessionInContext(ctx context.Context, session models.Session) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, sessionKey, session)
}</span>

func ProcessValidationErrors(w http.ResponseWriter, err error) <span class="cov0" title="0">{
        resp := ValidationErrResponse{}
        validationErrors := err.(govalidator.Errors)

        for _, err := range validationErrors </span><span class="cov0" title="0">{
                var validationErr govalidator.Error

                if errors.As(err, &amp;validationErr) </span><span class="cov0" title="0">{
                        valErr := models.AuthError{
                                Field:   validationErr.Name,
                                Message: validationErr.Err.Error(),
                        }
                        resp.Errors = append(resp.Errors, valErr)
                }</span>
        }
        <span class="cov0" title="0">WriteResponse(w, http.StatusBadRequest, resp)</span>
}

func GetPaginationParams(r *http.Request) models.PaginationParams <span class="cov8" title="1">{
        page := GetQueryParamInt(r, "page", defaultPage)
        limit := GetQueryParamInt(r, "limit", defaultLimit)
        offset := page * limit

        return models.PaginationParams{
                Offset: offset,
                Limit:  limit,
        }
}</span>

func GetQueryParamInt(r *http.Request, key string, defaultValue int) int <span class="cov8" title="1">{
        valueStr := r.URL.Query().Get(key)
        value, err := strconv.Atoi(valueStr)

        if err != nil || value &lt;= 0 </span><span class="cov8" title="1">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">return value</span>
}

func GetRequestIDFromContext(ctx context.Context) string <span class="cov8" title="1">{
        ID, _ := ctx.Value(requestIDKey).(string)
        return ID
}</span>

func SetRequestIDInContext(ctx context.Context, ID string) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, requestIDKey, ID)
}</span>

func LogRequestData(ctx context.Context, logger *zap.SugaredLogger, msg string, statusCode int, method, url, remoteAddr string, duration time.Duration, data map[string]interface{}) <span class="cov0" title="0">{
        requestID := GetRequestIDFromContext(ctx)

        if data != nil </span><span class="cov0" title="0">{
                logger.Infow(msg,
                        "request_id", requestID,
                        "method", method,
                        "url", url,
                        "remote_addr", remoteAddr,
                        "status_code", statusCode,
                        "work_time", duration,
                        "data", data,
                )
        }</span> else<span class="cov0" title="0"> {
                logger.Infow(msg,
                        "request_id", requestID,
                        "method", method,
                        "url", url,
                        "remote_addr", remoteAddr,
                        "status_code", statusCode,
                        "work_time", duration,
                )
        }</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package utils

import (
        json "encoding/json"
        easyjson "github.com/mailru/easyjson"
        jlexer "github.com/mailru/easyjson/jlexer"
        jwriter "github.com/mailru/easyjson/jwriter"
        models "kudago/internal/models"
)

// suppress unused package warning
var (
        _ *json.RawMessage
        _ *jlexer.Lexer
        _ *jwriter.Writer
        _ easyjson.Marshaler
)

func easyjson79a3de99DecodeKudagoInternalGatewayUtils(in *jlexer.Lexer, out *ValidationErrResponse) <span class="cov0" title="0">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov0" title="0">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov0" title="0">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov0" title="0">switch key </span>{
                case "errors":<span class="cov0" title="0">
                        if in.IsNull() </span><span class="cov0" title="0">{
                                in.Skip()
                                out.Errors = nil
                        }</span> else<span class="cov0" title="0"> {
                                in.Delim('[')
                                if out.Errors == nil </span><span class="cov0" title="0">{
                                        if !in.IsDelim(']') </span><span class="cov0" title="0">{
                                                out.Errors = make([]models.AuthError, 0, 2)
                                        }</span> else<span class="cov0" title="0"> {
                                                out.Errors = []models.AuthError{}
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        out.Errors = (out.Errors)[:0]
                                }</span>
                                <span class="cov0" title="0">for !in.IsDelim(']') </span><span class="cov0" title="0">{
                                        var v1 models.AuthError
                                        easyjson79a3de99DecodeKudagoInternalModels(in, &amp;v1)
                                        out.Errors = append(out.Errors, v1)
                                        in.WantComma()
                                }</span>
                                <span class="cov0" title="0">in.Delim(']')</span>
                        }
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov0" title="0">in.WantComma()</span>
        }
        <span class="cov0" title="0">in.Delim('}')
        if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjson79a3de99EncodeKudagoInternalGatewayUtils(out *jwriter.Writer, in ValidationErrResponse) <span class="cov0" title="0">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov0" title="0">{
                const prefix string = ",\"errors\":"
                out.RawString(prefix[1:])
                if in.Errors == nil &amp;&amp; (out.Flags&amp;jwriter.NilSliceAsEmpty) == 0 </span><span class="cov0" title="0">{
                        out.RawString("null")
                }</span> else<span class="cov0" title="0"> {
                        out.RawByte('[')
                        for v2, v3 := range in.Errors </span><span class="cov0" title="0">{
                                if v2 &gt; 0 </span><span class="cov0" title="0">{
                                        out.RawByte(',')
                                }</span>
                                <span class="cov0" title="0">easyjson79a3de99EncodeKudagoInternalModels(out, v3)</span>
                        }
                        <span class="cov0" title="0">out.RawByte(']')</span>
                }
        }
        <span class="cov0" title="0">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v ValidationErrResponse) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjson79a3de99EncodeKudagoInternalGatewayUtils(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v ValidationErrResponse) MarshalEasyJSON(w *jwriter.Writer) <span class="cov0" title="0">{
        easyjson79a3de99EncodeKudagoInternalGatewayUtils(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *ValidationErrResponse) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        r := jlexer.Lexer{Data: data}
        easyjson79a3de99DecodeKudagoInternalGatewayUtils(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *ValidationErrResponse) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjson79a3de99DecodeKudagoInternalGatewayUtils(l, v)
}</span>
func easyjson79a3de99DecodeKudagoInternalModels(in *jlexer.Lexer, out *models.AuthError) <span class="cov0" title="0">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov0" title="0">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov0" title="0">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov0" title="0">switch key </span>{
                case "field":<span class="cov0" title="0">
                        out.Field = string(in.String())</span>
                case "error":<span class="cov0" title="0">
                        out.Message = string(in.String())</span>
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov0" title="0">in.WantComma()</span>
        }
        <span class="cov0" title="0">in.Delim('}')
        if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjson79a3de99EncodeKudagoInternalModels(out *jwriter.Writer, in models.AuthError) <span class="cov0" title="0">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov0" title="0">{
                const prefix string = ",\"field\":"
                out.RawString(prefix[1:])
                out.String(string(in.Field))
        }</span>
        <span class="cov0" title="0">{
                const prefix string = ",\"error\":"
                out.RawString(prefix)
                out.String(string(in.Message))
        }</span>
        <span class="cov0" title="0">out.RawByte('}')</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.35.2
//         protoc        v3.12.4
// source: image.proto

package image

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type UploadRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        File     []byte `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
        Filename string `protobuf:"bytes,2,opt,name=filename,proto3" json:"filename,omitempty"`
}

func (x *UploadRequest) Reset() <span class="cov0" title="0">{
        *x = UploadRequest{}
        mi := &amp;file_image_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UploadRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UploadRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UploadRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_image_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UploadRequest.ProtoReflect.Descriptor instead.
func (*UploadRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_image_proto_rawDescGZIP(), []int{0}
}</span>

func (x *UploadRequest) GetFile() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.File
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UploadRequest) GetFilename() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Filename
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UploadResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        FileUrl string `protobuf:"bytes,1,opt,name=file_url,json=fileUrl,proto3" json:"file_url,omitempty"`
}

func (x *UploadResponse) Reset() <span class="cov0" title="0">{
        *x = UploadResponse{}
        mi := &amp;file_image_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UploadResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UploadResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UploadResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_image_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UploadResponse.ProtoReflect.Descriptor instead.
func (*UploadResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_image_proto_rawDescGZIP(), []int{1}
}</span>

func (x *UploadResponse) GetFileUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FileUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        FileUrl string `protobuf:"bytes,1,opt,name=file_url,json=fileUrl,proto3" json:"file_url,omitempty"`
}

func (x *DeleteRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteRequest{}
        mi := &amp;file_image_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_image_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteRequest.ProtoReflect.Descriptor instead.
func (*DeleteRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_image_proto_rawDescGZIP(), []int{2}
}</span>

func (x *DeleteRequest) GetFileUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FileUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Empty struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *Empty) Reset() <span class="cov0" title="0">{
        *x = Empty{}
        mi := &amp;file_image_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Empty) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Empty) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Empty) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_image_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Empty.ProtoReflect.Descriptor instead.
func (*Empty) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_image_proto_rawDescGZIP(), []int{3}
}</span>

var File_image_proto protoreflect.FileDescriptor

var file_image_proto_rawDesc = []byte{
        0x0a, 0x0b, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x05, 0x69,
        0x6d, 0x61, 0x67, 0x65, 0x22, 0x3f, 0x0a, 0x0d, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x69, 0x6c, 0x65, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x0c, 0x52, 0x04, 0x66, 0x69, 0x6c, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x66, 0x69, 0x6c,
        0x65, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x66, 0x69, 0x6c,
        0x65, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x2b, 0x0a, 0x0e, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x19, 0x0a, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x5f,
        0x75, 0x72, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x66, 0x69, 0x6c, 0x65, 0x55,
        0x72, 0x6c, 0x22, 0x2a, 0x0a, 0x0d, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x12, 0x19, 0x0a, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x75, 0x72, 0x6c, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x66, 0x69, 0x6c, 0x65, 0x55, 0x72, 0x6c, 0x22, 0x07,
        0x0a, 0x05, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x32, 0x7d, 0x0a, 0x0c, 0x49, 0x6d, 0x61, 0x67, 0x65,
        0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x3a, 0x0a, 0x0b, 0x55, 0x70, 0x6c, 0x6f, 0x61,
        0x64, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x14, 0x2e, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x2e, 0x55,
        0x70, 0x6c, 0x6f, 0x61, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x15, 0x2e, 0x69,
        0x6d, 0x61, 0x67, 0x65, 0x2e, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x31, 0x0a, 0x0b, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x49, 0x6d, 0x61,
        0x67, 0x65, 0x12, 0x14, 0x2e, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74,
        0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x0c, 0x2e, 0x69, 0x6d, 0x61, 0x67, 0x65,
        0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x42, 0x0a, 0x5a, 0x08, 0x2e, 0x2f, 0x3b, 0x69, 0x6d, 0x61,
        0x67, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_image_proto_rawDescOnce sync.Once
        file_image_proto_rawDescData = file_image_proto_rawDesc
)

func file_image_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_image_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_image_proto_rawDescData = protoimpl.X.CompressGZIP(file_image_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_image_proto_rawDescData</span>
}

var file_image_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_image_proto_goTypes = []any{
        (*UploadRequest)(nil),  // 0: image.UploadRequest
        (*UploadResponse)(nil), // 1: image.UploadResponse
        (*DeleteRequest)(nil),  // 2: image.DeleteRequest
        (*Empty)(nil),          // 3: image.Empty
}
var file_image_proto_depIdxs = []int32{
        0, // 0: image.ImageService.UploadImage:input_type -&gt; image.UploadRequest
        2, // 1: image.ImageService.DeleteImage:input_type -&gt; image.DeleteRequest
        1, // 2: image.ImageService.UploadImage:output_type -&gt; image.UploadResponse
        3, // 3: image.ImageService.DeleteImage:output_type -&gt; image.Empty
        2, // [2:4] is the sub-list for method output_type
        0, // [0:2] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_image_proto_init() }</span>
func file_image_proto_init() <span class="cov8" title="1">{
        if File_image_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_image_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_image_proto_goTypes,
                DependencyIndexes: file_image_proto_depIdxs,
                MessageInfos:      file_image_proto_msgTypes,
        }.Build()
        File_image_proto = out.File
        file_image_proto_rawDesc = nil
        file_image_proto_goTypes = nil
        file_image_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: image.proto

package image

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        ImageService_UploadImage_FullMethodName = "/image.ImageService/UploadImage"
        ImageService_DeleteImage_FullMethodName = "/image.ImageService/DeleteImage"
)

// ImageServiceClient is the client API for ImageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ImageServiceClient interface {
        UploadImage(ctx context.Context, in *UploadRequest, opts ...grpc.CallOption) (*UploadResponse, error)
        DeleteImage(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*Empty, error)
}

type imageServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewImageServiceClient(cc grpc.ClientConnInterface) ImageServiceClient <span class="cov0" title="0">{
        return &amp;imageServiceClient{cc}
}</span>

func (c *imageServiceClient) UploadImage(ctx context.Context, in *UploadRequest, opts ...grpc.CallOption) (*UploadResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UploadResponse)
        err := c.cc.Invoke(ctx, ImageService_UploadImage_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *imageServiceClient) DeleteImage(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Empty)
        err := c.cc.Invoke(ctx, ImageService_DeleteImage_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ImageServiceServer is the server API for ImageService service.
// All implementations must embed UnimplementedImageServiceServer
// for forward compatibility.
type ImageServiceServer interface {
        UploadImage(context.Context, *UploadRequest) (*UploadResponse, error)
        DeleteImage(context.Context, *DeleteRequest) (*Empty, error)
        mustEmbedUnimplementedImageServiceServer()
}

// UnimplementedImageServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedImageServiceServer struct{}

func (UnimplementedImageServiceServer) UploadImage(context.Context, *UploadRequest) (*UploadResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UploadImage not implemented")
}</span>
func (UnimplementedImageServiceServer) DeleteImage(context.Context, *DeleteRequest) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteImage not implemented")
}</span>
func (UnimplementedImageServiceServer) mustEmbedUnimplementedImageServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedImageServiceServer) testEmbeddedByValue()                      {<span class="cov0" title="0">}</span>

// UnsafeImageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ImageServiceServer will
// result in compilation errors.
type UnsafeImageServiceServer interface {
        mustEmbedUnimplementedImageServiceServer()
}

func RegisterImageServiceServer(s grpc.ServiceRegistrar, srv ImageServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedImageServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;ImageService_ServiceDesc, srv)</span>
}

func _ImageService_UploadImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UploadRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ImageServiceServer).UploadImage(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ImageService_UploadImage_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ImageServiceServer).UploadImage(ctx, req.(*UploadRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ImageService_DeleteImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ImageServiceServer).DeleteImage(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ImageService_DeleteImage_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ImageServiceServer).DeleteImage(ctx, req.(*DeleteRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// ImageService_ServiceDesc is the grpc.ServiceDesc for ImageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ImageService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "image.ImageService",
        HandlerType: (*ImageServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "UploadImage",
                        Handler:    _ImageService_UploadImage_Handler,
                },
                {
                        MethodName: "DeleteImage",
                        Handler:    _ImageService_DeleteImage_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "image.proto",
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package grpc

import (
        "context"

        pb "kudago/internal/image/api"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) DeleteImage(ctx context.Context, req *pb.DeleteRequest) (*pb.Empty, error) <span class="cov8" title="1">{
        err := s.service.DeleteImage(ctx, req.FileUrl)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "delete image", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>

        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">//go:generate mockgen -source=image.go -destination=tests/mocks/image.go -package=mocks

package grpc

import (
        "context"

        pb "kudago/internal/image/api"
        "kudago/internal/logger"
        "kudago/internal/models"
)

const (
        ErrInternal = "internal error"
)

type ServerAPI struct {
        pb.UnimplementedImageServiceServer
        service ImageService
        logger  *logger.Logger
}

type ImageService interface {
        UploadImage(ctx context.Context, media models.MediaFile) (string, error)
        DeleteImage(ctx context.Context, imagePath string) error
}

func NewServerAPI(service ImageService, logger *logger.Logger) *ServerAPI <span class="cov8" title="1">{
        return &amp;ServerAPI{
                service: service,
                logger:  logger,
        }
}</span>
</pre>
		
		<pre class="file" id="file118" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: image.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        models "kudago/internal/models"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockImageService is a mock of ImageService interface.
type MockImageService struct {
        ctrl     *gomock.Controller
        recorder *MockImageServiceMockRecorder
}

// MockImageServiceMockRecorder is the mock recorder for MockImageService.
type MockImageServiceMockRecorder struct {
        mock *MockImageService
}

// NewMockImageService creates a new mock instance.
func NewMockImageService(ctrl *gomock.Controller) *MockImageService <span class="cov8" title="1">{
        mock := &amp;MockImageService{ctrl: ctrl}
        mock.recorder = &amp;MockImageServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockImageService) EXPECT() *MockImageServiceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// DeleteImage mocks base method.
func (m *MockImageService) DeleteImage(ctx context.Context, imagePath string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteImage", ctx, imagePath)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteImage indicates an expected call of DeleteImage.
func (mr *MockImageServiceMockRecorder) DeleteImage(ctx, imagePath interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteImage", reflect.TypeOf((*MockImageService)(nil).DeleteImage), ctx, imagePath)
}</span>

// UploadImage mocks base method.
func (m *MockImageService) UploadImage(ctx context.Context, media models.MediaFile) (string, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UploadImage", ctx, media)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UploadImage indicates an expected call of UploadImage.
func (mr *MockImageServiceMockRecorder) UploadImage(ctx, media interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UploadImage", reflect.TypeOf((*MockImageService)(nil).UploadImage), ctx, media)
}</span>
</pre>
		
		<pre class="file" id="file119" style="display: none">package grpc

import (
        "bytes"
        "context"

        pb "kudago/internal/image/api"
        "kudago/internal/models"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) UploadImage(ctx context.Context, req *pb.UploadRequest) (*pb.UploadResponse, error) <span class="cov8" title="1">{
        file := bytes.NewReader(req.File)

        mediaFile := models.MediaFile{
                Filename: req.Filename,
                File:     &amp;readSeekCloser{Reader: file},
        }

        url, err := s.service.UploadImage(ctx, mediaFile)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "upload image", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.UploadResponse{
                FileUrl: url,
        }
        return resp, nil</span>
}

type readSeekCloser struct {
        *bytes.Reader
}

func (r *readSeekCloser) Close() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file120" style="display: none">package images

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"

        "kudago/internal/models"
)

type ImageDB struct {
        UploadPath string
}

type ImageConfig struct {
        Path string
}

func NewDB(config ImageConfig) *ImageDB <span class="cov0" title="0">{
        return &amp;ImageDB{UploadPath: config.Path}
}</span>

func (r *ImageDB) UploadImage(ctx context.Context, media models.MediaFile) (string, error) <span class="cov0" title="0">{
        defer media.File.Close()

        buffer := make([]byte, 512)
        if _, err := media.File.Read(buffer); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov0" title="0">fileType := http.DetectContentType(buffer)
        if !isSupportedImageType(fileType) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", models.LevelDB, models.ErrUnsupportedFile)
        }</span>

        <span class="cov0" title="0">if _, err := media.File.Seek(0, io.SeekStart); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov0" title="0">newPath := filepath.Join(r.UploadPath, media.Filename)
        if err := os.MkdirAll(r.UploadPath, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", models.LevelDB, models.ErrUnsupportedFile)
        }</span>

        <span class="cov0" title="0">newFile, err := os.Create(newPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", models.LevelDB, models.ErrUnsupportedFile)
        }</span>
        <span class="cov0" title="0">defer newFile.Close()

        _, err = io.Copy(newFile, media.File)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", models.LevelDB, models.ErrUnsupportedFile)
        }</span>
        <span class="cov0" title="0">return newPath, nil</span>
}

func (r *ImageDB) DeleteImage(ctx context.Context, imagePath string) error <span class="cov0" title="0">{
        if _, err := os.Stat(imagePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", models.LevelDB, models.ErrNotFound)
        }</span>

        <span class="cov0" title="0">if err := os.Remove(imagePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", models.LevelDB, models.ErrUnsupportedFile)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func isSupportedImageType(fileType string) bool <span class="cov0" title="0">{
        supportedTypes := map[string]bool{
                "image/jpeg": true,
                "image/jpg":  true,
                "image/png":  true,
                "image/gif":  true,
        }

        return supportedTypes[fileType]
}</span>
</pre>
		
		<pre class="file" id="file121" style="display: none">package interceptors

import (
        "context"
        "time"

        "kudago/internal/metrics"

        "google.golang.org/grpc"
)

func MetricsUnaryInterceptor(serviceName string) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                req interface{},
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (interface{}, error) </span><span class="cov0" title="0">{
                start := time.Now()

                resp, err := handler(ctx, req)
                duration := time.Since(start).Seconds()

                statusCode := "OK"
                if err != nil </span><span class="cov0" title="0">{
                        statusCode = "ERROR"
                }</span>

                <span class="cov0" title="0">metrics.RequestDuration.WithLabelValues(info.FullMethod, "gRPC", serviceName, statusCode).Observe(duration)
                metrics.RequestCount.WithLabelValues(info.FullMethod, "gRPC", serviceName, statusCode).Inc()

                if err != nil </span><span class="cov0" title="0">{
                        metrics.ErrorCount.WithLabelValues(info.FullMethod, "gRPC", serviceName, statusCode).Inc()
                }</span>

                <span class="cov0" title="0">return resp, err</span>
        }
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package interceptors

import (
        "context"
        "log"

        "google.golang.org/grpc"
)

func PanicRecoveryInterceptor(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
) (interface{}, error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        log.Printf("Panic intercepted in method %s: %v", info.FullMethod, r)
                }</span>
        }()

        <span class="cov0" title="0">return handler(ctx, req)</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">package logger

import (
        "context"

        "kudago/internal/gateway/utils"

        "github.com/jackc/pgx/v5"
        "go.uber.org/zap"
)

type Logger struct {
        Logger *zap.SugaredLogger
}

func NewLogger() (*Logger, error) <span class="cov8" title="1">{
        zapLogger, err := zap.NewProduction()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;Logger{Logger: zapLogger.Sugar()}, nil</span>
}

func (l *Logger) TraceQueryStart(ctx context.Context, conn *pgx.Conn, data pgx.TraceQueryStartData) context.Context <span class="cov0" title="0">{
        requestID := utils.GetRequestIDFromContext(ctx)
        l.Logger.Infow("Query",
                "request_id", requestID,
                "sql", data.SQL,
                "args", data.Args,
        )
        return ctx
}</span>

func (l *Logger) TraceQueryEnd(ctx context.Context, conn *pgx.Conn, data pgx.TraceQueryEndData) <span class="cov0" title="0">{
        requestID := utils.GetRequestIDFromContext(ctx)
        if data.Err != nil </span><span class="cov0" title="0">{
                l.Logger.Errorw("Query failed",
                        "request_id", requestID,
                        "commandTag", data.CommandTag,
                        "args", data.Err,
                )
        }</span>
}

func (l *Logger) Error(ctx context.Context, method string, err error) <span class="cov8" title="1">{
        requestID := utils.GetRequestIDFromContext(ctx)
        l.Logger.Errorf("request_id: %s, method: %s, failed : %v", requestID, method, zap.Error(err))
}</span>
</pre>
		
		<pre class="file" id="file124" style="display: none">package metrics

import (
        "github.com/prometheus/client_golang/prometheus"
)

var (
        RequestDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_request_duration_seconds",
                        Help:    "Histogram of response times for handler in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"path", "method", "service", "status_code"},
        )

        RequestCount = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "http_requests_total",
                        Help: "Total number of requests",
                },
                []string{"path", "method", "service", "status_code"},
        )

        ErrorCount = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "http_errors_total",
                        Help: "Total number of error requests",
                },
                []string{"path", "method", "service", "status_code"},
        )
)

func InitMetrics() <span class="cov0" title="0">{
        prometheus.MustRegister(RequestDuration)
        prometheus.MustRegister(RequestCount)
        prometheus.MustRegister(ErrorCount)
}</span>
</pre>
		
		<pre class="file" id="file125" style="display: none">package middleware

import (
        "context"
        "net/http"
        "strings"
        "time"

        pb "kudago/internal/auth/api"
        httpErrors "kudago/internal/gateway/errors"
        "kudago/internal/gateway/utils"
        "kudago/internal/models"

        "google.golang.org/grpc"
)

const (
        SessionToken = "session_token"
        SessionKey   = "session"
)

var whitelist = []string{
        "/login",
        "/register",
        "/events",
        "/static",
        "/session",
        "/logout",
        "/docs",
        "/categories",
        "/swagger",
        "/profile",
        "/metrics",
}

type sessionChecker interface {
        CheckSession(ctx context.Context, req *pb.CheckSessionRequest, opts ...grpc.CallOption) (*pb.Session, error)
}

func AuthMiddleware(sessionChecker sessionChecker, next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                cookie, err := r.Cookie(SessionToken)
                if err == nil </span><span class="cov0" title="0">{
                        req := &amp;pb.CheckSessionRequest{
                                Cookie: cookie.Value,
                        }

                        sessionPB, err := sessionChecker.CheckSession(r.Context(), req)
                        if err == nil </span><span class="cov0" title="0">{
                                session := sessionPBToSession(sessionPB)
                                ctx := utils.SetSessionInContext(r.Context(), session)
                                r = r.WithContext(ctx)
                                next.ServeHTTP(w, r)
                                return
                        }</span>
                }

                <span class="cov0" title="0">for _, path := range whitelist </span><span class="cov0" title="0">{
                        if strings.HasPrefix(r.URL.Path, path) </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>
                }

                <span class="cov0" title="0">utils.WriteResponse(w, http.StatusUnauthorized, httpErrors.ErrUnauthorized)
                return</span>
        })
}

func sessionPBToSession(sessionPB *pb.Session) models.Session <span class="cov0" title="0">{
        expires, _ := time.Parse(time.RFC3339, sessionPB.Expires)
        return models.Session{
                UserID:  int(sessionPB.UserID),
                Token:   sessionPB.Token,
                Expires: expires,
        }
}</span>
</pre>
		
		<pre class="file" id="file126" style="display: none">package middleware

import (
        "net/http"
)

func CORSMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Устанавливаем CORS-заголовки
                origin := r.Header.Get("Origin")
                allowedOrigins := []string{
                        "http://localhost",       // Клиент на порту 80
                        "http://vyhodnoy.online", // Другой разрешенный домен
                        "http://37.139.40.252",
                        "http://37.139.40.252:8080",
                        "http://127.0.0.1",
                        "http://127.0.0.1:8080",
                }

                // Проверка на разрешенные домены
                for _, allowedOrigin := range allowedOrigins </span><span class="cov0" title="0">{
                        if origin == allowedOrigin </span><span class="cov0" title="0">{
                                w.Header().Set("Access-Control-Allow-Origin", allowedOrigin)
                                break</span>
                        }
                }
                <span class="cov0" title="0">w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS, PUT, DELETE")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
                w.Header().Set("Access-Control-Allow-Credentials", "true")

                // Обработка preflight-запросов
                if r.Method == http.MethodOptions </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusNoContent)
                        return
                }</span>

                // Передаем управление следующему обработчику
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file127" style="display: none">package middleware

import (
        "net/http"
        "time"

        "kudago/internal/gateway/utils"

        "github.com/google/uuid"
        "go.uber.org/zap"
)

type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

func NewResponseWriter(w http.ResponseWriter, requestID string) *responseWriter <span class="cov0" title="0">{
        rw := responseWriter{w, http.StatusOK}
        rw.Header().Add("X-Request-ID", requestID)
        return &amp;rw
}</span>

func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

func LoggingMiddleware(next http.Handler, logger *zap.SugaredLogger) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()
                requestID := uuid.New().String()

                r = r.WithContext(utils.SetRequestIDInContext(r.Context(), requestID))
                wrappedWriter := NewResponseWriter(w, requestID)
                next.ServeHTTP(wrappedWriter, r)
                utils.LogRequestData(r.Context(), logger, "http request", wrappedWriter.statusCode, r.Method, r.URL.Path, r.RemoteAddr, time.Since(start), nil)
        }</span>)
}
</pre>
		
		<pre class="file" id="file128" style="display: none">package middleware

import (
        "net/http"
        "regexp"
        "time"

        "kudago/internal/metrics"
)

func MetricsMiddleware(next http.Handler, serviceName string) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()

                ww := &amp;responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

                next.ServeHTTP(ww, r)

                duration := time.Since(start).Seconds()

                path := r.URL.Path
                re := regexp.MustCompile(`/(.*?)/\d+$`)
                if re.MatchString(r.URL.Path) </span><span class="cov0" title="0">{
                        path = re.ReplaceAllString(r.URL.Path, "/$1/{id}")
                }</span>

                <span class="cov0" title="0">if matched, _ := regexp.MatchString(`^/static/images/`, path); matched </span><span class="cov0" title="0">{
                        path = "/static/images"
                }</span>

                <span class="cov0" title="0">metrics.RequestDuration.WithLabelValues(path, r.Method, serviceName, http.StatusText(ww.statusCode)).Observe(duration)
                metrics.RequestCount.WithLabelValues(path, r.Method, serviceName, http.StatusText(ww.statusCode)).Inc()

                if ww.statusCode &gt;= 400 </span><span class="cov0" title="0">{
                        metrics.ErrorCount.WithLabelValues(path, r.Method, serviceName, http.StatusText(ww.statusCode)).Inc()
                }</span>
        })
}
</pre>
		
		<pre class="file" id="file129" style="display: none">package middleware

import (
        "net/http"
)

func PanicMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Internal server error", http.StatusInternalServerError)
                        }</span>
                }()
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file130" style="display: none">package models

import "errors"

var (
        ErrEventNotFound       = errors.New("event not found")
        ErrAccessDenied        = errors.New("user has no access to event")
        ErrUserNotFound        = errors.New("user not found")
        ErrInternal            = errors.New("internal error")
        ErrInvalidCategory     = errors.New("invalid category")
        ErrInvalidImageFormat  = errors.New("invalid image format")
        ErrInvalidImage        = errors.New("invalid image")
        ErrUnsupportedFile     = errors.New("unsupported file type")
        ErrForeignKeyViolation = errors.New("violates foreign key constraint")
        ErrNotFound            = errors.New("not found")
        ErrNothingToInsert     = errors.New("nothing to insert")
)

const (
        LevelDB      string = "DB"
        LevelService string = "Service"
        LevelHandler string = "Handler"
)

type AuthError struct {
        Field   string `json:"field"`
        Message string `json:"error"`
}

var (
        ErrEmailIsUsed = &amp;AuthError{
                Field:   "email",
                Message: "email is already used",
        }

        ErrUsernameIsUsed = &amp;AuthError{
                Field:   "username",
                Message: "user already exists",
        }
)

func (e AuthError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>
</pre>
		
		<pre class="file" id="file131" style="display: none">// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package models

import (
        json "encoding/json"
        easyjson "github.com/mailru/easyjson"
        jlexer "github.com/mailru/easyjson/jlexer"
        jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
        _ *json.RawMessage
        _ *jlexer.Lexer
        _ *jwriter.Writer
        _ easyjson.Marshaler
)

func easyjson9806e1DecodeKudagoInternalModels(in *jlexer.Lexer, out *Notification) <span class="cov8" title="1">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov8" title="1">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov8" title="1">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov8" title="1">switch key </span>{
                case "id":<span class="cov8" title="1">
                        out.ID = int(in.Int())</span>
                case "user_id":<span class="cov8" title="1">
                        out.UserID = int(in.Int())</span>
                case "event_id":<span class="cov8" title="1">
                        out.EventID = int(in.Int())</span>
                case "notify_at":<span class="cov8" title="1">
                        if data := in.Raw(); in.Ok() </span><span class="cov8" title="1">{
                                in.AddError((out.NotifyAt).UnmarshalJSON(data))
                        }</span>
                case "message":<span class="cov8" title="1">
                        out.Message = string(in.String())</span>
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov8" title="1">in.WantComma()</span>
        }
        <span class="cov8" title="1">in.Delim('}')
        if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjson9806e1EncodeKudagoInternalModels(out *jwriter.Writer, in Notification) <span class="cov8" title="1">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov8" title="1">{
                const prefix string = ",\"id\":"
                out.RawString(prefix[1:])
                out.Int(int(in.ID))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"user_id\":"
                out.RawString(prefix)
                out.Int(int(in.UserID))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"event_id\":"
                out.RawString(prefix)
                out.Int(int(in.EventID))
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"notify_at\":"
                out.RawString(prefix)
                out.Raw((in.NotifyAt).MarshalJSON())
        }</span>
        <span class="cov8" title="1">{
                const prefix string = ",\"message\":"
                out.RawString(prefix)
                out.String(string(in.Message))
        }</span>
        <span class="cov8" title="1">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v Notification) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjson9806e1EncodeKudagoInternalModels(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Notification) MarshalEasyJSON(w *jwriter.Writer) <span class="cov8" title="1">{
        easyjson9806e1EncodeKudagoInternalModels(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Notification) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        r := jlexer.Lexer{Data: data}
        easyjson9806e1DecodeKudagoInternalModels(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Notification) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov8" title="1">{
        easyjson9806e1DecodeKudagoInternalModels(l, v)
}</span>
</pre>
		
		<pre class="file" id="file132" style="display: none">// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package models

import (
        json "encoding/json"
        easyjson "github.com/mailru/easyjson"
        jlexer "github.com/mailru/easyjson/jlexer"
        jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
        _ *json.RawMessage
        _ *jlexer.Lexer
        _ *jwriter.Writer
        _ easyjson.Marshaler
)

func easyjson9e1087fdDecodeKudagoInternalModels(in *jlexer.Lexer, out *User) <span class="cov8" title="1">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov8" title="1">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov0" title="0">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov0" title="0">switch key </span>{
                case "id":<span class="cov0" title="0">
                        out.ID = int(in.Int())</span>
                case "username":<span class="cov0" title="0">
                        out.Username = string(in.String())</span>
                case "email":<span class="cov0" title="0">
                        out.Email = string(in.String())</span>
                case "password":<span class="cov0" title="0">
                        out.Password = string(in.String())</span>
                case "image":<span class="cov0" title="0">
                        out.ImageURL = string(in.String())</span>
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov0" title="0">in.WantComma()</span>
        }
        <span class="cov8" title="1">in.Delim('}')
        if isTopLevel </span><span class="cov8" title="1">{
                in.Consumed()
        }</span>
}
func easyjson9e1087fdEncodeKudagoInternalModels(out *jwriter.Writer, in User) <span class="cov0" title="0">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov0" title="0">{
                const prefix string = ",\"id\":"
                out.RawString(prefix[1:])
                out.Int(int(in.ID))
        }</span>
        <span class="cov0" title="0">{
                const prefix string = ",\"username\":"
                out.RawString(prefix)
                out.String(string(in.Username))
        }</span>
        <span class="cov0" title="0">{
                const prefix string = ",\"email\":"
                out.RawString(prefix)
                out.String(string(in.Email))
        }</span>
        <span class="cov0" title="0">{
                const prefix string = ",\"password\":"
                out.RawString(prefix)
                out.String(string(in.Password))
        }</span>
        <span class="cov0" title="0">{
                const prefix string = ",\"image\":"
                out.RawString(prefix)
                out.String(string(in.ImageURL))
        }</span>
        <span class="cov0" title="0">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v User) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjson9e1087fdEncodeKudagoInternalModels(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v User) MarshalEasyJSON(w *jwriter.Writer) <span class="cov0" title="0">{
        easyjson9e1087fdEncodeKudagoInternalModels(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *User) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        r := jlexer.Lexer{Data: data}
        easyjson9e1087fdDecodeKudagoInternalModels(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *User) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjson9e1087fdDecodeKudagoInternalModels(l, v)
}</span>
</pre>
		
		<pre class="file" id="file133" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.35.2
//         protoc        v3.12.4
// source: notification.proto

package notification

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type GetNotificationsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserID int32 `protobuf:"varint,1,opt,name=user_iD,json=userID,proto3" json:"user_iD,omitempty"`
}

func (x *GetNotificationsRequest) Reset() <span class="cov0" title="0">{
        *x = GetNotificationsRequest{}
        mi := &amp;file_notification_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetNotificationsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetNotificationsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetNotificationsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_notification_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetNotificationsRequest.ProtoReflect.Descriptor instead.
func (*GetNotificationsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_notification_proto_rawDescGZIP(), []int{0}
}</span>

func (x *GetNotificationsRequest) GetUserID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetNotificationsResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Notifications []*Notification `protobuf:"bytes,1,rep,name=notifications,proto3" json:"notifications,omitempty"`
}

func (x *GetNotificationsResponse) Reset() <span class="cov0" title="0">{
        *x = GetNotificationsResponse{}
        mi := &amp;file_notification_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetNotificationsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetNotificationsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetNotificationsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_notification_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetNotificationsResponse.ProtoReflect.Descriptor instead.
func (*GetNotificationsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_notification_proto_rawDescGZIP(), []int{1}
}</span>

func (x *GetNotificationsResponse) GetNotifications() []*Notification <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Notifications
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Notification struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id       int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        UserID   int32  `protobuf:"varint,2,opt,name=user_iD,json=userID,proto3" json:"user_iD,omitempty"`
        EventID  int32  `protobuf:"varint,3,opt,name=event_iD,json=eventID,proto3" json:"event_iD,omitempty"`
        Message  string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
        NotifyAt string `protobuf:"bytes,5,opt,name=notifyAt,proto3" json:"notifyAt,omitempty"`
}

func (x *Notification) Reset() <span class="cov0" title="0">{
        *x = Notification{}
        mi := &amp;file_notification_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Notification) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Notification) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Notification) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_notification_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Notification.ProtoReflect.Descriptor instead.
func (*Notification) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_notification_proto_rawDescGZIP(), []int{2}
}</span>

func (x *Notification) GetId() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Notification) GetUserID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Notification) GetEventID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EventID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Notification) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Notification) GetNotifyAt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotifyAt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteNotificationRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *DeleteNotificationRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteNotificationRequest{}
        mi := &amp;file_notification_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteNotificationRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteNotificationRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteNotificationRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_notification_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteNotificationRequest.ProtoReflect.Descriptor instead.
func (*DeleteNotificationRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_notification_proto_rawDescGZIP(), []int{3}
}</span>

func (x *DeleteNotificationRequest) GetId() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CreateNotificationsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserIDs      []int32       `protobuf:"varint,1,rep,packed,name=UserIDs,proto3" json:"UserIDs,omitempty"`
        Notification *Notification `protobuf:"bytes,2,opt,name=notification,proto3" json:"notification,omitempty"`
}

func (x *CreateNotificationsRequest) Reset() <span class="cov0" title="0">{
        *x = CreateNotificationsRequest{}
        mi := &amp;file_notification_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateNotificationsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateNotificationsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateNotificationsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_notification_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateNotificationsRequest.ProtoReflect.Descriptor instead.
func (*CreateNotificationsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_notification_proto_rawDescGZIP(), []int{4}
}</span>

func (x *CreateNotificationsRequest) GetUserIDs() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserIDs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CreateNotificationsRequest) GetNotification() *Notification <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Notification
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Empty struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *Empty) Reset() <span class="cov0" title="0">{
        *x = Empty{}
        mi := &amp;file_notification_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Empty) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Empty) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Empty) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_notification_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Empty.ProtoReflect.Descriptor instead.
func (*Empty) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_notification_proto_rawDescGZIP(), []int{5}
}</span>

var File_notification_proto protoreflect.FileDescriptor

var file_notification_proto_rawDesc = []byte{
        0x0a, 0x12, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x22, 0x32, 0x0a, 0x17, 0x47, 0x65, 0x74, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a,
        0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06,
        0x75, 0x73, 0x65, 0x72, 0x49, 0x44, 0x22, 0x5c, 0x0a, 0x18, 0x47, 0x65, 0x74, 0x4e, 0x6f, 0x74,
        0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x12, 0x40, 0x0a, 0x0d, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6e, 0x6f, 0x74, 0x69,
        0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0d, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x73, 0x22, 0x88, 0x01, 0x0a, 0x0c, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x05, 0x52, 0x02, 0x69, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x44,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x44, 0x12, 0x19,
        0x0a, 0x08, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x44, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05,
        0x52, 0x07, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73,
        0x73, 0x61, 0x67, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73,
        0x61, 0x67, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x79, 0x41, 0x74, 0x18,
        0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x79, 0x41, 0x74, 0x22,
        0x2b, 0x0a, 0x19, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02,
        0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x69, 0x64, 0x22, 0x76, 0x0a, 0x1a,
        0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x55, 0x73,
        0x65, 0x72, 0x49, 0x44, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x07, 0x55, 0x73, 0x65,
        0x72, 0x49, 0x44, 0x73, 0x12, 0x3e, 0x0a, 0x0c, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6e, 0x6f, 0x74,
        0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69,
        0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x22, 0x07, 0x0a, 0x05, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x32, 0xa2, 0x02,
        0x0a, 0x13, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x65,
        0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x61, 0x0a, 0x10, 0x47, 0x65, 0x74, 0x4e, 0x6f, 0x74, 0x69,
        0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x25, 0x2e, 0x6e, 0x6f, 0x74, 0x69,
        0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x47, 0x65, 0x74, 0x4e, 0x6f, 0x74, 0x69,
        0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x26, 0x2e, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
        0x47, 0x65, 0x74, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x54, 0x0a, 0x13, 0x43, 0x72, 0x65, 0x61,
        0x74, 0x65, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12,
        0x28, 0x2e, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x43,
        0x72, 0x65, 0x61, 0x74, 0x65, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x13, 0x2e, 0x6e, 0x6f, 0x74, 0x69,
        0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x52,
        0x0a, 0x12, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x12, 0x27, 0x2e, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69,
        0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x13, 0x2e,
        0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x45, 0x6d, 0x70,
        0x74, 0x79, 0x42, 0x11, 0x5a, 0x0f, 0x2e, 0x2f, 0x3b, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_notification_proto_rawDescOnce sync.Once
        file_notification_proto_rawDescData = file_notification_proto_rawDesc
)

func file_notification_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_notification_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_notification_proto_rawDescData = protoimpl.X.CompressGZIP(file_notification_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_notification_proto_rawDescData</span>
}

var file_notification_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_notification_proto_goTypes = []any{
        (*GetNotificationsRequest)(nil),    // 0: notification.GetNotificationsRequest
        (*GetNotificationsResponse)(nil),   // 1: notification.GetNotificationsResponse
        (*Notification)(nil),               // 2: notification.Notification
        (*DeleteNotificationRequest)(nil),  // 3: notification.DeleteNotificationRequest
        (*CreateNotificationsRequest)(nil), // 4: notification.CreateNotificationsRequest
        (*Empty)(nil),                      // 5: notification.Empty
}
var file_notification_proto_depIdxs = []int32{
        2, // 0: notification.GetNotificationsResponse.notifications:type_name -&gt; notification.Notification
        2, // 1: notification.CreateNotificationsRequest.notification:type_name -&gt; notification.Notification
        0, // 2: notification.NotificationService.GetNotifications:input_type -&gt; notification.GetNotificationsRequest
        4, // 3: notification.NotificationService.CreateNotifications:input_type -&gt; notification.CreateNotificationsRequest
        3, // 4: notification.NotificationService.DeleteNotification:input_type -&gt; notification.DeleteNotificationRequest
        1, // 5: notification.NotificationService.GetNotifications:output_type -&gt; notification.GetNotificationsResponse
        5, // 6: notification.NotificationService.CreateNotifications:output_type -&gt; notification.Empty
        5, // 7: notification.NotificationService.DeleteNotification:output_type -&gt; notification.Empty
        5, // [5:8] is the sub-list for method output_type
        2, // [2:5] is the sub-list for method input_type
        2, // [2:2] is the sub-list for extension type_name
        2, // [2:2] is the sub-list for extension extendee
        0, // [0:2] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_notification_proto_init() }</span>
func file_notification_proto_init() <span class="cov8" title="1">{
        if File_notification_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_notification_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   6,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_notification_proto_goTypes,
                DependencyIndexes: file_notification_proto_depIdxs,
                MessageInfos:      file_notification_proto_msgTypes,
        }.Build()
        File_notification_proto = out.File
        file_notification_proto_rawDesc = nil
        file_notification_proto_goTypes = nil
        file_notification_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: notification.proto

package notification

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        NotificationService_GetNotifications_FullMethodName    = "/notification.NotificationService/GetNotifications"
        NotificationService_CreateNotifications_FullMethodName = "/notification.NotificationService/CreateNotifications"
        NotificationService_DeleteNotification_FullMethodName  = "/notification.NotificationService/DeleteNotification"
)

// NotificationServiceClient is the client API for NotificationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NotificationServiceClient interface {
        GetNotifications(ctx context.Context, in *GetNotificationsRequest, opts ...grpc.CallOption) (*GetNotificationsResponse, error)
        CreateNotifications(ctx context.Context, in *CreateNotificationsRequest, opts ...grpc.CallOption) (*Empty, error)
        DeleteNotification(ctx context.Context, in *DeleteNotificationRequest, opts ...grpc.CallOption) (*Empty, error)
}

type notificationServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewNotificationServiceClient(cc grpc.ClientConnInterface) NotificationServiceClient <span class="cov0" title="0">{
        return &amp;notificationServiceClient{cc}
}</span>

func (c *notificationServiceClient) GetNotifications(ctx context.Context, in *GetNotificationsRequest, opts ...grpc.CallOption) (*GetNotificationsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetNotificationsResponse)
        err := c.cc.Invoke(ctx, NotificationService_GetNotifications_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *notificationServiceClient) CreateNotifications(ctx context.Context, in *CreateNotificationsRequest, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Empty)
        err := c.cc.Invoke(ctx, NotificationService_CreateNotifications_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *notificationServiceClient) DeleteNotification(ctx context.Context, in *DeleteNotificationRequest, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Empty)
        err := c.cc.Invoke(ctx, NotificationService_DeleteNotification_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// NotificationServiceServer is the server API for NotificationService service.
// All implementations must embed UnimplementedNotificationServiceServer
// for forward compatibility.
type NotificationServiceServer interface {
        GetNotifications(context.Context, *GetNotificationsRequest) (*GetNotificationsResponse, error)
        CreateNotifications(context.Context, *CreateNotificationsRequest) (*Empty, error)
        DeleteNotification(context.Context, *DeleteNotificationRequest) (*Empty, error)
        mustEmbedUnimplementedNotificationServiceServer()
}

// UnimplementedNotificationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNotificationServiceServer struct{}

func (UnimplementedNotificationServiceServer) GetNotifications(context.Context, *GetNotificationsRequest) (*GetNotificationsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetNotifications not implemented")
}</span>
func (UnimplementedNotificationServiceServer) CreateNotifications(context.Context, *CreateNotificationsRequest) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateNotifications not implemented")
}</span>
func (UnimplementedNotificationServiceServer) DeleteNotification(context.Context, *DeleteNotificationRequest) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteNotification not implemented")
}</span>
func (UnimplementedNotificationServiceServer) mustEmbedUnimplementedNotificationServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedNotificationServiceServer) testEmbeddedByValue()                             {<span class="cov0" title="0">}</span>

// UnsafeNotificationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotificationServiceServer will
// result in compilation errors.
type UnsafeNotificationServiceServer interface {
        mustEmbedUnimplementedNotificationServiceServer()
}

func RegisterNotificationServiceServer(s grpc.ServiceRegistrar, srv NotificationServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedNotificationServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;NotificationService_ServiceDesc, srv)</span>
}

func _NotificationService_GetNotifications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetNotificationsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NotificationServiceServer).GetNotifications(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: NotificationService_GetNotifications_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NotificationServiceServer).GetNotifications(ctx, req.(*GetNotificationsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _NotificationService_CreateNotifications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateNotificationsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NotificationServiceServer).CreateNotifications(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: NotificationService_CreateNotifications_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NotificationServiceServer).CreateNotifications(ctx, req.(*CreateNotificationsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _NotificationService_DeleteNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteNotificationRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(NotificationServiceServer).DeleteNotification(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: NotificationService_DeleteNotification_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(NotificationServiceServer).DeleteNotification(ctx, req.(*DeleteNotificationRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// NotificationService_ServiceDesc is the grpc.ServiceDesc for NotificationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NotificationService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "notification.NotificationService",
        HandlerType: (*NotificationServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetNotifications",
                        Handler:    _NotificationService_GetNotifications_Handler,
                },
                {
                        MethodName: "CreateNotifications",
                        Handler:    _NotificationService_CreateNotifications_Handler,
                },
                {
                        MethodName: "DeleteNotification",
                        Handler:    _NotificationService_DeleteNotification_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "notification.proto",
}
</pre>
		
		<pre class="file" id="file135" style="display: none">//go:generate mockgen -source=notification.go -destination=tests/mocks/notification.go -package=mocks

package grpc

import (
        "context"
        "strings"
        "time"

        "kudago/internal/logger"
        "kudago/internal/models"
        pb "kudago/internal/notification/api"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

const (
        layout      = "2006-01-02 15:04:05.999999999 -0700 MST"
        ErrInternal = "internal error"
)

type ServerAPI struct {
        pb.UnimplementedNotificationServiceServer
        service NotificationService
        logger  *logger.Logger
}

type NotificationService interface {
        GetNotifications(ctx context.Context, userID int) ([]models.Notification, error)
        CreateNotification(ctx context.Context, notification models.Notification) error
        CreateNotificationsByUserIDs(ctx context.Context, ids []int, ntf models.Notification) error
        DeleteNotification(ctx context.Context, ID int) error
        UpdateSentNotifications(ctx context.Context, IDs []int) error
}

func NewServerAPI(service NotificationService, logger *logger.Logger) *ServerAPI <span class="cov8" title="1">{
        return &amp;ServerAPI{
                service: service,
                logger:  logger,
        }
}</span>

func (s *ServerAPI) CreateInvitationNotification(ctx context.Context, req *pb.Notification) (*pb.Empty, error) <span class="cov8" title="1">{
        notifyAt, _ := time.Parse(layout, req.NotifyAt)

        ntf := models.Notification{
                UserID:   int(req.UserID),
                EventID:  int(req.EventID),
                NotifyAt: notifyAt,
                Message:  req.Message,
        }

        err := s.service.CreateNotification(ctx, ntf)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "create notification", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

func (s *ServerAPI) CreateNotifications(ctx context.Context, req *pb.CreateNotificationsRequest) (*pb.Empty, error) <span class="cov8" title="1">{
        ids := make([]int, 0, len(req.UserIDs))
        for _, id := range req.UserIDs </span><span class="cov8" title="1">{
                ids = append(ids, int(id))
        }</span>

        <span class="cov8" title="1">cleanTime := strings.Split(req.Notification.NotifyAt, " m=")[0]
        notifyAt, _ := time.Parse(layout, cleanTime)

        ntf := models.Notification{
                EventID:  int(req.Notification.EventID),
                NotifyAt: notifyAt,
                Message:  req.Notification.Message,
        }

        if err := s.service.CreateNotificationsByUserIDs(ctx, ids, ntf); err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "create notification by user ids", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

func (s *ServerAPI) GetNotifications(ctx context.Context, req *pb.GetNotificationsRequest) (*pb.GetNotificationsResponse, error) <span class="cov8" title="1">{
        notifications, err := s.service.GetNotifications(ctx, int(req.UserID))
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "get notifications", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>

        <span class="cov8" title="1">var ids []int
        for _, n := range notifications </span><span class="cov8" title="1">{
                ids = append(ids, n.EventID)
        }</span>

        <span class="cov8" title="1">err = s.service.UpdateSentNotifications(ctx, ids)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">resp := toGetNotificationsResponse(notifications)
        return resp, nil</span>
}

func toGetNotificationsResponse(notifications []models.Notification) *pb.GetNotificationsResponse <span class="cov8" title="1">{
        notificationsPB := make([]*pb.Notification, 0, len(notifications))

        for _, ntf := range notifications </span><span class="cov8" title="1">{
                temp := &amp;pb.Notification{
                        Id:       int32(ntf.ID),
                        UserID:   int32(ntf.UserID),
                        EventID:  int32(ntf.EventID),
                        Message:  ntf.Message,
                        NotifyAt: ntf.NotifyAt.String(),
                }
                notificationsPB = append(notificationsPB, temp)
        }</span>

        <span class="cov8" title="1">return &amp;pb.GetNotificationsResponse{
                Notifications: notificationsPB,
        }</span>
}

func (s *ServerAPI) DeleteNotification(ctx context.Context, req *pb.DeleteNotificationRequest) (*pb.Empty, error) <span class="cov8" title="1">{
        err := s.service.DeleteNotification(ctx, int(req.Id))
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "delete notification", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>

        <span class="cov8" title="1">return nil, nil</span>
}

func toNotificationModel(notification *pb.Notification) models.Notification <span class="cov0" title="0">{
        notifyAt, _ := time.Parse(time.RFC3339, notification.NotifyAt)

        return models.Notification{
                ID:       int(notification.Id),
                UserID:   int(notification.UserID),
                EventID:  int(notification.EventID),
                NotifyAt: notifyAt,
                Message:  notification.Message,
        }
}</span>
</pre>
		
		<pre class="file" id="file136" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: notification.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        models "kudago/internal/models"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockNotificationService is a mock of NotificationService interface.
type MockNotificationService struct {
        ctrl     *gomock.Controller
        recorder *MockNotificationServiceMockRecorder
}

// MockNotificationServiceMockRecorder is the mock recorder for MockNotificationService.
type MockNotificationServiceMockRecorder struct {
        mock *MockNotificationService
}

// NewMockNotificationService creates a new mock instance.
func NewMockNotificationService(ctrl *gomock.Controller) *MockNotificationService <span class="cov8" title="1">{
        mock := &amp;MockNotificationService{ctrl: ctrl}
        mock.recorder = &amp;MockNotificationServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNotificationService) EXPECT() *MockNotificationServiceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CreateNotification mocks base method.
func (m *MockNotificationService) CreateNotification(ctx context.Context, notification models.Notification) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateNotification", ctx, notification)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateNotification indicates an expected call of CreateNotification.
func (mr *MockNotificationServiceMockRecorder) CreateNotification(ctx, notification interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateNotification", reflect.TypeOf((*MockNotificationService)(nil).CreateNotification), ctx, notification)
}</span>

// CreateNotificationsByUserIDs mocks base method.
func (m *MockNotificationService) CreateNotificationsByUserIDs(ctx context.Context, ids []int, ntf models.Notification) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateNotificationsByUserIDs", ctx, ids, ntf)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateNotificationsByUserIDs indicates an expected call of CreateNotificationsByUserIDs.
func (mr *MockNotificationServiceMockRecorder) CreateNotificationsByUserIDs(ctx, ids, ntf interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateNotificationsByUserIDs", reflect.TypeOf((*MockNotificationService)(nil).CreateNotificationsByUserIDs), ctx, ids, ntf)
}</span>

// DeleteNotification mocks base method.
func (m *MockNotificationService) DeleteNotification(ctx context.Context, ID int) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteNotification", ctx, ID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteNotification indicates an expected call of DeleteNotification.
func (mr *MockNotificationServiceMockRecorder) DeleteNotification(ctx, ID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteNotification", reflect.TypeOf((*MockNotificationService)(nil).DeleteNotification), ctx, ID)
}</span>

// GetNotifications mocks base method.
func (m *MockNotificationService) GetNotifications(ctx context.Context, userID int) ([]models.Notification, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetNotifications", ctx, userID)
        ret0, _ := ret[0].([]models.Notification)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetNotifications indicates an expected call of GetNotifications.
func (mr *MockNotificationServiceMockRecorder) GetNotifications(ctx, userID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNotifications", reflect.TypeOf((*MockNotificationService)(nil).GetNotifications), ctx, userID)
}</span>

// UpdateSentNotifications mocks base method.
func (m *MockNotificationService) UpdateSentNotifications(ctx context.Context, IDs []int) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateSentNotifications", ctx, IDs)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateSentNotifications indicates an expected call of UpdateSentNotifications.
func (mr *MockNotificationServiceMockRecorder) UpdateSentNotifications(ctx, IDs interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateSentNotifications", reflect.TypeOf((*MockNotificationService)(nil).UpdateSentNotifications), ctx, IDs)
}</span>
</pre>
		
		<pre class="file" id="file137" style="display: none">package repository

import (
        "context"
        "fmt"

        "kudago/internal/models"

        "github.com/jackc/pgx/v5/pgxpool"
)

type NotificationDB struct {
        pool *pgxpool.Pool
}

func NewDB(pool *pgxpool.Pool) *NotificationDB <span class="cov0" title="0">{
        return &amp;NotificationDB{
                pool: pool,
        }
}</span>

const getNotificationsQuery = `
        SELECT id, user_id, event_id, notify_at, message
        FROM notification
        WHERE notify_at &lt;= NOW() AND is_sent = FALSE AND user_id=$1
    `

func (s *NotificationDB) GetNotifications(ctx context.Context, userID int) ([]models.Notification, error) <span class="cov0" title="0">{
        rows, err := s.pool.Query(ctx, getNotificationsQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var notifications []models.Notification
        for rows.Next() </span><span class="cov0" title="0">{
                var n models.Notification
                if err := rows.Scan(&amp;n.ID, &amp;n.UserID, &amp;n.EventID, &amp;n.NotifyAt, &amp;n.Message); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">notifications = append(notifications, n)</span>
        }

        <span class="cov0" title="0">return notifications, nil</span>
}

const updateSentNotificationsQuery = `
    UPDATE notification
    SET is_sent = TRUE
    WHERE id = $1
`

func (db *NotificationDB) UpdateSentNotifications(ctx context.Context, ids []int) error <span class="cov0" title="0">{
        tx, err := db.pool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback(ctx)

        for _, id := range ids </span><span class="cov0" title="0">{
                _, err = db.pool.Exec(ctx, updateSentNotificationsQuery, id)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>
        }

        <span class="cov0" title="0">err = tx.Commit(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

const deleteNotificationQuery = `DELETE FROM NOTIFICATION WHERE id=$1`

func (db *NotificationDB) DeleteNotification(ctx context.Context, ID int) error <span class="cov0" title="0">{
        _, err := db.pool.Exec(ctx, deleteNotificationQuery, ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

const createNotificationQuery = `
        INSERT INTO NOTIFICATION (user_id, event_id, message, notify_at)
        VALUES ($1, $2, $3, $4)
        `

func (db *NotificationDB) CreateNotification(ctx context.Context, notification models.Notification) error <span class="cov0" title="0">{
        _, err := db.pool.Exec(ctx, createNotificationQuery,
                notification.UserID,
                notification.EventID,
                notification.Message,
                notification.NotifyAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

const createNotificationsByUserIDsQuery = `
        INSERT INTO NOTIFICATION (user_id, event_id, message, notify_at)
        VALUES ($1, $2, $3, $4)
        `

func (db *NotificationDB) CreateNotificationsByUserIDs(ctx context.Context, ids []int, ntf models.Notification) error <span class="cov0" title="0">{
        tx, err := db.pool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback(ctx)

        for _, id := range ids </span><span class="cov0" title="0">{
                _, err = db.pool.Exec(ctx, createNotificationsByUserIDsQuery, id, ntf.EventID, ntf.Message, ntf.NotifyAt)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>
        }

        <span class="cov0" title="0">err = tx.Commit(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "fmt"
        "os"

        "github.com/pressly/goose/v3"

        "kudago/internal/logger"

        "github.com/jackc/pgx/v5/pgxpool"
        _ "github.com/jackc/pgx/v5/stdlib"
)

type PostgresConfig struct {
        User     string
        Password string
        Host     string
        Port     string
        DB       string
        URL      string
}

func GetPostgresConfig() (PostgresConfig, error) <span class="cov0" title="0">{
        var config PostgresConfig
        config.User = os.Getenv("POSTGRES_USER")
        config.Password = os.Getenv("POSTGRES_PASSWORD")
        config.Host = os.Getenv("POSTGRES_HOST")
        config.Port = os.Getenv("POSTGRES_PORT")
        config.DB = os.Getenv("POSTGRES_DB")
        config.URL = fmt.Sprintf("postgres://%s:%s@%s:%s/%s", config.User, config.Password, config.Host, config.Port, config.DB)
        return config, nil
}</span>

func InitPostgres(config PostgresConfig, logger *logger.Logger) (*pgxpool.Pool, error) <span class="cov0" title="0">{
        dbConf, err := pgxpool.ParseConfig(config.URL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to parse db URL: %v", err)
        }</span>

        <span class="cov0" title="0">dbConf.ConnConfig.Tracer = logger
        pool, err := pgxpool.NewWithConfig(context.Background(), dbConf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to connect to db pgxpool: %v", err)
        }</span>

        <span class="cov0" title="0">postgresPing := pool.Ping(context.Background())
        if postgresPing != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to connect to db ping: %v", postgresPing)
        }</span>

        <span class="cov0" title="0">if err := RunMigrations(config.URL); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to run migrations: %v", err)
        }</span>

        <span class="cov0" title="0">return pool, nil</span>
}

func RunMigrations(dbURL string) error <span class="cov0" title="0">{
        migrationsDir := os.Getenv("MIGRATION_FOLDER")
        if migrationsDir == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("MIGRATION_FOLDER environment variable is not set")
        }</span>

        <span class="cov0" title="0">sqlDB, err := sql.Open("pgx", dbURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to open db: %v", err)
        }</span>
        <span class="cov0" title="0">defer sqlDB.Close()

        if err := goose.Up(sqlDB, migrationsDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to run migrations: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">package redisDB

import (
        "fmt"
        "os"

        "github.com/joho/godotenv"
)

type RedisConfig struct {
        Host     string
        Port     string
        Password string
        URL      string
        DB       int
        PoolSize int
}

func GetRedisConfig() (*RedisConfig, error) <span class="cov0" title="0">{
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error in loading .env: %v", err)
        }</span>

        <span class="cov0" title="0">var config RedisConfig
        config.Password = os.Getenv("REDIS_PASSWORD")
        config.Host = os.Getenv("REDIS_HOST")
        config.Port = os.Getenv("REDIS_PORT")
        config.URL = fmt.Sprintf("%s:%s", config.Host, config.Port)

        return &amp;config, nil</span>
}
</pre>
		
		<pre class="file" id="file140" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.35.2
//         protoc        v3.12.4
// source: user.proto

package user

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type GetUserByIDRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (x *GetUserByIDRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserByIDRequest{}
        mi := &amp;file_user_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserByIDRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserByIDRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserByIDRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserByIDRequest.ProtoReflect.Descriptor instead.
func (*GetUserByIDRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{0}
}</span>

func (x *GetUserByIDRequest) GetID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetSubscriptionsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (x *GetSubscriptionsRequest) Reset() <span class="cov0" title="0">{
        *x = GetSubscriptionsRequest{}
        mi := &amp;file_user_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSubscriptionsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSubscriptionsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSubscriptionsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSubscriptionsRequest.ProtoReflect.Descriptor instead.
func (*GetSubscriptionsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{1}
}</span>

func (x *GetSubscriptionsRequest) GetID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetSubscriptionsResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Users []*User `protobuf:"bytes,1,rep,name=users,proto3" json:"users,omitempty"`
}

func (x *GetSubscriptionsResponse) Reset() <span class="cov0" title="0">{
        *x = GetSubscriptionsResponse{}
        mi := &amp;file_user_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSubscriptionsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSubscriptionsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSubscriptionsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSubscriptionsResponse.ProtoReflect.Descriptor instead.
func (*GetSubscriptionsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetSubscriptionsResponse) GetUsers() []*User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Users
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Subscription struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        SubscriberID int32 `protobuf:"varint,1,opt,name=subscriberID,proto3" json:"subscriberID,omitempty"`
        FollowsID    int32 `protobuf:"varint,2,opt,name=followsID,proto3" json:"followsID,omitempty"`
}

func (x *Subscription) Reset() <span class="cov0" title="0">{
        *x = Subscription{}
        mi := &amp;file_user_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Subscription) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Subscription) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Subscription) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Subscription.ProtoReflect.Descriptor instead.
func (*Subscription) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{3}
}</span>

func (x *Subscription) GetSubscriberID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SubscriberID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Subscription) GetFollowsID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FollowsID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type User struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ID        int32  `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
        Username  string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
        Email     string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
        AvatarUrl string `protobuf:"bytes,4,opt,name=avatar_url,json=avatarUrl,proto3" json:"avatar_url,omitempty"`
}

func (x *User) Reset() <span class="cov0" title="0">{
        *x = User{}
        mi := &amp;file_user_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *User) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*User) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *User) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{4}
}</span>

func (x *User) GetID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *User) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetAvatarUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AvatarUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetSubscribersRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (x *GetSubscribersRequest) Reset() <span class="cov0" title="0">{
        *x = GetSubscribersRequest{}
        mi := &amp;file_user_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSubscribersRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSubscribersRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSubscribersRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSubscribersRequest.ProtoReflect.Descriptor instead.
func (*GetSubscribersRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{5}
}</span>

func (x *GetSubscribersRequest) GetID() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetSubscribersResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Users []*User `protobuf:"bytes,1,rep,name=users,proto3" json:"users,omitempty"`
}

func (x *GetSubscribersResponse) Reset() <span class="cov0" title="0">{
        *x = GetSubscribersResponse{}
        mi := &amp;file_user_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSubscribersResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSubscribersResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSubscribersResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSubscribersResponse.ProtoReflect.Descriptor instead.
func (*GetSubscribersResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{6}
}</span>

func (x *GetSubscribersResponse) GetUsers() []*User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Users
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Empty struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *Empty) Reset() <span class="cov0" title="0">{
        *x = Empty{}
        mi := &amp;file_user_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Empty) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Empty) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Empty) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Empty.ProtoReflect.Descriptor instead.
func (*Empty) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{7}
}</span>

var File_user_proto protoreflect.FileDescriptor

var file_user_proto_rawDesc = []byte{
        0x0a, 0x0a, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x04, 0x75, 0x73,
        0x65, 0x72, 0x22, 0x24, 0x0a, 0x12, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x42, 0x79, 0x49,
        0x44, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x44, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x49, 0x44, 0x22, 0x29, 0x0a, 0x17, 0x47, 0x65, 0x74, 0x53,
        0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x02, 0x49, 0x44, 0x22, 0x3c, 0x0a, 0x18, 0x47, 0x65, 0x74, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72,
        0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x20, 0x0a, 0x05, 0x75, 0x73, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0a,
        0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x05, 0x75, 0x73, 0x65, 0x72,
        0x73, 0x22, 0x50, 0x0a, 0x0c, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x12, 0x22, 0x0a, 0x0c, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x72, 0x49,
        0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0c, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69,
        0x62, 0x65, 0x72, 0x49, 0x44, 0x12, 0x1c, 0x0a, 0x09, 0x66, 0x6f, 0x6c, 0x6c, 0x6f, 0x77, 0x73,
        0x49, 0x44, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x09, 0x66, 0x6f, 0x6c, 0x6c, 0x6f, 0x77,
        0x73, 0x49, 0x44, 0x22, 0x67, 0x0a, 0x04, 0x55, 0x73, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02, 0x49,
        0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x49, 0x44, 0x12, 0x1a, 0x0a, 0x08, 0x75,
        0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75,
        0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c,
        0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x1d, 0x0a,
        0x0a, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x09, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72, 0x55, 0x72, 0x6c, 0x22, 0x27, 0x0a, 0x15,
        0x47, 0x65, 0x74, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x72, 0x73, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x05, 0x52, 0x02, 0x49, 0x44, 0x22, 0x3a, 0x0a, 0x16, 0x47, 0x65, 0x74, 0x53, 0x75, 0x62, 0x73,
        0x63, 0x72, 0x69, 0x62, 0x65, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x20, 0x0a, 0x05, 0x75, 0x73, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0a,
        0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x05, 0x75, 0x73, 0x65, 0x72,
        0x73, 0x22, 0x07, 0x0a, 0x05, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x32, 0xe6, 0x02, 0x0a, 0x0b, 0x55,
        0x73, 0x65, 0x72, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x33, 0x0a, 0x0b, 0x47, 0x65,
        0x74, 0x55, 0x73, 0x65, 0x72, 0x42, 0x79, 0x49, 0x44, 0x12, 0x18, 0x2e, 0x75, 0x73, 0x65, 0x72,
        0x2e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x42, 0x79, 0x49, 0x44, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x1a, 0x0a, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x12,
        0x2c, 0x0a, 0x09, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x12, 0x12, 0x2e, 0x75,
        0x73, 0x65, 0x72, 0x2e, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x1a, 0x0b, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x2e, 0x0a,
        0x0b, 0x55, 0x6e, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x12, 0x12, 0x2e, 0x75,
        0x73, 0x65, 0x72, 0x2e, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x1a, 0x0b, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x51, 0x0a,
        0x10, 0x47, 0x65, 0x74, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x12, 0x1d, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x75, 0x62, 0x73,
        0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x1e, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x75, 0x62, 0x73, 0x63,
        0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x4b, 0x0a, 0x0e, 0x47, 0x65, 0x74, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65,
        0x72, 0x73, 0x12, 0x1b, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x75, 0x62,
        0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
        0x1c, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72,
        0x69, 0x62, 0x65, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x24, 0x0a,
        0x0a, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x12, 0x0a, 0x2e, 0x75, 0x73,
        0x65, 0x72, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x1a, 0x0a, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x55,
        0x73, 0x65, 0x72, 0x42, 0x09, 0x5a, 0x07, 0x2e, 0x2f, 0x3b, 0x75, 0x73, 0x65, 0x72, 0x62, 0x06,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_user_proto_rawDescOnce sync.Once
        file_user_proto_rawDescData = file_user_proto_rawDesc
)

func file_user_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_user_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_user_proto_rawDescData = protoimpl.X.CompressGZIP(file_user_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_user_proto_rawDescData</span>
}

var file_user_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_user_proto_goTypes = []any{
        (*GetUserByIDRequest)(nil),       // 0: user.GetUserByIDRequest
        (*GetSubscriptionsRequest)(nil),  // 1: user.GetSubscriptionsRequest
        (*GetSubscriptionsResponse)(nil), // 2: user.GetSubscriptionsResponse
        (*Subscription)(nil),             // 3: user.Subscription
        (*User)(nil),                     // 4: user.User
        (*GetSubscribersRequest)(nil),    // 5: user.GetSubscribersRequest
        (*GetSubscribersResponse)(nil),   // 6: user.GetSubscribersResponse
        (*Empty)(nil),                    // 7: user.Empty
}
var file_user_proto_depIdxs = []int32{
        4, // 0: user.GetSubscriptionsResponse.users:type_name -&gt; user.User
        4, // 1: user.GetSubscribersResponse.users:type_name -&gt; user.User
        0, // 2: user.UserService.GetUserByID:input_type -&gt; user.GetUserByIDRequest
        3, // 3: user.UserService.Subscribe:input_type -&gt; user.Subscription
        3, // 4: user.UserService.Unsubscribe:input_type -&gt; user.Subscription
        1, // 5: user.UserService.GetSubscriptions:input_type -&gt; user.GetSubscriptionsRequest
        5, // 6: user.UserService.GetSubscribers:input_type -&gt; user.GetSubscribersRequest
        4, // 7: user.UserService.UpdateUser:input_type -&gt; user.User
        4, // 8: user.UserService.GetUserByID:output_type -&gt; user.User
        7, // 9: user.UserService.Subscribe:output_type -&gt; user.Empty
        7, // 10: user.UserService.Unsubscribe:output_type -&gt; user.Empty
        2, // 11: user.UserService.GetSubscriptions:output_type -&gt; user.GetSubscriptionsResponse
        6, // 12: user.UserService.GetSubscribers:output_type -&gt; user.GetSubscribersResponse
        4, // 13: user.UserService.UpdateUser:output_type -&gt; user.User
        8, // [8:14] is the sub-list for method output_type
        2, // [2:8] is the sub-list for method input_type
        2, // [2:2] is the sub-list for extension type_name
        2, // [2:2] is the sub-list for extension extendee
        0, // [0:2] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_user_proto_init() }</span>
func file_user_proto_init() <span class="cov8" title="1">{
        if File_user_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_user_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   8,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_user_proto_goTypes,
                DependencyIndexes: file_user_proto_depIdxs,
                MessageInfos:      file_user_proto_msgTypes,
        }.Build()
        File_user_proto = out.File
        file_user_proto_rawDesc = nil
        file_user_proto_goTypes = nil
        file_user_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file141" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: user.proto

package user

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        UserService_GetUserByID_FullMethodName      = "/user.UserService/GetUserByID"
        UserService_Subscribe_FullMethodName        = "/user.UserService/Subscribe"
        UserService_Unsubscribe_FullMethodName      = "/user.UserService/Unsubscribe"
        UserService_GetSubscriptions_FullMethodName = "/user.UserService/GetSubscriptions"
        UserService_GetSubscribers_FullMethodName   = "/user.UserService/GetSubscribers"
        UserService_UpdateUser_FullMethodName       = "/user.UserService/UpdateUser"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
        GetUserByID(ctx context.Context, in *GetUserByIDRequest, opts ...grpc.CallOption) (*User, error)
        Subscribe(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (*Empty, error)
        Unsubscribe(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (*Empty, error)
        GetSubscriptions(ctx context.Context, in *GetSubscriptionsRequest, opts ...grpc.CallOption) (*GetSubscriptionsResponse, error)
        GetSubscribers(ctx context.Context, in *GetSubscribersRequest, opts ...grpc.CallOption) (*GetSubscribersResponse, error)
        UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
}

type userServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient <span class="cov0" title="0">{
        return &amp;userServiceClient{cc}
}</span>

func (c *userServiceClient) GetUserByID(ctx context.Context, in *GetUserByIDRequest, opts ...grpc.CallOption) (*User, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(User)
        err := c.cc.Invoke(ctx, UserService_GetUserByID_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) Subscribe(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Empty)
        err := c.cc.Invoke(ctx, UserService_Subscribe_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) Unsubscribe(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Empty)
        err := c.cc.Invoke(ctx, UserService_Unsubscribe_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) GetSubscriptions(ctx context.Context, in *GetSubscriptionsRequest, opts ...grpc.CallOption) (*GetSubscriptionsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetSubscriptionsResponse)
        err := c.cc.Invoke(ctx, UserService_GetSubscriptions_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) GetSubscribers(ctx context.Context, in *GetSubscribersRequest, opts ...grpc.CallOption) (*GetSubscribersResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetSubscribersResponse)
        err := c.cc.Invoke(ctx, UserService_GetSubscribers_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(User)
        err := c.cc.Invoke(ctx, UserService_UpdateUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
type UserServiceServer interface {
        GetUserByID(context.Context, *GetUserByIDRequest) (*User, error)
        Subscribe(context.Context, *Subscription) (*Empty, error)
        Unsubscribe(context.Context, *Subscription) (*Empty, error)
        GetSubscriptions(context.Context, *GetSubscriptionsRequest) (*GetSubscriptionsResponse, error)
        GetSubscribers(context.Context, *GetSubscribersRequest) (*GetSubscribersResponse, error)
        UpdateUser(context.Context, *User) (*User, error)
        mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) GetUserByID(context.Context, *GetUserByIDRequest) (*User, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserByID not implemented")
}</span>
func (UnimplementedUserServiceServer) Subscribe(context.Context, *Subscription) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}</span>
func (UnimplementedUserServiceServer) Unsubscribe(context.Context, *Subscription) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Unsubscribe not implemented")
}</span>
func (UnimplementedUserServiceServer) GetSubscriptions(context.Context, *GetSubscriptionsRequest) (*GetSubscriptionsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetSubscriptions not implemented")
}</span>
func (UnimplementedUserServiceServer) GetSubscribers(context.Context, *GetSubscribersRequest) (*GetSubscribersResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetSubscribers not implemented")
}</span>
func (UnimplementedUserServiceServer) UpdateUser(context.Context, *User) (*User, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}</span>
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {<span class="cov0" title="0">}</span>

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
        mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedUserServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;UserService_ServiceDesc, srv)</span>
}

func _UserService_GetUserByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserByIDRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetUserByID(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_GetUserByID_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetUserByID(ctx, req.(*GetUserByIDRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(Subscription)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).Subscribe(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_Subscribe_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).Subscribe(ctx, req.(*Subscription))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(Subscription)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).Unsubscribe(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_Unsubscribe_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).Unsubscribe(ctx, req.(*Subscription))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_GetSubscriptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetSubscriptionsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetSubscriptions(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_GetSubscriptions_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetSubscriptions(ctx, req.(*GetSubscriptionsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_GetSubscribers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetSubscribersRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetSubscribers(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_GetSubscribers_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetSubscribers(ctx, req.(*GetSubscribersRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(User)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).UpdateUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_UpdateUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).UpdateUser(ctx, req.(*User))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "user.UserService",
        HandlerType: (*UserServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetUserByID",
                        Handler:    _UserService_GetUserByID_Handler,
                },
                {
                        MethodName: "Subscribe",
                        Handler:    _UserService_Subscribe_Handler,
                },
                {
                        MethodName: "Unsubscribe",
                        Handler:    _UserService_Unsubscribe_Handler,
                },
                {
                        MethodName: "GetSubscriptions",
                        Handler:    _UserService_GetSubscriptions_Handler,
                },
                {
                        MethodName: "GetSubscribers",
                        Handler:    _UserService_GetSubscribers_Handler,
                },
                {
                        MethodName: "UpdateUser",
                        Handler:    _UserService_UpdateUser_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "user.proto",
}
</pre>
		
		<pre class="file" id="file142" style="display: none">package grpc

import (
        "context"
        "errors"

        "kudago/internal/models"
        pb "kudago/internal/user/api"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) GetUserByID(ctx context.Context, in *pb.GetUserByIDRequest) (*pb.User, error) <span class="cov8" title="1">{
        userData, err := s.service.GetUserByID(ctx, int(in.ID))
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "get user by id", err)
                if errors.Is(err, models.ErrUserNotFound) </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.NotFound, ErrUserNotFound)
                }</span>
                <span class="cov8" title="1">return nil, status.Error(codes.Internal, ErrInternal)</span>
        }

        <span class="cov8" title="1">user := userToUserPb(userData)

        return user, nil</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">package grpc

import (
        "context"

        "kudago/internal/models"
        pb "kudago/internal/user/api"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) GetSubscribers(ctx context.Context, in *pb.GetSubscribersRequest) (*pb.GetSubscribersResponse, error) <span class="cov8" title="1">{
        usersData, err := s.service.GetSubscribers(ctx, int(in.ID))
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "get subscribers", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>

        <span class="cov8" title="1">users := usersToGetSubscribersResponse(usersData)

        return users, nil</span>
}

func usersToGetSubscribersResponse(users []models.User) *pb.GetSubscribersResponse <span class="cov8" title="1">{
        resp := &amp;pb.GetSubscribersResponse{}

        for _, user := range users </span><span class="cov8" title="1">{
                userResp := userToUserPb(user)
                resp.Users = append(resp.Users, userResp)
        }</span>
        <span class="cov8" title="1">return resp</span>
}
</pre>
		
		<pre class="file" id="file144" style="display: none">package grpc

import (
        "context"
        "errors"

        "kudago/internal/models"
        pb "kudago/internal/user/api"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) GetSubscriptions(ctx context.Context, in *pb.GetSubscriptionsRequest) (*pb.GetSubscriptionsResponse, error) <span class="cov8" title="1">{
        usersData, err := s.service.GetSubscriptions(ctx, int(in.ID))
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrUserNotFound) </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.NotFound, ErrUserNotFound)
                }</span>
                <span class="cov8" title="1">s.logger.Error(ctx, "get subscriptions", err)
                return nil, status.Error(codes.Internal, ErrInternal)</span>
        }

        <span class="cov8" title="1">users := usersToUsersPb(usersData)

        return users, nil</span>
}

func usersToUsersPb(users []models.User) *pb.GetSubscriptionsResponse <span class="cov8" title="1">{
        resp := &amp;pb.GetSubscriptionsResponse{}

        for _, user := range users </span><span class="cov8" title="1">{
                userResp := userToUserPb(user)
                resp.Users = append(resp.Users, userResp)
        }</span>
        <span class="cov8" title="1">return resp</span>
}
</pre>
		
		<pre class="file" id="file145" style="display: none">package grpc

import (
        "context"

        "kudago/internal/models"
        pb "kudago/internal/user/api"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) Subscribe(ctx context.Context, in *pb.Subscription) (*pb.Empty, error) <span class="cov8" title="1">{
        subscription := subscriptionPBToSubscription(in)

        err := s.service.Subscribe(ctx, subscription)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "subscribe", err)
                switch err </span>{
                case models.ErrForeignKeyViolation:<span class="cov8" title="1">
                        return nil, status.Error(codes.NotFound, ErrUserNotFound)</span>
                case models.ErrNothingToInsert:<span class="cov8" title="1">
                        return nil, status.Error(codes.AlreadyExists, ErrSubscriptionAlreadyExists)</span>
                default:<span class="cov8" title="1">
                        return nil, status.Error(codes.Internal, ErrInternal)</span>
                }
        }

        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file146" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: user.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        models "kudago/internal/models"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockUserService is a mock of UserService interface.
type MockUserService struct {
        ctrl     *gomock.Controller
        recorder *MockUserServiceMockRecorder
}

// MockUserServiceMockRecorder is the mock recorder for MockUserService.
type MockUserServiceMockRecorder struct {
        mock *MockUserService
}

// NewMockUserService creates a new mock instance.
func NewMockUserService(ctrl *gomock.Controller) *MockUserService <span class="cov8" title="1">{
        mock := &amp;MockUserService{ctrl: ctrl}
        mock.recorder = &amp;MockUserServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserService) EXPECT() *MockUserServiceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// GetSubscribers mocks base method.
func (m *MockUserService) GetSubscribers(ctx context.Context, ID int) ([]models.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSubscribers", ctx, ID)
        ret0, _ := ret[0].([]models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSubscribers indicates an expected call of GetSubscribers.
func (mr *MockUserServiceMockRecorder) GetSubscribers(ctx, ID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubscribers", reflect.TypeOf((*MockUserService)(nil).GetSubscribers), ctx, ID)
}</span>

// GetSubscriptions mocks base method.
func (m *MockUserService) GetSubscriptions(ctx context.Context, ID int) ([]models.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSubscriptions", ctx, ID)
        ret0, _ := ret[0].([]models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSubscriptions indicates an expected call of GetSubscriptions.
func (mr *MockUserServiceMockRecorder) GetSubscriptions(ctx, ID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubscriptions", reflect.TypeOf((*MockUserService)(nil).GetSubscriptions), ctx, ID)
}</span>

// GetUserByID mocks base method.
func (m *MockUserService) GetUserByID(ctx context.Context, ID int) (models.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByID", ctx, ID)
        ret0, _ := ret[0].(models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByID indicates an expected call of GetUserByID.
func (mr *MockUserServiceMockRecorder) GetUserByID(ctx, ID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByID", reflect.TypeOf((*MockUserService)(nil).GetUserByID), ctx, ID)
}</span>

// Subscribe mocks base method.
func (m *MockUserService) Subscribe(ctx context.Context, subscription models.Subscription) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Subscribe", ctx, subscription)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Subscribe indicates an expected call of Subscribe.
func (mr *MockUserServiceMockRecorder) Subscribe(ctx, subscription interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockUserService)(nil).Subscribe), ctx, subscription)
}</span>

// Unsubscribe mocks base method.
func (m *MockUserService) Unsubscribe(ctx context.Context, subscription models.Subscription) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Unsubscribe", ctx, subscription)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Unsubscribe indicates an expected call of Unsubscribe.
func (mr *MockUserServiceMockRecorder) Unsubscribe(ctx, subscription interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockUserService)(nil).Unsubscribe), ctx, subscription)
}</span>

// UpdateUser mocks base method.
func (m *MockUserService) UpdateUser(ctx context.Context, user models.User) (models.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateUser", ctx, user)
        ret0, _ := ret[0].(models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateUser indicates an expected call of UpdateUser.
func (mr *MockUserServiceMockRecorder) UpdateUser(ctx, user interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUser", reflect.TypeOf((*MockUserService)(nil).UpdateUser), ctx, user)
}</span>

// UserExists mocks base method.
func (m *MockUserService) UserExists(ctx context.Context, user models.User) (bool, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UserExists", ctx, user)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UserExists indicates an expected call of UserExists.
func (mr *MockUserServiceMockRecorder) UserExists(ctx, user interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserExists", reflect.TypeOf((*MockUserService)(nil).UserExists), ctx, user)
}</span>
</pre>
		
		<pre class="file" id="file147" style="display: none">package grpc

import (
        "context"
        "errors"

        "kudago/internal/models"
        pb "kudago/internal/user/api"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) Unsubscribe(ctx context.Context, in *pb.Subscription) (*pb.Empty, error) <span class="cov8" title="1">{
        subscription := subscriptionPBToSubscription(in)

        err := s.service.Unsubscribe(ctx, subscription)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrNotFound) </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.NotFound, ErrUserNotFound)
                }</span>
                <span class="cov8" title="1">s.logger.Error(ctx, "unsubscribe", err)
                return nil, status.Error(codes.Internal, ErrInternal)</span>
        }

        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file148" style="display: none">package grpc

import (
        "context"

        "kudago/internal/models"
        pb "kudago/internal/user/api"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *ServerAPI) UpdateUser(ctx context.Context, in *pb.User) (*pb.User, error) <span class="cov8" title="1">{
        user := models.User{
                ID:       int(in.ID),
                Username: in.Username,
                Email:    in.Email,
                ImageURL: in.AvatarUrl,
        }

        userExists, err := s.service.UserExists(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>

        <span class="cov8" title="1">if userExists </span><span class="cov8" title="1">{
                return nil, status.Error(codes.AlreadyExists, ErrUsernameOrEmailIsTaken)
        }</span>

        <span class="cov8" title="1">userData, err := s.service.UpdateUser(ctx, user)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(ctx, "update user", err)
                return nil, status.Error(codes.Internal, ErrInternal)
        }</span>

        <span class="cov8" title="1">resp := userToUserPb(userData)

        return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file149" style="display: none">//go:generate mockgen -source=user.go -destination=tests/mocks/user.go -package=mocks

package grpc

import (
        "context"

        "kudago/internal/logger"
        "kudago/internal/models"
        pb "kudago/internal/user/api"
)

type ServerAPI struct {
        pb.UnimplementedUserServiceServer
        service UserService
        logger  *logger.Logger
}

type UserService interface {
        GetUserByID(ctx context.Context, ID int) (models.User, error)
        Subscribe(ctx context.Context, subscription models.Subscription) error
        Unsubscribe(ctx context.Context, subscription models.Subscription) error
        GetSubscriptions(ctx context.Context, ID int) ([]models.User, error)
        UpdateUser(ctx context.Context, user models.User) (models.User, error)
        UserExists(ctx context.Context, user models.User) (bool, error)
        GetSubscribers(ctx context.Context, ID int) ([]models.User, error)
}

func NewServerAPI(service UserService, logger *logger.Logger) *ServerAPI <span class="cov8" title="1">{
        return &amp;ServerAPI{
                service: service,
                logger:  logger,
        }
}</span>

func userToUserPb(userData models.User) *pb.User <span class="cov8" title="1">{
        return &amp;pb.User{
                ID:        int32(userData.ID),
                Username:  userData.Username,
                Email:     userData.Email,
                AvatarUrl: userData.ImageURL,
        }
}</span>

func subscriptionPBToSubscription(subscription *pb.Subscription) models.Subscription <span class="cov8" title="1">{
        return models.Subscription{
                SubscriberID: int(subscription.SubscriberID),
                FollowsID:    int(subscription.FollowsID),
        }
}</span>
</pre>
		
		<pre class="file" id="file150" style="display: none">package userRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

const getSubscribersQuery = `
        SELECT u.id, u.username, u.email, u.url_to_avatar
        FROM "USER" u
        JOIN SUBSCRIPTION s ON s.subscriber_id = u.id
        WHERE s.follows_id = $1;
`

func (d UserDB) GetSubscribers(ctx context.Context, ID int) ([]models.User, error) <span class="cov8" title="1">{
        rows, err := d.pool.Query(ctx, getSubscribersQuery, ID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var subscriptions []models.User
        for rows.Next() </span><span class="cov8" title="1">{
                var user models.User
                err = rows.Scan(&amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.ImageURL)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>
                <span class="cov8" title="1">subscriptions = append(subscriptions, user)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov8" title="1">return subscriptions, nil</span>
}
</pre>
		
		<pre class="file" id="file151" style="display: none">package userRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

const getSubscriptionsQuery = `
        SELECT u.id, u.username, u.email, u.url_to_avatar
        FROM "USER" u
        JOIN SUBSCRIPTION s ON s.follows_id = u.id
        WHERE s.subscriber_id = $1;
`

func (d UserDB) GetSubscriptions(ctx context.Context, ID int) ([]models.User, error) <span class="cov8" title="1">{
        rows, err := d.pool.Query(ctx, getSubscriptionsQuery, ID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var subscriptions []models.User
        for rows.Next() </span><span class="cov8" title="1">{
                var user models.User
                err = rows.Scan(&amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.ImageURL)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
                }</span>
                <span class="cov8" title="1">subscriptions = append(subscriptions, user)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov8" title="1">return subscriptions, nil</span>
}
</pre>
		
		<pre class="file" id="file152" style="display: none">package userRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"

        "github.com/jackc/pgx/v5"
        "github.com/pkg/errors"
)

const getUserByEmailOrUsernameQuery = `
                SELECT id 
                FROM "USER" 
                WHERE (username = $1 OR email = $2)`

func (d *UserDB) UserExists(ctx context.Context, user models.User) (bool, error) <span class="cov8" title="1">{
        var exists int
        query := getUserByEmailOrUsernameQuery
        args := []interface{}{user.Username, user.Email}

        if user.ID &gt; 0 </span><span class="cov0" title="0">{
                query += " AND id != $3"
                args = append(args, user.ID)
        }</span>

        <span class="cov8" title="1">err := d.pool.QueryRow(ctx, query, args...).Scan(&amp;exists)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">return false, fmt.Errorf("%s: %w", models.LevelDB, err)</span>
        }

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file153" style="display: none">package userRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"

        "github.com/jackc/pgx/v5"
)

const getUserByIDQuery = `SELECT id, username, email, url_to_avatar FROM "USER" WHERE id=$1`

func (d UserDB) GetUserByID(ctx context.Context, ID int) (models.User, error) <span class="cov8" title="1">{
        var userInfo UserInfo

        err := d.pool.QueryRow(ctx, getUserByIDQuery, ID).Scan(
                &amp;userInfo.ID,
                &amp;userInfo.Username,
                &amp;userInfo.Email,
                &amp;userInfo.ImageURL,
        )

        if err == pgx.ErrNoRows </span><span class="cov8" title="1">{
                return models.User{}, fmt.Errorf("%s: %w", models.LevelDB, models.ErrUserNotFound)
        }</span>

        <span class="cov8" title="1">user := toDomainUser(userInfo)
        return user, err</span>
}
</pre>
		
		<pre class="file" id="file154" style="display: none">package userRepository

import (
        "context"
        "errors"
        "fmt"

        "kudago/internal/models"

        "github.com/jackc/pgx/v5/pgconn"
)

const insertSubscription = `
        INSERT INTO SUBSCRIPTION (subscriber_id, follows_id)
        VALUES ($1, $2)
        ON CONFLICT DO NOTHING`

func (db *UserDB) Subscribe(ctx context.Context, subscription models.Subscription) error <span class="cov0" title="0">{
        result, err := db.pool.Exec(ctx, insertSubscription, subscription.SubscriberID, subscription.FollowsID)
        if err != nil </span><span class="cov0" title="0">{
                var pgErr *pgconn.PgError
                if errors.As(err, &amp;pgErr) </span><span class="cov0" title="0">{
                        return models.ErrForeignKeyViolation
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("%s: %w", models.LevelDB, err)</span>
        }

        <span class="cov0" title="0">rowsAffected := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                return models.ErrNothingToInsert
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file155" style="display: none">package userRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

const deleteSubscription = `
        DELETE FROM SUBSCRIPTION
        WHERE subscriber_id=$1 AND follows_id=$2`

func (db *UserDB) Unsubscribe(ctx context.Context, subscription models.Subscription) error <span class="cov8" title="1">{
        result, err := db.pool.Exec(ctx, deleteSubscription, subscription.SubscriberID, subscription.FollowsID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov8" title="1">rowsAffected := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov8" title="1">{
                return models.ErrNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">package userRepository

import (
        "context"
        "fmt"

        "kudago/internal/models"
)

const updateUserQuery = `
        UPDATE "USER"
        SET 
                username = COALESCE($2, username), 
                email = COALESCE($3, email), 
                URL_to_avatar = COALESCE($4, URL_to_avatar), 
                modified_at = NOW()
        WHERE id = $1 
        RETURNING id, username, email, URL_to_avatar
`

func (db *UserDB) UpdateUser(ctx context.Context, updatedUser models.User) (models.User, error) <span class="cov0" title="0">{
        var user models.User
        err := db.pool.QueryRow(ctx, updateUserQuery,
                updatedUser.ID,
                nilIfEmpty(updatedUser.Username),
                nilIfEmpty(updatedUser.Email),
                nilIfEmpty(updatedUser.ImageURL),
        ).Scan(&amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.ImageURL)
        if err != nil </span><span class="cov0" title="0">{
                return models.User{}, fmt.Errorf("%s: %w", models.LevelDB, err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file157" style="display: none">package userRepository

import (
        "context"
        "time"

        "kudago/internal/models"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type UserInfo struct {
        ID         int       `db:"id"`
        Username   string    `db:"username"`
        Email      string    `db:"email"`
        ImageURL   *string   `db:"url_to_avatar"`
        CreatedAt  time.Time `db:"created_at"`
        ModifiedAt time.Time `db:"modified_at"`
}

type UserDB struct {
        pool Pool
}

func NewDB(pool Pool) *UserDB <span class="cov8" title="1">{
        return &amp;UserDB{
                pool: pool,
        }
}</span>

type Pool interface {
        Begin(ctx context.Context) (pgx.Tx, error)
        Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error)
        Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error)
        QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
        SendBatch(ctx context.Context, b *pgx.Batch) pgx.BatchResults
}

func nilIfEmpty(value string) *string <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;value</span>
}

func toDomainUser(user UserInfo) models.User <span class="cov8" title="1">{
        var imageURL string
        if user.ImageURL == nil </span><span class="cov8" title="1">{
                imageURL = ""
        }</span> else<span class="cov0" title="0"> {
                imageURL = *user.ImageURL
        }</span>

        <span class="cov8" title="1">return models.User{
                ID:       user.ID,
                Username: user.Username,
                Email:    user.Email,
                ImageURL: imageURL,
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
